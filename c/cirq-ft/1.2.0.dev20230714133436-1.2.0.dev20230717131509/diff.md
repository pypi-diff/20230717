# Comparing `tmp/cirq_ft-1.2.0.dev20230714133436-py3-none-any.whl.zip` & `tmp/cirq_ft-1.2.0.dev20230717131509-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,72 +1,72 @@
-Zip file size: 138409 bytes, number of entries: 70
--rw-r--r--  2.0 unx     1546 b- defN 23-Jul-14 13:34 cirq_ft/__init__.py
--rw-r--r--  2.0 unx       40 b- defN 23-Jul-14 13:34 cirq_ft/_version.py
--rw-r--r--  2.0 unx     1935 b- defN 23-Jul-14 13:34 cirq_ft/algos/__init__.py
--rw-r--r--  2.0 unx     6324 b- defN 23-Jul-14 13:34 cirq_ft/algos/and_gate.py
--rw-r--r--  2.0 unx     9377 b- defN 23-Jul-14 13:34 cirq_ft/algos/and_gate_test.py
--rw-r--r--  2.0 unx     3822 b- defN 23-Jul-14 13:34 cirq_ft/algos/apply_gate_to_lth_target.py
--rw-r--r--  2.0 unx     4001 b- defN 23-Jul-14 13:34 cirq_ft/algos/apply_gate_to_lth_target_test.py
--rw-r--r--  2.0 unx    16191 b- defN 23-Jul-14 13:34 cirq_ft/algos/arithmetic_gates.py
--rw-r--r--  2.0 unx    13900 b- defN 23-Jul-14 13:34 cirq_ft/algos/arithmetic_gates_test.py
--rw-r--r--  2.0 unx     5611 b- defN 23-Jul-14 13:34 cirq_ft/algos/generic_select.py
--rw-r--r--  2.0 unx    11576 b- defN 23-Jul-14 13:34 cirq_ft/algos/generic_select_test.py
--rw-r--r--  2.0 unx    14436 b- defN 23-Jul-14 13:34 cirq_ft/algos/hubbard_model.py
--rw-r--r--  2.0 unx     2984 b- defN 23-Jul-14 13:34 cirq_ft/algos/hubbard_model_test.py
--rw-r--r--  2.0 unx     4341 b- defN 23-Jul-14 13:34 cirq_ft/algos/multi_control_multi_target_pauli.py
--rw-r--r--  2.0 unx     1584 b- defN 23-Jul-14 13:34 cirq_ft/algos/multi_control_multi_target_pauli_test.py
--rw-r--r--  2.0 unx     4016 b- defN 23-Jul-14 13:34 cirq_ft/algos/prepare_uniform_superposition.py
--rw-r--r--  2.0 unx     3398 b- defN 23-Jul-14 13:34 cirq_ft/algos/prepare_uniform_superposition_test.py
--rw-r--r--  2.0 unx     9267 b- defN 23-Jul-14 13:34 cirq_ft/algos/programmable_rotation_gate_array.py
--rw-r--r--  2.0 unx     5966 b- defN 23-Jul-14 13:34 cirq_ft/algos/programmable_rotation_gate_array_test.py
--rw-r--r--  2.0 unx     7451 b- defN 23-Jul-14 13:34 cirq_ft/algos/qrom.py
--rw-r--r--  2.0 unx     7101 b- defN 23-Jul-14 13:34 cirq_ft/algos/qrom_test.py
--rw-r--r--  2.0 unx     6350 b- defN 23-Jul-14 13:34 cirq_ft/algos/qubitization_walk_operator.py
--rw-r--r--  2.0 unx    13615 b- defN 23-Jul-14 13:34 cirq_ft/algos/qubitization_walk_operator_test.py
--rw-r--r--  2.0 unx     5399 b- defN 23-Jul-14 13:34 cirq_ft/algos/reflection_using_prepare.py
--rw-r--r--  2.0 unx    14779 b- defN 23-Jul-14 13:34 cirq_ft/algos/reflection_using_prepare_test.py
--rw-r--r--  2.0 unx     2827 b- defN 23-Jul-14 13:34 cirq_ft/algos/select_and_prepare.py
--rw-r--r--  2.0 unx    10850 b- defN 23-Jul-14 13:34 cirq_ft/algos/select_swap_qrom.py
--rw-r--r--  2.0 unx     3976 b- defN 23-Jul-14 13:34 cirq_ft/algos/select_swap_qrom_test.py
--rw-r--r--  2.0 unx     4168 b- defN 23-Jul-14 13:34 cirq_ft/algos/selected_majorana_fermion.py
--rw-r--r--  2.0 unx     7405 b- defN 23-Jul-14 13:34 cirq_ft/algos/selected_majorana_fermion_test.py
--rw-r--r--  2.0 unx     6871 b- defN 23-Jul-14 13:34 cirq_ft/algos/state_preparation.py
--rw-r--r--  2.0 unx     6433 b- defN 23-Jul-14 13:34 cirq_ft/algos/state_preparation_test.py
--rw-r--r--  2.0 unx     8722 b- defN 23-Jul-14 13:34 cirq_ft/algos/swap_network.py
--rw-r--r--  2.0 unx     6530 b- defN 23-Jul-14 13:34 cirq_ft/algos/swap_network_test.py
--rw-r--r--  2.0 unx    17396 b- defN 23-Jul-14 13:34 cirq_ft/algos/unary_iteration_gate.py
--rw-r--r--  2.0 unx     8003 b- defN 23-Jul-14 13:34 cirq_ft/algos/unary_iteration_gate_test.py
--rw-r--r--  2.0 unx      849 b- defN 23-Jul-14 13:34 cirq_ft/algos/mean_estimation/__init__.py
--rw-r--r--  2.0 unx     2263 b- defN 23-Jul-14 13:34 cirq_ft/algos/mean_estimation/arctan.py
--rw-r--r--  2.0 unx     1875 b- defN 23-Jul-14 13:34 cirq_ft/algos/mean_estimation/arctan_test.py
--rw-r--r--  2.0 unx     3195 b- defN 23-Jul-14 13:34 cirq_ft/algos/mean_estimation/complex_phase_oracle.py
--rw-r--r--  2.0 unx     3407 b- defN 23-Jul-14 13:34 cirq_ft/algos/mean_estimation/complex_phase_oracle_test.py
--rw-r--r--  2.0 unx     7049 b- defN 23-Jul-14 13:34 cirq_ft/algos/mean_estimation/mean_estimation_operator.py
--rw-r--r--  2.0 unx    10399 b- defN 23-Jul-14 13:34 cirq_ft/algos/mean_estimation/mean_estimation_operator_test.py
--rw-r--r--  2.0 unx     1006 b- defN 23-Jul-14 13:34 cirq_ft/infra/__init__.py
--rw-r--r--  2.0 unx     3520 b- defN 23-Jul-14 13:34 cirq_ft/infra/bit_tools.py
--rw-r--r--  2.0 unx     2838 b- defN 23-Jul-14 13:34 cirq_ft/infra/bit_tools_test.py
--rw-r--r--  2.0 unx     3647 b- defN 23-Jul-14 13:34 cirq_ft/infra/decompose_protocol.py
--rw-r--r--  2.0 unx     1784 b- defN 23-Jul-14 13:34 cirq_ft/infra/decompose_protocol_test.py
--rw-r--r--  2.0 unx    12231 b- defN 23-Jul-14 13:34 cirq_ft/infra/gate_with_registers.py
--rw-r--r--  2.0 unx     4949 b- defN 23-Jul-14 13:34 cirq_ft/infra/gate_with_registers_test.py
--rw-r--r--  2.0 unx     3938 b- defN 23-Jul-14 13:34 cirq_ft/infra/jupyter_tools.py
--rw-r--r--  2.0 unx     1992 b- defN 23-Jul-14 13:34 cirq_ft/infra/jupyter_tools_test.py
--rw-r--r--  2.0 unx     9405 b- defN 23-Jul-14 13:34 cirq_ft/infra/qubit_management_transformers.py
--rw-r--r--  2.0 unx    13631 b- defN 23-Jul-14 13:34 cirq_ft/infra/qubit_management_transformers_test.py
--rw-r--r--  2.0 unx     3853 b- defN 23-Jul-14 13:34 cirq_ft/infra/qubit_manager.py
--rw-r--r--  2.0 unx     3126 b- defN 23-Jul-14 13:34 cirq_ft/infra/qubit_manager_test.py
--rw-r--r--  2.0 unx     6693 b- defN 23-Jul-14 13:34 cirq_ft/infra/t_complexity_protocol.py
--rw-r--r--  2.0 unx     7836 b- defN 23-Jul-14 13:34 cirq_ft/infra/t_complexity_protocol_test.py
--rw-r--r--  2.0 unx     5244 b- defN 23-Jul-14 13:34 cirq_ft/infra/testing.py
--rw-r--r--  2.0 unx     2683 b- defN 23-Jul-14 13:34 cirq_ft/infra/testing_test.py
--rw-r--r--  2.0 unx      809 b- defN 23-Jul-14 13:34 cirq_ft/infra/type_convertors.py
--rw-r--r--  2.0 unx      772 b- defN 23-Jul-14 13:34 cirq_ft/infra/type_convertors_test.py
--rw-r--r--  2.0 unx      673 b- defN 23-Jul-14 13:34 cirq_ft/linalg/__init__.py
--rw-r--r--  2.0 unx     8140 b- defN 23-Jul-14 13:34 cirq_ft/linalg/lcu_util.py
--rw-r--r--  2.0 unx     6420 b- defN 23-Jul-14 13:34 cirq_ft/linalg/lcu_util_test.py
--rw-r--r--  2.0 unx    11357 b- defN 23-Jul-14 13:34 cirq_ft-1.2.0.dev20230714133436.dist-info/LICENSE
--rw-r--r--  2.0 unx     1509 b- defN 23-Jul-14 13:34 cirq_ft-1.2.0.dev20230714133436.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jul-14 13:34 cirq_ft-1.2.0.dev20230714133436.dist-info/WHEEL
--rw-r--r--  2.0 unx        8 b- defN 23-Jul-14 13:34 cirq_ft-1.2.0.dev20230714133436.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     6633 b- defN 23-Jul-14 13:34 cirq_ft-1.2.0.dev20230714133436.dist-info/RECORD
-70 files, 412017 bytes uncompressed, 127675 bytes compressed:  69.0%
+Zip file size: 141703 bytes, number of entries: 70
+-rw-r--r--  2.0 unx     1546 b- defN 23-Jul-17 13:15 cirq_ft/__init__.py
+-rw-r--r--  2.0 unx       40 b- defN 23-Jul-17 13:15 cirq_ft/_version.py
+-rw-r--r--  2.0 unx     1978 b- defN 23-Jul-17 13:15 cirq_ft/algos/__init__.py
+-rw-r--r--  2.0 unx     6324 b- defN 23-Jul-17 13:15 cirq_ft/algos/and_gate.py
+-rw-r--r--  2.0 unx     9377 b- defN 23-Jul-17 13:15 cirq_ft/algos/and_gate_test.py
+-rw-r--r--  2.0 unx     3822 b- defN 23-Jul-17 13:15 cirq_ft/algos/apply_gate_to_lth_target.py
+-rw-r--r--  2.0 unx     4001 b- defN 23-Jul-17 13:15 cirq_ft/algos/apply_gate_to_lth_target_test.py
+-rw-r--r--  2.0 unx    27134 b- defN 23-Jul-17 13:15 cirq_ft/algos/arithmetic_gates.py
+-rw-r--r--  2.0 unx    17717 b- defN 23-Jul-17 13:15 cirq_ft/algos/arithmetic_gates_test.py
+-rw-r--r--  2.0 unx     5611 b- defN 23-Jul-17 13:15 cirq_ft/algos/generic_select.py
+-rw-r--r--  2.0 unx    11576 b- defN 23-Jul-17 13:15 cirq_ft/algos/generic_select_test.py
+-rw-r--r--  2.0 unx    14436 b- defN 23-Jul-17 13:15 cirq_ft/algos/hubbard_model.py
+-rw-r--r--  2.0 unx     2984 b- defN 23-Jul-17 13:15 cirq_ft/algos/hubbard_model_test.py
+-rw-r--r--  2.0 unx     4341 b- defN 23-Jul-17 13:15 cirq_ft/algos/multi_control_multi_target_pauli.py
+-rw-r--r--  2.0 unx     1584 b- defN 23-Jul-17 13:15 cirq_ft/algos/multi_control_multi_target_pauli_test.py
+-rw-r--r--  2.0 unx     4016 b- defN 23-Jul-17 13:15 cirq_ft/algos/prepare_uniform_superposition.py
+-rw-r--r--  2.0 unx     3398 b- defN 23-Jul-17 13:15 cirq_ft/algos/prepare_uniform_superposition_test.py
+-rw-r--r--  2.0 unx     9267 b- defN 23-Jul-17 13:15 cirq_ft/algos/programmable_rotation_gate_array.py
+-rw-r--r--  2.0 unx     5966 b- defN 23-Jul-17 13:15 cirq_ft/algos/programmable_rotation_gate_array_test.py
+-rw-r--r--  2.0 unx     7451 b- defN 23-Jul-17 13:15 cirq_ft/algos/qrom.py
+-rw-r--r--  2.0 unx     7101 b- defN 23-Jul-17 13:15 cirq_ft/algos/qrom_test.py
+-rw-r--r--  2.0 unx     6350 b- defN 23-Jul-17 13:15 cirq_ft/algos/qubitization_walk_operator.py
+-rw-r--r--  2.0 unx    13615 b- defN 23-Jul-17 13:15 cirq_ft/algos/qubitization_walk_operator_test.py
+-rw-r--r--  2.0 unx     5399 b- defN 23-Jul-17 13:15 cirq_ft/algos/reflection_using_prepare.py
+-rw-r--r--  2.0 unx    14779 b- defN 23-Jul-17 13:15 cirq_ft/algos/reflection_using_prepare_test.py
+-rw-r--r--  2.0 unx     2827 b- defN 23-Jul-17 13:15 cirq_ft/algos/select_and_prepare.py
+-rw-r--r--  2.0 unx    10850 b- defN 23-Jul-17 13:15 cirq_ft/algos/select_swap_qrom.py
+-rw-r--r--  2.0 unx     3976 b- defN 23-Jul-17 13:15 cirq_ft/algos/select_swap_qrom_test.py
+-rw-r--r--  2.0 unx     4168 b- defN 23-Jul-17 13:15 cirq_ft/algos/selected_majorana_fermion.py
+-rw-r--r--  2.0 unx     7405 b- defN 23-Jul-17 13:15 cirq_ft/algos/selected_majorana_fermion_test.py
+-rw-r--r--  2.0 unx     6871 b- defN 23-Jul-17 13:15 cirq_ft/algos/state_preparation.py
+-rw-r--r--  2.0 unx     6673 b- defN 23-Jul-17 13:15 cirq_ft/algos/state_preparation_test.py
+-rw-r--r--  2.0 unx     8722 b- defN 23-Jul-17 13:15 cirq_ft/algos/swap_network.py
+-rw-r--r--  2.0 unx     6530 b- defN 23-Jul-17 13:15 cirq_ft/algos/swap_network_test.py
+-rw-r--r--  2.0 unx    17396 b- defN 23-Jul-17 13:15 cirq_ft/algos/unary_iteration_gate.py
+-rw-r--r--  2.0 unx     8003 b- defN 23-Jul-17 13:15 cirq_ft/algos/unary_iteration_gate_test.py
+-rw-r--r--  2.0 unx      849 b- defN 23-Jul-17 13:15 cirq_ft/algos/mean_estimation/__init__.py
+-rw-r--r--  2.0 unx     2263 b- defN 23-Jul-17 13:15 cirq_ft/algos/mean_estimation/arctan.py
+-rw-r--r--  2.0 unx     1875 b- defN 23-Jul-17 13:15 cirq_ft/algos/mean_estimation/arctan_test.py
+-rw-r--r--  2.0 unx     3195 b- defN 23-Jul-17 13:15 cirq_ft/algos/mean_estimation/complex_phase_oracle.py
+-rw-r--r--  2.0 unx     3407 b- defN 23-Jul-17 13:15 cirq_ft/algos/mean_estimation/complex_phase_oracle_test.py
+-rw-r--r--  2.0 unx     7049 b- defN 23-Jul-17 13:15 cirq_ft/algos/mean_estimation/mean_estimation_operator.py
+-rw-r--r--  2.0 unx    10399 b- defN 23-Jul-17 13:15 cirq_ft/algos/mean_estimation/mean_estimation_operator_test.py
+-rw-r--r--  2.0 unx     1006 b- defN 23-Jul-17 13:15 cirq_ft/infra/__init__.py
+-rw-r--r--  2.0 unx     3520 b- defN 23-Jul-17 13:15 cirq_ft/infra/bit_tools.py
+-rw-r--r--  2.0 unx     2838 b- defN 23-Jul-17 13:15 cirq_ft/infra/bit_tools_test.py
+-rw-r--r--  2.0 unx     3647 b- defN 23-Jul-17 13:15 cirq_ft/infra/decompose_protocol.py
+-rw-r--r--  2.0 unx     1784 b- defN 23-Jul-17 13:15 cirq_ft/infra/decompose_protocol_test.py
+-rw-r--r--  2.0 unx    12231 b- defN 23-Jul-17 13:15 cirq_ft/infra/gate_with_registers.py
+-rw-r--r--  2.0 unx     4949 b- defN 23-Jul-17 13:15 cirq_ft/infra/gate_with_registers_test.py
+-rw-r--r--  2.0 unx     3938 b- defN 23-Jul-17 13:15 cirq_ft/infra/jupyter_tools.py
+-rw-r--r--  2.0 unx     1992 b- defN 23-Jul-17 13:15 cirq_ft/infra/jupyter_tools_test.py
+-rw-r--r--  2.0 unx     9405 b- defN 23-Jul-17 13:15 cirq_ft/infra/qubit_management_transformers.py
+-rw-r--r--  2.0 unx    13631 b- defN 23-Jul-17 13:15 cirq_ft/infra/qubit_management_transformers_test.py
+-rw-r--r--  2.0 unx     3853 b- defN 23-Jul-17 13:15 cirq_ft/infra/qubit_manager.py
+-rw-r--r--  2.0 unx     3126 b- defN 23-Jul-17 13:15 cirq_ft/infra/qubit_manager_test.py
+-rw-r--r--  2.0 unx     6693 b- defN 23-Jul-17 13:15 cirq_ft/infra/t_complexity_protocol.py
+-rw-r--r--  2.0 unx     7836 b- defN 23-Jul-17 13:15 cirq_ft/infra/t_complexity_protocol_test.py
+-rw-r--r--  2.0 unx     5244 b- defN 23-Jul-17 13:15 cirq_ft/infra/testing.py
+-rw-r--r--  2.0 unx     2683 b- defN 23-Jul-17 13:15 cirq_ft/infra/testing_test.py
+-rw-r--r--  2.0 unx      809 b- defN 23-Jul-17 13:15 cirq_ft/infra/type_convertors.py
+-rw-r--r--  2.0 unx      772 b- defN 23-Jul-17 13:15 cirq_ft/infra/type_convertors_test.py
+-rw-r--r--  2.0 unx      673 b- defN 23-Jul-17 13:15 cirq_ft/linalg/__init__.py
+-rw-r--r--  2.0 unx     8140 b- defN 23-Jul-17 13:15 cirq_ft/linalg/lcu_util.py
+-rw-r--r--  2.0 unx     6420 b- defN 23-Jul-17 13:15 cirq_ft/linalg/lcu_util_test.py
+-rw-r--r--  2.0 unx    11357 b- defN 23-Jul-17 13:15 cirq_ft-1.2.0.dev20230717131509.dist-info/LICENSE
+-rw-r--r--  2.0 unx     1509 b- defN 23-Jul-17 13:15 cirq_ft-1.2.0.dev20230717131509.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jul-17 13:15 cirq_ft-1.2.0.dev20230717131509.dist-info/WHEEL
+-rw-r--r--  2.0 unx        8 b- defN 23-Jul-17 13:15 cirq_ft-1.2.0.dev20230717131509.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     6633 b- defN 23-Jul-17 13:15 cirq_ft-1.2.0.dev20230717131509.dist-info/RECORD
+70 files, 427060 bytes uncompressed, 130969 bytes compressed:  69.3%
```

## zipnote {}

```diff
@@ -189,23 +189,23 @@
 
 Filename: cirq_ft/linalg/lcu_util.py
 Comment: 
 
 Filename: cirq_ft/linalg/lcu_util_test.py
 Comment: 
 
-Filename: cirq_ft-1.2.0.dev20230714133436.dist-info/LICENSE
+Filename: cirq_ft-1.2.0.dev20230717131509.dist-info/LICENSE
 Comment: 
 
-Filename: cirq_ft-1.2.0.dev20230714133436.dist-info/METADATA
+Filename: cirq_ft-1.2.0.dev20230717131509.dist-info/METADATA
 Comment: 
 
-Filename: cirq_ft-1.2.0.dev20230714133436.dist-info/WHEEL
+Filename: cirq_ft-1.2.0.dev20230717131509.dist-info/WHEEL
 Comment: 
 
-Filename: cirq_ft-1.2.0.dev20230714133436.dist-info/top_level.txt
+Filename: cirq_ft-1.2.0.dev20230717131509.dist-info/top_level.txt
 Comment: 
 
-Filename: cirq_ft-1.2.0.dev20230714133436.dist-info/RECORD
+Filename: cirq_ft-1.2.0.dev20230717131509.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## cirq_ft/_version.py

```diff
@@ -1 +1 @@
-__version__ = "1.2.0.dev20230714133436"
+__version__ = "1.2.0.dev20230717131509"
```

## cirq_ft/algos/__init__.py

```diff
@@ -16,14 +16,16 @@
 from cirq_ft.algos.apply_gate_to_lth_target import ApplyGateToLthQubit
 from cirq_ft.algos.arithmetic_gates import (
     AdditionGate,
     AddMod,
     ContiguousRegisterGate,
     LessThanEqualGate,
     LessThanGate,
+    SingleQubitCompare,
+    BiQubitsMixer,
 )
 from cirq_ft.algos.generic_select import GenericSelect
 from cirq_ft.algos.hubbard_model import PrepareHubbard, SelectHubbard
 from cirq_ft.algos.multi_control_multi_target_pauli import MultiControlPauli, MultiTargetCNOT
 from cirq_ft.algos.prepare_uniform_superposition import PrepareUniformSuperposition
 from cirq_ft.algos.programmable_rotation_gate_array import (
     ProgrammableRotationGateArray,
```

## cirq_ft/algos/arithmetic_gates.py

```diff
@@ -8,16 +8,17 @@
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-from typing import Iterable, Optional, Sequence, Tuple, Union
+from typing import Iterable, Optional, Sequence, Tuple, Union, List, Iterator
 
+from cirq._compat import cached_property
 import attr
 import cirq
 from cirq_ft import infra
 from cirq_ft.algos import and_gate
 
 
 @attr.frozen
@@ -74,15 +75,15 @@
         qubits, target = qubits[:-1], qubits[-1]
         # Trivial case, self._val is larger than any value the registers could represent
         if self.less_than_val >= 2**self.bitsize:
             yield cirq.X(target)
             return
         adjoint = []
 
-        [are_equal] = context.qubit_manager.qalloc(1)
+        (are_equal,) = context.qubit_manager.qalloc(1)
 
         # Initially our belief is that the numbers are equal.
         yield cirq.X(are_equal)
         adjoint.append(cirq.X(are_equal))
 
         # Scan from left to right.
         # `are_equal` contains whether the numbers are equal so far.
@@ -127,14 +128,155 @@
             return infra.TComplexity(clifford=1)
         return infra.TComplexity(
             t=4 * n, clifford=15 * n + 3 * bin(self.less_than_val).count("1") + 2
         )
 
 
 @attr.frozen
+class BiQubitsMixer(infra.GateWithRegisters):
+    """Implements the COMPARE2 (Fig. 1) https://static-content.springer.com/esm/art%3A10.1038%2Fs41534-018-0071-5/MediaObjects/41534_2018_71_MOESM1_ESM.pdf
+
+    This gates mixes the values in a way that preserves the result of comparison.
+    The registers being compared are 2-qubit registers where
+        x = 2*x_msb + x_lsb
+        y = 2*y_msb + y_lsb
+    The Gate mixes the 4 qubits so that sign(x - y) = sign(x_lsb' - y_lsb') where x_lsb' and y_lsb'
+    are the final values of x_lsb' and y_lsb'.
+    """  # pylint: disable=line-too-long
+
+    adjoint: bool = False
+
+    @cached_property
+    def registers(self) -> infra.Registers:
+        return infra.Registers.build(x=2, y=2, ancilla=3)
+
+    def __repr__(self) -> str:
+        return f'cirq_ft.algos.BiQubitsMixer({self.adjoint})'
+
+    def decompose_from_registers(
+        self, *, context: cirq.DecompositionContext, **quregs: Sequence[cirq.Qid]
+    ) -> cirq.OP_TREE:
+        x, y, ancilla = quregs['x'], quregs['y'], quregs['ancilla']
+        x_msb, x_lsb = x
+        y_msb, y_lsb = y
+
+        def _cswap(control: cirq.Qid, a: cirq.Qid, b: cirq.Qid, aux: cirq.Qid) -> cirq.OP_TREE:
+            """A CSWAP with 4T complexity and whose adjoint has 0T complexity.
+
+                A controlled SWAP that swaps `a` and `b` based on `control`.
+            It uses an extra qubit `aux` so that its adjoint would have
+            a T complexity of zero.
+            """
+            yield cirq.CNOT(a, b)
+            yield and_gate.And(adjoint=self.adjoint).on(control, b, aux)
+            yield cirq.CNOT(aux, a)
+            yield cirq.CNOT(a, b)
+
+        def _decomposition():
+            # computes the difference of x - y where
+            #   x = 2*x_msb + x_lsb
+            #   y = 2*y_msb + y_lsb
+            # And stores the result in x_lsb and y_lsb such that
+            #   sign(x - y) = sign(x_lsb - y_lsb)
+            # This decomposition uses 3 ancilla qubits in order to have a
+            # T complexity of 8.
+            yield cirq.X(ancilla[0])
+            yield cirq.CNOT(y_msb, x_msb)
+            yield cirq.CNOT(y_lsb, x_lsb)
+            yield from _cswap(x_msb, x_lsb, ancilla[0], ancilla[1])
+            yield from _cswap(x_msb, y_msb, y_lsb, ancilla[2])
+            yield cirq.CNOT(y_lsb, x_lsb)
+
+        if self.adjoint:
+            yield from reversed(tuple(cirq.flatten_to_ops(_decomposition())))
+        else:
+            yield from _decomposition()
+
+    def __pow__(self, power: int) -> cirq.Gate:
+        if power == 1:
+            return self
+        if power == -1:
+            return BiQubitsMixer(adjoint=not self.adjoint)
+        return NotImplemented  # coverage: ignore
+
+    def _t_complexity_(self) -> infra.TComplexity:
+        if self.adjoint:
+            return infra.TComplexity(clifford=18)
+        return infra.TComplexity(t=8, clifford=28)
+
+    def _has_unitary_(self):
+        return not self.adjoint
+
+
+@attr.frozen
+class SingleQubitCompare(infra.GateWithRegisters):
+    """Applies U|a>|b>|0>|0> = |a> |a=b> |(a<b)> |(a>b)>
+
+    Source: (FIG. 3) in https://static-content.springer.com/esm/art%3A10.1038%2Fs41534-018-0071-5/MediaObjects/41534_2018_71_MOESM1_ESM.pdf
+    """  # pylint: disable=line-too-long
+
+    adjoint: bool = False
+
+    @cached_property
+    def registers(self) -> infra.Registers:
+        return infra.Registers.build(a=1, b=1, less_than=1, greater_than=1)
+
+    def __repr__(self) -> str:
+        return f'cirq_ft.algos.SingleQubitCompare({self.adjoint})'
+
+    def decompose_from_registers(
+        self, *, context: cirq.DecompositionContext, **quregs: Sequence[cirq.Qid]
+    ) -> cirq.OP_TREE:
+        a = quregs['a']
+        b = quregs['b']
+        less_than = quregs['less_than']
+        greater_than = quregs['greater_than']
+
+        def _decomposition() -> Iterator[cirq.Operation]:
+            yield and_gate.And((0, 1), adjoint=self.adjoint).on(*a, *b, *less_than)
+            yield cirq.CNOT(*less_than, *greater_than)
+            yield cirq.CNOT(*b, *greater_than)
+            yield cirq.CNOT(*a, *b)
+            yield cirq.CNOT(*a, *greater_than)
+            yield cirq.X(*b)
+
+        if self.adjoint:
+            yield from reversed(tuple(_decomposition()))
+        else:
+            yield from _decomposition()
+
+    def __pow__(self, power: int) -> cirq.Gate:
+        if not isinstance(power, int):
+            raise ValueError('SingleQubitCompare is only defined for integer powers.')
+        if power % 2 == 0:
+            return cirq.IdentityGate(4)
+        if power < 0:
+            return SingleQubitCompare(adjoint=not self.adjoint)
+        return self
+
+    def _t_complexity_(self) -> infra.TComplexity:
+        if self.adjoint:
+            return infra.TComplexity(clifford=11)
+        return infra.TComplexity(t=4, clifford=16)
+
+
+def _equality_with_zero(
+    context: cirq.DecompositionContext, qubits: Sequence[cirq.Qid], z: cirq.Qid
+) -> cirq.OP_TREE:
+    if len(qubits) == 1:
+        (q,) = qubits
+        yield cirq.X(q)
+        yield cirq.CNOT(q, z)
+        return
+
+    ancilla = context.qubit_manager.qalloc(len(qubits) - 2)
+    yield and_gate.And(cv=[0] * len(qubits)).on(*qubits, *ancilla, z)
+
+
+@attr.frozen
 class LessThanEqualGate(cirq.ArithmeticGate):
     """Applies U|x>|y>|z> = |x>|y> |z ^ (x <= y)>"""
 
     x_bitsize: int
     y_bitsize: int
 
     def registers(self) -> Sequence[Union[int, Sequence[int]]]:
@@ -157,17 +299,138 @@
         if power in [1, -1]:
             return self
         return NotImplemented  # coverage: ignore
 
     def __repr__(self) -> str:
         return f'cirq_ft.LessThanEqualGate({self.x_bitsize}, {self.y_bitsize})'
 
+    def _decompose_via_tree(
+        self, context: cirq.DecompositionContext, X: Sequence[cirq.Qid], Y: Sequence[cirq.Qid]
+    ) -> cirq.OP_TREE:
+        """Returns comparison oracle from https://static-content.springer.com/esm/art%3A10.1038%2Fs41534-018-0071-5/MediaObjects/41534_2018_71_MOESM1_ESM.pdf
+
+        This decomposition follows the tree structure of (FIG. 2)
+        """  # pylint: disable=line-too-long
+        if len(X) == 1:
+            return
+        if len(X) == 2:
+            yield BiQubitsMixer().on_registers(x=X, y=Y, ancilla=context.qubit_manager.qalloc(3))
+            return
+
+        m = len(X) // 2
+        yield self._decompose_via_tree(context, X[:m], Y[:m])
+        yield self._decompose_via_tree(context, X[m:], Y[m:])
+        yield BiQubitsMixer().on_registers(
+            x=(X[m - 1], X[-1]), y=(Y[m - 1], Y[-1]), ancilla=context.qubit_manager.qalloc(3)
+        )
+
+    def _decompose_with_context_(
+        self, qubits: Sequence[cirq.Qid], context: Optional[cirq.DecompositionContext] = None
+    ) -> cirq.OP_TREE:
+        """Decomposes the gate in a T-complexity optimal way.
+
+        The construction can be broken in 4 parts:
+            1. In case of differing bitsizes then a multicontrol And Gate
+                - Section III.A. https://arxiv.org/abs/1805.03662) is used to check whether
+                the extra prefix is equal to zero:
+                    - result stored in: `prefix_equality` qubit.
+            2. The tree structure (FIG. 2) https://static-content.springer.com/esm/art%3A10.1038%2Fs41534-018-0071-5/MediaObjects/41534_2018_71_MOESM1_ESM.pdf
+                followed by a SingleQubitCompare to compute the result of comparison of
+                the suffixes of equal length:
+                    - result stored in: `less_than` and `greater_than` with equality in qubits[-2]
+            3. The results from the previous two steps are combined to update the target qubit.
+            4. The adjoint of the previous operations is added to restore the input qubits
+                to their original state and clean the ancilla qubits.
+        """  # pylint: disable=line-too-long
+
+        if context is None:
+            context = cirq.DecompositionContext(cirq.ops.SimpleQubitManager())
+
+        lhs, rhs, target = qubits[: self.x_bitsize], qubits[self.x_bitsize : -1], qubits[-1]
+
+        n = min(len(lhs), len(rhs))
+
+        prefix_equality = None
+        adjoint: List[cirq.Operation] = []
+
+        # if one of the registers is longer than the other store equality with |0--0>
+        # into `prefix_equality` using d = |len(P) - len(Q)| And operations => 4d T.
+        if len(lhs) != len(rhs):
+            (prefix_equality,) = context.qubit_manager.qalloc(1)
+            if len(lhs) > len(rhs):
+                for op in cirq.flatten_to_ops(
+                    _equality_with_zero(context, lhs[:-n], prefix_equality)
+                ):
+                    yield op
+                    adjoint.append(cirq.inverse(op))
+            else:
+                for op in cirq.flatten_to_ops(
+                    _equality_with_zero(context, rhs[:-n], prefix_equality)
+                ):
+                    yield op
+                    adjoint.append(cirq.inverse(op))
+
+                yield cirq.X(target), cirq.CNOT(prefix_equality, target)
+
+        # compare the remaing suffix of P and Q
+        lhs = lhs[-n:]
+        rhs = rhs[-n:]
+        for op in cirq.flatten_to_ops(self._decompose_via_tree(context, lhs, rhs)):
+            yield op
+            adjoint.append(cirq.inverse(op))
+
+        less_than, greater_than = context.qubit_manager.qalloc(2)
+        yield SingleQubitCompare().on_registers(
+            a=lhs[-1], b=rhs[-1], less_than=less_than, greater_than=greater_than
+        )
+        adjoint.append(
+            SingleQubitCompare(adjoint=True).on_registers(
+                a=lhs[-1], b=rhs[-1], less_than=less_than, greater_than=greater_than
+            )
+        )
+
+        if prefix_equality is None:
+            yield cirq.X(target)
+            yield cirq.CNOT(greater_than, target)
+        else:
+            (less_than_or_equal,) = context.qubit_manager.qalloc(1)
+            yield and_gate.And([1, 0]).on(prefix_equality, greater_than, less_than_or_equal)
+            adjoint.append(
+                and_gate.And([1, 0], adjoint=True).on(
+                    prefix_equality, greater_than, less_than_or_equal
+                )
+            )
+
+            yield cirq.CNOT(less_than_or_equal, target)
+
+        yield from reversed(adjoint)
+
     def _t_complexity_(self) -> infra.TComplexity:
-        # TODO(#112): This is rough cost that ignores cliffords.
-        return infra.TComplexity(t=4 * (self.x_bitsize + self.y_bitsize))
+        n = min(self.x_bitsize, self.y_bitsize)
+        d = max(self.x_bitsize, self.y_bitsize) - n
+        is_second_longer = self.y_bitsize > self.x_bitsize
+        if d == 0:
+            # When both registers are of the same size the T complexity is
+            # 8n - 4 same as in https://static-content.springer.com/esm/art%3A10.1038%2Fs41534-018-0071-5/MediaObjects/41534_2018_71_MOESM1_ESM.pdf.  pylint: disable=line-too-long
+            return infra.TComplexity(t=8 * n - 4, clifford=46 * n - 17)
+        else:
+            # When the registers differ in size and `n` is the size of the smaller one and
+            # `d` is the difference in size. The T complexity is the sum of the tree
+            # decomposition as before giving 8n + O(1) and the T complexity of an `And` gate
+            # over `d` registers giving 4d + O(1) totaling 8n + 4d + O(1).
+            # From the decomposition we get that the constant is -4 as well as the clifford counts.
+            if d == 1:
+                return infra.TComplexity(t=8 * n, clifford=46 * n + 3 + 2 * is_second_longer)
+            else:
+                return infra.TComplexity(
+                    t=8 * n + 4 * d - 4, clifford=46 * n + 17 * d - 14 + 2 * is_second_longer
+                )
+
+    def _has_unitary_(self):
+        return True
 
 
 @attr.frozen
 class ContiguousRegisterGate(cirq.ArithmeticGate):
     """Applies U|x>|y>|0> -> |x>|y>|x(x-1)/2 + y>
 
     This is useful in the case when $|x>$ and $|y>$ represent two selection registers such that
```

## cirq_ft/algos/arithmetic_gates_test.py

```diff
@@ -14,15 +14,15 @@
 
 import itertools
 
 import cirq
 import cirq_ft
 import numpy as np
 import pytest
-from cirq_ft.infra import bit_tools
+from cirq_ft.infra import bit_tools, GreedyQubitManager
 
 
 def identity_map(n: int):
     """Returns a dict of size `2**n` mapping each integer in range [0, 2**n) to itself."""
     return {i: i for i in range(2**n)}
 
 
@@ -108,19 +108,28 @@
             basis_map[input_int] = output_int
 
     cirq.testing.assert_equivalent_computational_basis_map(basis_map, circuit)
     circuit += op**-1
     cirq.testing.assert_equivalent_computational_basis_map(identity_map(len(qubits)), circuit)
 
 
-@pytest.mark.parametrize("x_bitsize", [2, 3])
-@pytest.mark.parametrize("y_bitsize", [2, 3])
+@pytest.mark.parametrize("x_bitsize", [*range(1, 5)])
+@pytest.mark.parametrize("y_bitsize", [*range(1, 5)])
 def test_less_than_equal_consistent_protocols(x_bitsize: int, y_bitsize: int):
     g = cirq_ft.LessThanEqualGate(x_bitsize, y_bitsize)
     cirq_ft.testing.assert_decompose_is_consistent_with_t_complexity(g)
+
+    # Decomposition works even when context is None.
+    qubits = cirq.LineQid.range(x_bitsize + y_bitsize + 1, dimension=2)
+    assert cirq.Circuit(g._decompose_with_context_(qubits=qubits)) == cirq.Circuit(
+        cirq.decompose_once(
+            g.on(*qubits), context=cirq.DecompositionContext(cirq.ops.SimpleQubitManager())
+        )
+    )
+
     cirq.testing.assert_equivalent_repr(g, setup_code='import cirq_ft')
     # Test the unitary is self-inverse
     assert g**-1 is g
     u = cirq.unitary(g)
     np.testing.assert_allclose(u @ u, np.eye(2 ** (x_bitsize + y_bitsize + 1)))
     # Test diagrams
     expected_wire_symbols = ("In(x)",) * x_bitsize + ("In(y)",) * y_bitsize + ("+(x <= y)",)
@@ -318,7 +327,92 @@
     out_bin = format(a + b, f'0{num_bits}b')
     true_out_int = a + b
     input_int = int(a_bin + b_bin, 2)
     output_int = int(a_bin + out_bin, 2)
     assert true_out_int == int(out_bin, 2)
     basis_map[input_int] = output_int
     cirq.testing.assert_equivalent_computational_basis_map(basis_map, circuit)
+
+
+@pytest.mark.parametrize("P,n", [(v, n) for n in range(1, 4) for v in range(1 << n)])
+@pytest.mark.parametrize("Q,m", [(v, n) for n in range(1, 4) for v in range(1 << n)])
+def test_decompose_less_than_equal_gate(P: int, n: int, Q: int, m: int):
+    qubit_states = list(bit_tools.iter_bits(P, n)) + list(bit_tools.iter_bits(Q, m))
+    circuit = cirq.Circuit(
+        cirq.decompose_once(
+            cirq_ft.LessThanEqualGate(n, m).on(*cirq.LineQubit.range(n + m + 1)),
+            context=cirq.DecompositionContext(GreedyQubitManager(prefix='_c')),
+        )
+    )
+    qubit_order = tuple(sorted(circuit.all_qubits()))
+    num_ancillas = len(circuit.all_qubits()) - n - m - 1
+    initial_state = qubit_states + [0] + [0] * num_ancillas
+    output_state = qubit_states + [int(P <= Q)] + [0] * num_ancillas
+    cirq_ft.testing.assert_circuit_inp_out_cirqsim(
+        circuit, qubit_order, initial_state, output_state
+    )
+
+
+@pytest.mark.parametrize("adjoint", [False, True])
+def test_single_qubit_compare_protocols(adjoint: bool):
+    g = cirq_ft.algos.SingleQubitCompare(adjoint=adjoint)
+    cirq_ft.testing.assert_decompose_is_consistent_with_t_complexity(g)
+    cirq.testing.assert_equivalent_repr(g, setup_code='import cirq_ft')
+
+    with pytest.raises(ValueError):
+        _ = g**0.5  # type: ignore
+
+    assert g**2 == cirq.IdentityGate(4)
+    assert g**1 is g
+    assert g**-1 == cirq_ft.algos.SingleQubitCompare(adjoint=adjoint ^ True)
+
+
+@pytest.mark.parametrize("v1,v2", [(v1, v2) for v1 in range(2) for v2 in range(2)])
+def test_single_qubit_compare(v1: int, v2: int):
+    g = cirq_ft.algos.SingleQubitCompare()
+    qubits = cirq.LineQid.range(4, dimension=2)
+    c = cirq.Circuit(g.on(*qubits))
+    initial_state = [v1, v2, 0, 0]
+    output_state = [v1, int(v1 == v2), int(v1 < v2), int(v1 > v2)]
+    cirq_ft.testing.assert_circuit_inp_out_cirqsim(
+        c, sorted(c.all_qubits()), initial_state, output_state
+    )
+
+    # Check that g**-1 restores the qubits to their original state
+    c = cirq.Circuit(g.on(*qubits), (g**-1).on(*qubits))
+    cirq_ft.testing.assert_circuit_inp_out_cirqsim(
+        c, sorted(c.all_qubits()), initial_state, initial_state
+    )
+
+
+@pytest.mark.parametrize("adjoint", [False, True])
+def test_bi_qubits_mixer_protocols(adjoint: bool):
+    g = cirq_ft.algos.BiQubitsMixer(adjoint=adjoint)
+    cirq_ft.testing.assert_decompose_is_consistent_with_t_complexity(g)
+    cirq.testing.assert_equivalent_repr(g, setup_code='import cirq_ft')
+
+    assert g**1 is g
+    assert g**-1 == cirq_ft.algos.BiQubitsMixer(adjoint=adjoint ^ True)
+
+
+@pytest.mark.parametrize("x", [*range(4)])
+@pytest.mark.parametrize("y", [*range(4)])
+def test_bi_qubits_mixer(x: int, y: int):
+    g = cirq_ft.algos.BiQubitsMixer()
+    qubits = cirq.LineQid.range(7, dimension=2)
+    c = cirq.Circuit(g.on(*qubits))
+    x_1, x_0 = (x >> 1) & 1, x & 1
+    y_1, y_0 = (y >> 1) & 1, y & 1
+    initial_state = [x_1, x_0, y_1, y_0, 0, 0, 0]
+    result = (
+        cirq.Simulator()
+        .simulate(c, initial_state=initial_state, qubit_order=qubits)
+        .dirac_notation()[1:-1]
+    )
+    x_0, y_0 = int(result[1]), int(result[3])
+    assert np.sign(x - y) == np.sign(x_0 - y_0)
+
+    # Check that g**-1 restores the qubits to their original state
+    c = cirq.Circuit(g.on(*qubits), (g**-1).on(*qubits))
+    cirq_ft.testing.assert_circuit_inp_out_cirqsim(
+        c, sorted(c.all_qubits()), initial_state, initial_state
+    )
```

## cirq_ft/algos/state_preparation_test.py

```diff
@@ -26,30 +26,33 @@
     gate = cirq_ft.StatePreparationAliasSampling.from_lcu_probs(
         lcu_probabilities=data, probability_epsilon=eps
     )
     g = cirq_ft.testing.GateHelper(gate)
     context = cirq.DecompositionContext(cirq.ops.SimpleQubitManager())
 
     def map_func(op: cirq.Operation, _):
-        gateset = cirq.Gateset(cirq_ft.And)
+        gateset = cirq.Gateset(cirq_ft.And, cirq_ft.LessThanEqualGate, cirq_ft.LessThanGate)
         return cirq.Circuit(
             cirq.decompose(op, on_stuck_raise=None, keep=gateset.validate, context=context)
         )
 
-    # TODO: Do not decompose `cq.And` because the `cq.map_clean_and_borrowable_qubits` currently
-    # gets confused and is not able to re-map qubits optimally; which results in a higher number
-    # of ancillas and thus the tests fails due to OOO.
+    # TODO: Do not decompose {cq.And, cq.LessThanEqualGate, cq.LessThanGate} because the
+    # `cq.map_clean_and_borrowable_qubits` currently gets confused and is not able to re-map qubits
+    # optimally; which results in a higher number of ancillas thus the tests fails due to OOO.
     decomposed_circuit = cirq.map_operations_and_unroll(
         g.circuit, map_func, raise_if_add_qubits=False
     )
     greedy_mm = cirq_ft.GreedyQubitManager(prefix="_a", size=25, maximize_reuse=True)
     decomposed_circuit = cirq_ft.map_clean_and_borrowable_qubits(decomposed_circuit, qm=greedy_mm)
     # We are fine decomposing the `cq.And` gates once the qubit re-mapping is complete. Ideally,
     # we shouldn't require this two step process.
-    decomposed_circuit = cirq.Circuit(cirq.decompose(decomposed_circuit))
+    arithmetic_gateset = cirq.Gateset(cirq_ft.LessThanEqualGate, cirq_ft.LessThanGate)
+    decomposed_circuit = cirq.Circuit(
+        cirq.decompose(decomposed_circuit, keep=arithmetic_gateset.validate, on_stuck_raise=None)
+    )
     ordered_input = list(itertools.chain(*g.quregs.values()))
     qubit_order = cirq.QubitOrder.explicit(ordered_input, fallback=cirq.QubitOrder.DEFAULT)
     return g, qubit_order, decomposed_circuit
 
 
 @pytest.mark.parametrize("num_sites, epsilon", [[2, 3e-3], [3, 3.0e-3], [4, 5.0e-3], [7, 8.0e-3]])
 def test_state_preparation_via_coherent_alias_sampling(num_sites, epsilon):
```

## Comparing `cirq_ft-1.2.0.dev20230714133436.dist-info/LICENSE` & `cirq_ft-1.2.0.dev20230717131509.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `cirq_ft-1.2.0.dev20230714133436.dist-info/METADATA` & `cirq_ft-1.2.0.dev20230717131509.dist-info/METADATA`

 * *Files 10% similar despite different names*

```diff
@@ -1,24 +1,24 @@
 Metadata-Version: 2.1
 Name: cirq-ft
-Version: 1.2.0.dev20230714133436
+Version: 1.2.0.dev20230717131509
 Summary: A Cirq package for fault-tolerant algorithms
 Home-page: http://github.com/quantumlib/cirq
 Author: The Cirq Developers
 Author-email: cirq-dev@googlegroups.com
 License: Apache 2
 Platform: UNKNOWN
 Requires-Python: >=3.9.0
 License-File: LICENSE
 Requires-Dist: attrs
 Requires-Dist: cachetools (>=5.3)
 Requires-Dist: ipywidgets
 Requires-Dist: nbconvert
 Requires-Dist: nbformat
-Requires-Dist: cirq-core (==1.2.0.dev20230714133436)
+Requires-Dist: cirq-core (==1.2.0.dev20230717131509)
 
 **This is a development version of Cirq-ft and may be unstable.**
 
 **For the latest stable release of Cirq-ft see**
 `here <https://pypi.org/project/cirq-ft>`__.
 
 .. image:: https://raw.githubusercontent.com/quantumlib/Cirq/master/docs/images/Cirq_logo_color.png
```

## Comparing `cirq_ft-1.2.0.dev20230714133436.dist-info/RECORD` & `cirq_ft-1.2.0.dev20230717131509.dist-info/RECORD`

 * *Files 7% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 cirq_ft/__init__.py,sha256=kjDotbiwECFjkQxV_PWQ25epHm-K3SHzVbHV9zONJbs,1546
-cirq_ft/_version.py,sha256=wITPybNfPtdAJqr-B5WkpFtiskEL4ai7bhRn6_-vGlM,40
-cirq_ft/algos/__init__.py,sha256=cmyEnL8XxqIn7S8YIV9fg128wh4UaOcLsq8UYVpxKC4,1935
+cirq_ft/_version.py,sha256=QQD_zp2Pz0RjGtHznPQGYTcKwoDhcAb9nl0tOqHjiKU,40
+cirq_ft/algos/__init__.py,sha256=zwN5_e9ZvanHMI8IMVMu1Yr44vlgWMZ0O1xMjGSwZic,1978
 cirq_ft/algos/and_gate.py,sha256=8DVGHIXyfbqcr3G2bfb-ZzQ0_2Tdkeim-lpe-JtH9C0,6324
 cirq_ft/algos/and_gate_test.py,sha256=79vPBHBirFA2mmoJBizYTbATzR6PWOEg_yl4bqrxbqE,9377
 cirq_ft/algos/apply_gate_to_lth_target.py,sha256=yYPUw010EOlYuSvrN0w4zMNTj3gohcJcdBj5PCplrDo,3822
 cirq_ft/algos/apply_gate_to_lth_target_test.py,sha256=K-5rliUAfWfl5eoIRdpoxSuH3UeQ-bCZ1VRCxo5d8WY,4001
-cirq_ft/algos/arithmetic_gates.py,sha256=dK9XV3sIYaOgMShfmJAIqH4aTtXa1UsQ_jacoL0NQ54,16191
-cirq_ft/algos/arithmetic_gates_test.py,sha256=N4w3GpxSxFugloXsqZMLHbrrqfDbSc_nFUZthR4OVG0,13900
+cirq_ft/algos/arithmetic_gates.py,sha256=GA0zg2pjc5-0658KV7ub11HlkSzhDt7e90Atlyo3UZw,27134
+cirq_ft/algos/arithmetic_gates_test.py,sha256=7XTDzxzc5Eqid7nv1Q9FOMjehvTddapWmgS1_JS65wM,17717
 cirq_ft/algos/generic_select.py,sha256=-_a7xKiqViC5R4Yw5mIzxGsnoDIY2-boJp5qi3FW8SE,5611
 cirq_ft/algos/generic_select_test.py,sha256=CoUln2E00yorjZJtb7ek1lzZ2-SxNjx0WzXHHc-PrWQ,11576
 cirq_ft/algos/hubbard_model.py,sha256=fzRSBXVoA2bSn2PqIUX1VZN44fYvmxRByc0bGnWKz0I,14436
 cirq_ft/algos/hubbard_model_test.py,sha256=pHFYDnStVLLTeL81nJUu98lcTLG_HLDlloD5aL-9Lmg,2984
 cirq_ft/algos/multi_control_multi_target_pauli.py,sha256=b43paZCXJ1-QSD6zGZI54jB77f_Tzmxsm2LOCrk55tY,4341
 cirq_ft/algos/multi_control_multi_target_pauli_test.py,sha256=Pal6zIp2hmYvaHUDWpi9rSkEqDttrxHbEXMD4OcYXVc,1584
 cirq_ft/algos/prepare_uniform_superposition.py,sha256=qKd6oHIamN81nQzBfUIZ4MDPhIU-RfTwQc5hiY-LreM,4016
@@ -25,15 +25,15 @@
 cirq_ft/algos/reflection_using_prepare_test.py,sha256=vpV9v4FZExbozpmCD5Nb8dJPbaec-gHCI6dNbzKSlI8,14779
 cirq_ft/algos/select_and_prepare.py,sha256=oULWEZewbNzEyKWuQf139CC71GrxMkXBRoct8wkVyUM,2827
 cirq_ft/algos/select_swap_qrom.py,sha256=9tq4M78ZXjPO1f8ynUNcyDFj5Yoo5tHeWe5B92PGr8E,10850
 cirq_ft/algos/select_swap_qrom_test.py,sha256=DiGxbRrk6LajqJaavOZ-CyRQ-JT4hkNpHOX99zsTaHA,3976
 cirq_ft/algos/selected_majorana_fermion.py,sha256=kcrKvWUYdbUznCBB9CwJyh5vZB6ABKsNPUS2tei2DwU,4168
 cirq_ft/algos/selected_majorana_fermion_test.py,sha256=T_RwXMd4cVfBKX2kjxweRyIuzSDEdc3llB75wjJH2us,7405
 cirq_ft/algos/state_preparation.py,sha256=HIN_rdkv5Hakz8pniNshdcWTCdTCCJnWdd3OWPvohk4,6871
-cirq_ft/algos/state_preparation_test.py,sha256=K53EY7r5QmmixtpwisjeSSnlLvlfkiOVExE1jj5KD3U,6433
+cirq_ft/algos/state_preparation_test.py,sha256=pIg1kmS5Qk9lOxaCAX4QSlCvLbtLtWgSsy72glHqh-c,6673
 cirq_ft/algos/swap_network.py,sha256=zTwYcBuXGHc0I4h3VAE056oQPzDfqfijhniGYPAOvQY,8722
 cirq_ft/algos/swap_network_test.py,sha256=REKn81DdlnHwJlGhKYVFXFTIVC4iq-Kfivtsp6kBruY,6530
 cirq_ft/algos/unary_iteration_gate.py,sha256=vidFB22o27pckiZwiwy7gcn6MFSloGRzYNsY4XvhkTo,17396
 cirq_ft/algos/unary_iteration_gate_test.py,sha256=LgkasXx-jAXkrhzotQFPtmijq8x1-XsLVBf_IjkzM9E,8003
 cirq_ft/algos/mean_estimation/__init__.py,sha256=s2u-R5oVBxxktlcIilJ9Tf487EeqlcDYCUB4yENPhBY,849
 cirq_ft/algos/mean_estimation/arctan.py,sha256=Aegt_hvHoaIGnGEAzGU93_6HXKj7yUlGdKx6-sowSGg,2263
 cirq_ft/algos/mean_estimation/arctan_test.py,sha256=aa1wvtjeEu4GM-5Na_IDn21JfPTwCWltwVLrvuFe-Dk,1875
@@ -59,12 +59,12 @@
 cirq_ft/infra/testing.py,sha256=0aJOkAmuLcyQE9fC2d8f1T-8awaOUh9M53O6ujLov34,5244
 cirq_ft/infra/testing_test.py,sha256=1x_NFb9tc_Ej3H6zNUsnkUu1dHinazY7hSUDb_mmtc4,2683
 cirq_ft/infra/type_convertors.py,sha256=XtGCyGVkWi-iZQhIxz-CqxnHugwo2Sl_0b_a3Qglz0s,809
 cirq_ft/infra/type_convertors_test.py,sha256=FHny6Ubxbla8LRBJg2RsuEMgofRjqF82C6yMHhvLGbk,772
 cirq_ft/linalg/__init__.py,sha256=T67aZHhaDq9hZ8SwhPMDLVq-VzzOxKeqOb0m3Ofkle4,673
 cirq_ft/linalg/lcu_util.py,sha256=2RJ6SBifVXN6aJMfXqb98Ec5_8fRWWNmjn93P_bvdNc,8140
 cirq_ft/linalg/lcu_util_test.py,sha256=FejxO4ajd0t1t3TO7o677NDGjjuac3yD4uLFgVuCt14,6420
-cirq_ft-1.2.0.dev20230714133436.dist-info/LICENSE,sha256=tAkwu8-AdEyGxGoSvJ2gVmQdcicWw3j1ZZueVV74M-E,11357
-cirq_ft-1.2.0.dev20230714133436.dist-info/METADATA,sha256=zldl0w50waZUjdjp3KNyD8QbPNFUAyH4aW8_kUprbzg,1509
-cirq_ft-1.2.0.dev20230714133436.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-cirq_ft-1.2.0.dev20230714133436.dist-info/top_level.txt,sha256=H8KJHkgeicc6P99pLIx51PGnLymjmgmVoKeeGGZxP_M,8
-cirq_ft-1.2.0.dev20230714133436.dist-info/RECORD,,
+cirq_ft-1.2.0.dev20230717131509.dist-info/LICENSE,sha256=tAkwu8-AdEyGxGoSvJ2gVmQdcicWw3j1ZZueVV74M-E,11357
+cirq_ft-1.2.0.dev20230717131509.dist-info/METADATA,sha256=Ei9gnGC6FXFYfeli1EISZzVC21kOugDzXHXH6LFJUHU,1509
+cirq_ft-1.2.0.dev20230717131509.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+cirq_ft-1.2.0.dev20230717131509.dist-info/top_level.txt,sha256=H8KJHkgeicc6P99pLIx51PGnLymjmgmVoKeeGGZxP_M,8
+cirq_ft-1.2.0.dev20230717131509.dist-info/RECORD,,
```

