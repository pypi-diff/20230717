# Comparing `tmp/cirq_ft-1.2.0.dev20230717193821-py3-none-any.whl.zip` & `tmp/cirq_ft-1.2.0.dev20230717204825-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,72 +1,72 @@
-Zip file size: 141722 bytes, number of entries: 70
--rw-r--r--  2.0 unx     1546 b- defN 23-Jul-17 19:38 cirq_ft/__init__.py
--rw-r--r--  2.0 unx       40 b- defN 23-Jul-17 19:38 cirq_ft/_version.py
--rw-r--r--  2.0 unx     1978 b- defN 23-Jul-17 19:38 cirq_ft/algos/__init__.py
--rw-r--r--  2.0 unx     6324 b- defN 23-Jul-17 19:38 cirq_ft/algos/and_gate.py
--rw-r--r--  2.0 unx     9377 b- defN 23-Jul-17 19:38 cirq_ft/algos/and_gate_test.py
--rw-r--r--  2.0 unx     3822 b- defN 23-Jul-17 19:38 cirq_ft/algos/apply_gate_to_lth_target.py
--rw-r--r--  2.0 unx     4001 b- defN 23-Jul-17 19:38 cirq_ft/algos/apply_gate_to_lth_target_test.py
--rw-r--r--  2.0 unx    27134 b- defN 23-Jul-17 19:38 cirq_ft/algos/arithmetic_gates.py
--rw-r--r--  2.0 unx    17717 b- defN 23-Jul-17 19:38 cirq_ft/algos/arithmetic_gates_test.py
--rw-r--r--  2.0 unx     5630 b- defN 23-Jul-17 19:38 cirq_ft/algos/generic_select.py
--rw-r--r--  2.0 unx    11576 b- defN 23-Jul-17 19:38 cirq_ft/algos/generic_select_test.py
--rw-r--r--  2.0 unx    14455 b- defN 23-Jul-17 19:38 cirq_ft/algos/hubbard_model.py
--rw-r--r--  2.0 unx     2984 b- defN 23-Jul-17 19:38 cirq_ft/algos/hubbard_model_test.py
--rw-r--r--  2.0 unx     4341 b- defN 23-Jul-17 19:38 cirq_ft/algos/multi_control_multi_target_pauli.py
--rw-r--r--  2.0 unx     1584 b- defN 23-Jul-17 19:38 cirq_ft/algos/multi_control_multi_target_pauli_test.py
--rw-r--r--  2.0 unx     4016 b- defN 23-Jul-17 19:38 cirq_ft/algos/prepare_uniform_superposition.py
--rw-r--r--  2.0 unx     3398 b- defN 23-Jul-17 19:38 cirq_ft/algos/prepare_uniform_superposition_test.py
--rw-r--r--  2.0 unx     9267 b- defN 23-Jul-17 19:38 cirq_ft/algos/programmable_rotation_gate_array.py
--rw-r--r--  2.0 unx     5966 b- defN 23-Jul-17 19:38 cirq_ft/algos/programmable_rotation_gate_array_test.py
--rw-r--r--  2.0 unx     7451 b- defN 23-Jul-17 19:38 cirq_ft/algos/qrom.py
--rw-r--r--  2.0 unx     7101 b- defN 23-Jul-17 19:38 cirq_ft/algos/qrom_test.py
--rw-r--r--  2.0 unx     6350 b- defN 23-Jul-17 19:38 cirq_ft/algos/qubitization_walk_operator.py
--rw-r--r--  2.0 unx    13615 b- defN 23-Jul-17 19:38 cirq_ft/algos/qubitization_walk_operator_test.py
--rw-r--r--  2.0 unx     5399 b- defN 23-Jul-17 19:38 cirq_ft/algos/reflection_using_prepare.py
--rw-r--r--  2.0 unx    14779 b- defN 23-Jul-17 19:38 cirq_ft/algos/reflection_using_prepare_test.py
--rw-r--r--  2.0 unx     2827 b- defN 23-Jul-17 19:38 cirq_ft/algos/select_and_prepare.py
--rw-r--r--  2.0 unx    10850 b- defN 23-Jul-17 19:38 cirq_ft/algos/select_swap_qrom.py
--rw-r--r--  2.0 unx     3976 b- defN 23-Jul-17 19:38 cirq_ft/algos/select_swap_qrom_test.py
--rw-r--r--  2.0 unx     4223 b- defN 23-Jul-17 19:38 cirq_ft/algos/selected_majorana_fermion.py
--rw-r--r--  2.0 unx     7405 b- defN 23-Jul-17 19:38 cirq_ft/algos/selected_majorana_fermion_test.py
--rw-r--r--  2.0 unx     6871 b- defN 23-Jul-17 19:38 cirq_ft/algos/state_preparation.py
--rw-r--r--  2.0 unx     6673 b- defN 23-Jul-17 19:38 cirq_ft/algos/state_preparation_test.py
--rw-r--r--  2.0 unx     8722 b- defN 23-Jul-17 19:38 cirq_ft/algos/swap_network.py
--rw-r--r--  2.0 unx     6530 b- defN 23-Jul-17 19:38 cirq_ft/algos/swap_network_test.py
--rw-r--r--  2.0 unx    17396 b- defN 23-Jul-17 19:38 cirq_ft/algos/unary_iteration_gate.py
--rw-r--r--  2.0 unx     8003 b- defN 23-Jul-17 19:38 cirq_ft/algos/unary_iteration_gate_test.py
--rw-r--r--  2.0 unx      849 b- defN 23-Jul-17 19:38 cirq_ft/algos/mean_estimation/__init__.py
--rw-r--r--  2.0 unx     2263 b- defN 23-Jul-17 19:38 cirq_ft/algos/mean_estimation/arctan.py
--rw-r--r--  2.0 unx     1875 b- defN 23-Jul-17 19:38 cirq_ft/algos/mean_estimation/arctan_test.py
--rw-r--r--  2.0 unx     3195 b- defN 23-Jul-17 19:38 cirq_ft/algos/mean_estimation/complex_phase_oracle.py
--rw-r--r--  2.0 unx     3407 b- defN 23-Jul-17 19:38 cirq_ft/algos/mean_estimation/complex_phase_oracle_test.py
--rw-r--r--  2.0 unx     7049 b- defN 23-Jul-17 19:38 cirq_ft/algos/mean_estimation/mean_estimation_operator.py
--rw-r--r--  2.0 unx    10399 b- defN 23-Jul-17 19:38 cirq_ft/algos/mean_estimation/mean_estimation_operator_test.py
--rw-r--r--  2.0 unx     1006 b- defN 23-Jul-17 19:38 cirq_ft/infra/__init__.py
--rw-r--r--  2.0 unx     3520 b- defN 23-Jul-17 19:38 cirq_ft/infra/bit_tools.py
--rw-r--r--  2.0 unx     2838 b- defN 23-Jul-17 19:38 cirq_ft/infra/bit_tools_test.py
--rw-r--r--  2.0 unx     3647 b- defN 23-Jul-17 19:38 cirq_ft/infra/decompose_protocol.py
--rw-r--r--  2.0 unx     1784 b- defN 23-Jul-17 19:38 cirq_ft/infra/decompose_protocol_test.py
--rw-r--r--  2.0 unx    12231 b- defN 23-Jul-17 19:38 cirq_ft/infra/gate_with_registers.py
--rw-r--r--  2.0 unx     4949 b- defN 23-Jul-17 19:38 cirq_ft/infra/gate_with_registers_test.py
--rw-r--r--  2.0 unx     3938 b- defN 23-Jul-17 19:38 cirq_ft/infra/jupyter_tools.py
--rw-r--r--  2.0 unx     1992 b- defN 23-Jul-17 19:38 cirq_ft/infra/jupyter_tools_test.py
--rw-r--r--  2.0 unx     9405 b- defN 23-Jul-17 19:38 cirq_ft/infra/qubit_management_transformers.py
--rw-r--r--  2.0 unx    13631 b- defN 23-Jul-17 19:38 cirq_ft/infra/qubit_management_transformers_test.py
--rw-r--r--  2.0 unx     3853 b- defN 23-Jul-17 19:38 cirq_ft/infra/qubit_manager.py
--rw-r--r--  2.0 unx     3126 b- defN 23-Jul-17 19:38 cirq_ft/infra/qubit_manager_test.py
--rw-r--r--  2.0 unx     6693 b- defN 23-Jul-17 19:38 cirq_ft/infra/t_complexity_protocol.py
--rw-r--r--  2.0 unx     7836 b- defN 23-Jul-17 19:38 cirq_ft/infra/t_complexity_protocol_test.py
--rw-r--r--  2.0 unx     5244 b- defN 23-Jul-17 19:38 cirq_ft/infra/testing.py
--rw-r--r--  2.0 unx     2683 b- defN 23-Jul-17 19:38 cirq_ft/infra/testing_test.py
--rw-r--r--  2.0 unx      809 b- defN 23-Jul-17 19:38 cirq_ft/infra/type_convertors.py
--rw-r--r--  2.0 unx      772 b- defN 23-Jul-17 19:38 cirq_ft/infra/type_convertors_test.py
--rw-r--r--  2.0 unx      673 b- defN 23-Jul-17 19:38 cirq_ft/linalg/__init__.py
--rw-r--r--  2.0 unx     8140 b- defN 23-Jul-17 19:38 cirq_ft/linalg/lcu_util.py
--rw-r--r--  2.0 unx     6420 b- defN 23-Jul-17 19:38 cirq_ft/linalg/lcu_util_test.py
--rw-r--r--  2.0 unx    11357 b- defN 23-Jul-17 19:38 cirq_ft-1.2.0.dev20230717193821.dist-info/LICENSE
--rw-r--r--  2.0 unx     1509 b- defN 23-Jul-17 19:38 cirq_ft-1.2.0.dev20230717193821.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jul-17 19:38 cirq_ft-1.2.0.dev20230717193821.dist-info/WHEEL
--rw-r--r--  2.0 unx        8 b- defN 23-Jul-17 19:38 cirq_ft-1.2.0.dev20230717193821.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     6633 b- defN 23-Jul-17 19:38 cirq_ft-1.2.0.dev20230717193821.dist-info/RECORD
-70 files, 427153 bytes uncompressed, 130988 bytes compressed:  69.3%
+Zip file size: 143199 bytes, number of entries: 70
+-rw-r--r--  2.0 unx     1546 b- defN 23-Jul-17 20:48 cirq_ft/__init__.py
+-rw-r--r--  2.0 unx       40 b- defN 23-Jul-17 20:48 cirq_ft/_version.py
+-rw-r--r--  2.0 unx     1978 b- defN 23-Jul-17 20:48 cirq_ft/algos/__init__.py
+-rw-r--r--  2.0 unx     6416 b- defN 23-Jul-17 20:48 cirq_ft/algos/and_gate.py
+-rw-r--r--  2.0 unx     9436 b- defN 23-Jul-17 20:48 cirq_ft/algos/and_gate_test.py
+-rw-r--r--  2.0 unx     3938 b- defN 23-Jul-17 20:48 cirq_ft/algos/apply_gate_to_lth_target.py
+-rw-r--r--  2.0 unx     4100 b- defN 23-Jul-17 20:48 cirq_ft/algos/apply_gate_to_lth_target_test.py
+-rw-r--r--  2.0 unx    27215 b- defN 23-Jul-17 20:48 cirq_ft/algos/arithmetic_gates.py
+-rw-r--r--  2.0 unx    17717 b- defN 23-Jul-17 20:48 cirq_ft/algos/arithmetic_gates_test.py
+-rw-r--r--  2.0 unx     5775 b- defN 23-Jul-17 20:48 cirq_ft/algos/generic_select.py
+-rw-r--r--  2.0 unx    11576 b- defN 23-Jul-17 20:48 cirq_ft/algos/generic_select_test.py
+-rw-r--r--  2.0 unx    15417 b- defN 23-Jul-17 20:48 cirq_ft/algos/hubbard_model.py
+-rw-r--r--  2.0 unx     2984 b- defN 23-Jul-17 20:48 cirq_ft/algos/hubbard_model_test.py
+-rw-r--r--  2.0 unx     4411 b- defN 23-Jul-17 20:48 cirq_ft/algos/multi_control_multi_target_pauli.py
+-rw-r--r--  2.0 unx     1584 b- defN 23-Jul-17 20:48 cirq_ft/algos/multi_control_multi_target_pauli_test.py
+-rw-r--r--  2.0 unx     4103 b- defN 23-Jul-17 20:48 cirq_ft/algos/prepare_uniform_superposition.py
+-rw-r--r--  2.0 unx     3403 b- defN 23-Jul-17 20:48 cirq_ft/algos/prepare_uniform_superposition_test.py
+-rw-r--r--  2.0 unx     9368 b- defN 23-Jul-17 20:48 cirq_ft/algos/programmable_rotation_gate_array.py
+-rw-r--r--  2.0 unx     6014 b- defN 23-Jul-17 20:48 cirq_ft/algos/programmable_rotation_gate_array_test.py
+-rw-r--r--  2.0 unx     7606 b- defN 23-Jul-17 20:48 cirq_ft/algos/qrom.py
+-rw-r--r--  2.0 unx     7214 b- defN 23-Jul-17 20:48 cirq_ft/algos/qrom_test.py
+-rw-r--r--  2.0 unx     6427 b- defN 23-Jul-17 20:48 cirq_ft/algos/qubitization_walk_operator.py
+-rw-r--r--  2.0 unx    13620 b- defN 23-Jul-17 20:48 cirq_ft/algos/qubitization_walk_operator_test.py
+-rw-r--r--  2.0 unx     5476 b- defN 23-Jul-17 20:48 cirq_ft/algos/reflection_using_prepare.py
+-rw-r--r--  2.0 unx    14779 b- defN 23-Jul-17 20:48 cirq_ft/algos/reflection_using_prepare_test.py
+-rw-r--r--  2.0 unx     2827 b- defN 23-Jul-17 20:48 cirq_ft/algos/select_and_prepare.py
+-rw-r--r--  2.0 unx    10999 b- defN 23-Jul-17 20:48 cirq_ft/algos/select_swap_qrom.py
+-rw-r--r--  2.0 unx     3976 b- defN 23-Jul-17 20:48 cirq_ft/algos/select_swap_qrom_test.py
+-rw-r--r--  2.0 unx     4485 b- defN 23-Jul-17 20:48 cirq_ft/algos/selected_majorana_fermion.py
+-rw-r--r--  2.0 unx     7642 b- defN 23-Jul-17 20:48 cirq_ft/algos/selected_majorana_fermion_test.py
+-rw-r--r--  2.0 unx     6972 b- defN 23-Jul-17 20:48 cirq_ft/algos/state_preparation.py
+-rw-r--r--  2.0 unx     6673 b- defN 23-Jul-17 20:48 cirq_ft/algos/state_preparation_test.py
+-rw-r--r--  2.0 unx     8789 b- defN 23-Jul-17 20:48 cirq_ft/algos/swap_network.py
+-rw-r--r--  2.0 unx     6463 b- defN 23-Jul-17 20:48 cirq_ft/algos/swap_network_test.py
+-rw-r--r--  2.0 unx    17538 b- defN 23-Jul-17 20:48 cirq_ft/algos/unary_iteration_gate.py
+-rw-r--r--  2.0 unx     8091 b- defN 23-Jul-17 20:48 cirq_ft/algos/unary_iteration_gate_test.py
+-rw-r--r--  2.0 unx      849 b- defN 23-Jul-17 20:48 cirq_ft/algos/mean_estimation/__init__.py
+-rw-r--r--  2.0 unx     2263 b- defN 23-Jul-17 20:48 cirq_ft/algos/mean_estimation/arctan.py
+-rw-r--r--  2.0 unx     1875 b- defN 23-Jul-17 20:48 cirq_ft/algos/mean_estimation/arctan_test.py
+-rw-r--r--  2.0 unx     3286 b- defN 23-Jul-17 20:48 cirq_ft/algos/mean_estimation/complex_phase_oracle.py
+-rw-r--r--  2.0 unx     3388 b- defN 23-Jul-17 20:48 cirq_ft/algos/mean_estimation/complex_phase_oracle_test.py
+-rw-r--r--  2.0 unx     7163 b- defN 23-Jul-17 20:48 cirq_ft/algos/mean_estimation/mean_estimation_operator.py
+-rw-r--r--  2.0 unx    10473 b- defN 23-Jul-17 20:48 cirq_ft/algos/mean_estimation/mean_estimation_operator_test.py
+-rw-r--r--  2.0 unx     1006 b- defN 23-Jul-17 20:48 cirq_ft/infra/__init__.py
+-rw-r--r--  2.0 unx     3520 b- defN 23-Jul-17 20:48 cirq_ft/infra/bit_tools.py
+-rw-r--r--  2.0 unx     2838 b- defN 23-Jul-17 20:48 cirq_ft/infra/bit_tools_test.py
+-rw-r--r--  2.0 unx     3647 b- defN 23-Jul-17 20:48 cirq_ft/infra/decompose_protocol.py
+-rw-r--r--  2.0 unx     1784 b- defN 23-Jul-17 20:48 cirq_ft/infra/decompose_protocol_test.py
+-rw-r--r--  2.0 unx    13514 b- defN 23-Jul-17 20:48 cirq_ft/infra/gate_with_registers.py
+-rw-r--r--  2.0 unx     5498 b- defN 23-Jul-17 20:48 cirq_ft/infra/gate_with_registers_test.py
+-rw-r--r--  2.0 unx     3938 b- defN 23-Jul-17 20:48 cirq_ft/infra/jupyter_tools.py
+-rw-r--r--  2.0 unx     1992 b- defN 23-Jul-17 20:48 cirq_ft/infra/jupyter_tools_test.py
+-rw-r--r--  2.0 unx     9405 b- defN 23-Jul-17 20:48 cirq_ft/infra/qubit_management_transformers.py
+-rw-r--r--  2.0 unx    13631 b- defN 23-Jul-17 20:48 cirq_ft/infra/qubit_management_transformers_test.py
+-rw-r--r--  2.0 unx     3853 b- defN 23-Jul-17 20:48 cirq_ft/infra/qubit_manager.py
+-rw-r--r--  2.0 unx     3126 b- defN 23-Jul-17 20:48 cirq_ft/infra/qubit_manager_test.py
+-rw-r--r--  2.0 unx     6693 b- defN 23-Jul-17 20:48 cirq_ft/infra/t_complexity_protocol.py
+-rw-r--r--  2.0 unx     7836 b- defN 23-Jul-17 20:48 cirq_ft/infra/t_complexity_protocol_test.py
+-rw-r--r--  2.0 unx     5305 b- defN 23-Jul-17 20:48 cirq_ft/infra/testing.py
+-rw-r--r--  2.0 unx     2800 b- defN 23-Jul-17 20:48 cirq_ft/infra/testing_test.py
+-rw-r--r--  2.0 unx      809 b- defN 23-Jul-17 20:48 cirq_ft/infra/type_convertors.py
+-rw-r--r--  2.0 unx      772 b- defN 23-Jul-17 20:48 cirq_ft/infra/type_convertors_test.py
+-rw-r--r--  2.0 unx      673 b- defN 23-Jul-17 20:48 cirq_ft/linalg/__init__.py
+-rw-r--r--  2.0 unx     8140 b- defN 23-Jul-17 20:48 cirq_ft/linalg/lcu_util.py
+-rw-r--r--  2.0 unx     6420 b- defN 23-Jul-17 20:48 cirq_ft/linalg/lcu_util_test.py
+-rw-r--r--  2.0 unx    11357 b- defN 23-Jul-17 20:48 cirq_ft-1.2.0.dev20230717204825.dist-info/LICENSE
+-rw-r--r--  2.0 unx     1509 b- defN 23-Jul-17 20:48 cirq_ft-1.2.0.dev20230717204825.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jul-17 20:48 cirq_ft-1.2.0.dev20230717204825.dist-info/WHEEL
+-rw-r--r--  2.0 unx        8 b- defN 23-Jul-17 20:48 cirq_ft-1.2.0.dev20230717204825.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     6633 b- defN 23-Jul-17 20:48 cirq_ft-1.2.0.dev20230717204825.dist-info/RECORD
+70 files, 432694 bytes uncompressed, 132465 bytes compressed:  69.4%
```

## zipnote {}

```diff
@@ -189,23 +189,23 @@
 
 Filename: cirq_ft/linalg/lcu_util.py
 Comment: 
 
 Filename: cirq_ft/linalg/lcu_util_test.py
 Comment: 
 
-Filename: cirq_ft-1.2.0.dev20230717193821.dist-info/LICENSE
+Filename: cirq_ft-1.2.0.dev20230717204825.dist-info/LICENSE
 Comment: 
 
-Filename: cirq_ft-1.2.0.dev20230717193821.dist-info/METADATA
+Filename: cirq_ft-1.2.0.dev20230717204825.dist-info/METADATA
 Comment: 
 
-Filename: cirq_ft-1.2.0.dev20230717193821.dist-info/WHEEL
+Filename: cirq_ft-1.2.0.dev20230717204825.dist-info/WHEEL
 Comment: 
 
-Filename: cirq_ft-1.2.0.dev20230717193821.dist-info/top_level.txt
+Filename: cirq_ft-1.2.0.dev20230717204825.dist-info/top_level.txt
 Comment: 
 
-Filename: cirq_ft-1.2.0.dev20230717193821.dist-info/RECORD
+Filename: cirq_ft-1.2.0.dev20230717204825.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## cirq_ft/_version.py

```diff
@@ -1 +1 @@
-__version__ = "1.2.0.dev20230717193821"
+__version__ = "1.2.0.dev20230717204825"
```

## cirq_ft/algos/and_gate.py

```diff
@@ -10,14 +10,17 @@
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 from typing import Sequence, Tuple
 
+import numpy as np
+from numpy.typing import NDArray
+
 import attr
 import cirq
 from cirq._compat import cached_property
 from cirq_ft import infra
 
 
 @attr.frozen
@@ -106,39 +109,39 @@
             yield [cirq.T(c1) ** -1, cirq.T(c2) ** -1, cirq.T(target)]
             yield [cirq.CNOT(target, c1), cirq.CNOT(target, c2)]
             yield [cirq.H(target), cirq.S(target)]
         yield pre_post_ops
 
     def _decompose_via_tree(
         self,
-        controls: Sequence[cirq.Qid],
+        controls: NDArray[cirq.Qid],  # type:ignore[type-var]
         control_values: Sequence[int],
-        ancillas: Sequence[cirq.Qid],
+        ancillas: NDArray[cirq.Qid],
         target: cirq.Qid,
     ) -> cirq.ops.op_tree.OpTree:
         """Decomposes multi-controlled `And` in-terms of an `And` ladder of size #controls- 2."""
         if len(controls) == 2:
             yield And(control_values, adjoint=self.adjoint).on(*controls, target)
             return
-        new_controls = (ancillas[0], *controls[2:])
+        new_controls = np.concatenate([ancillas[0:1], controls[2:]])
         new_control_values = (1, *control_values[2:])
         and_op = And(control_values[:2], adjoint=self.adjoint).on(*controls[:2], ancillas[0])
         if self.adjoint:
             yield from self._decompose_via_tree(
                 new_controls, new_control_values, ancillas[1:], target
             )
             yield and_op
         else:
             yield and_op
             yield from self._decompose_via_tree(
                 new_controls, new_control_values, ancillas[1:], target
             )
 
     def decompose_from_registers(
-        self, *, context: cirq.DecompositionContext, **quregs: Sequence[cirq.Qid]
+        self, *, context: cirq.DecompositionContext, **quregs: NDArray[cirq.Qid]
     ) -> cirq.OP_TREE:
         control, ancilla, target = quregs['control'], quregs['ancilla'], quregs['target']
         if len(self.cv) == 2:
             yield self._decompose_single_and(
                 self.cv[0], self.cv[1], control[0], control[1], *target
             )
         else:
```

## cirq_ft/algos/and_gate_test.py

```diff
@@ -41,24 +41,24 @@
     return [random.randint(0, 1) for _ in range(n)]
 
 
 @pytest.mark.parametrize("cv", [[1] * 3, random_cv(5), random_cv(6), random_cv(7)])
 def test_multi_controlled_and_gate(cv: List[int]):
     gate = cirq_ft.And(cv)
     r = gate.registers
-    assert r['ancilla'].bitsize == r['control'].bitsize - 2
+    assert r['ancilla'].total_bits() == r['control'].total_bits() - 2
     quregs = r.get_named_qubits()
     and_op = gate.on_registers(**quregs)
     circuit = cirq.Circuit(and_op)
 
     input_controls = [cv] + [random_cv(len(cv)) for _ in range(10)]
     qubit_order = gate.registers.merge_qubits(**quregs)
 
     for input_control in input_controls:
-        initial_state = input_control + [0] * (r['ancilla'].bitsize + 1)
+        initial_state = input_control + [0] * (r['ancilla'].total_bits() + 1)
         result = cirq.Simulator(dtype=np.complex128).simulate(
             circuit, initial_state=initial_state, qubit_order=qubit_order
         )
         expected_output = np.asarray([0, 1] if input_control == cv else [1, 0])
         assert cirq.equal_up_to_global_phase(
             cirq.sub_state_vector(
                 result.final_state_vector, keep_indices=[cirq.num_qubits(gate) - 1]
@@ -76,16 +76,18 @@
 
 
 def test_and_gate_diagram():
     gate = cirq_ft.And((1, 0, 1, 0, 1, 0))
     qubit_regs = gate.registers.get_named_qubits()
     op = gate.on_registers(**qubit_regs)
     # Qubit order should be alternating (control, ancilla) pairs.
-    c_and_a = sum(zip(qubit_regs["control"][1:], qubit_regs["ancilla"] + [0]), ())[:-1]
-    qubit_order = qubit_regs["control"][0:1] + list(c_and_a) + qubit_regs["target"]
+    c_and_a = sum(zip(qubit_regs["control"][1:], qubit_regs["ancilla"]), ()) + (
+        qubit_regs["control"][-1],
+    )
+    qubit_order = np.concatenate([qubit_regs["control"][0:1], c_and_a, qubit_regs["target"]])
     # Test diagrams.
     cirq.testing.assert_has_diagram(
         cirq.Circuit(op),
         """
 control0: ───@─────
              │
 control1: ───(0)───
```

## cirq_ft/algos/apply_gate_to_lth_target.py

```diff
@@ -52,16 +52,20 @@
 
     @classmethod
     def make_on(
         cls, *, nth_gate: Callable[..., cirq.Gate], **quregs: Sequence[cirq.Qid]
     ) -> cirq.Operation:
         """Helper constructor to automatically deduce bitsize attributes."""
         return cls(
-            infra.SelectionRegisters.build(
-                selection=(len(quregs['selection']), len(quregs['target']))
+            infra.SelectionRegisters(
+                [
+                    infra.SelectionRegister(
+                        'selection', len(quregs['selection']), len(quregs['target'])
+                    )
+                ]
             ),
             nth_gate=nth_gate,
             control_regs=infra.Registers.build(control=len(quregs['control'])),
         ).on_registers(**quregs)
 
     @cached_property
     def control_registers(self) -> infra.Registers:
@@ -72,16 +76,16 @@
         return self.selection_regs
 
     @cached_property
     def target_registers(self) -> infra.Registers:
         return infra.Registers.build(target=self.selection_registers.total_iteration_size)
 
     def _circuit_diagram_info_(self, args: cirq.CircuitDiagramInfoArgs) -> cirq.CircuitDiagramInfo:
-        wire_symbols = ["@"] * self.control_registers.bitsize
-        wire_symbols += ["In"] * self.selection_registers.bitsize
+        wire_symbols = ["@"] * self.control_registers.total_bits()
+        wire_symbols += ["In"] * self.selection_registers.total_bits()
         for it in itertools.product(*[range(x) for x in self.selection_regs.iteration_lengths]):
             wire_symbols += [str(self.nth_gate(*it))]
         return cirq.CircuitDiagramInfo(wire_symbols=wire_symbols)
 
     def nth_operation(  # type: ignore[override]
         self,
         context: cirq.DecompositionContext,
```

## cirq_ft/algos/apply_gate_to_lth_target_test.py

```diff
@@ -19,22 +19,24 @@
 from cirq_ft.infra.jupyter_tools import execute_notebook
 
 
 @pytest.mark.parametrize("selection_bitsize,target_bitsize", [[3, 5], [3, 7], [4, 5]])
 def test_apply_gate_to_lth_qubit(selection_bitsize, target_bitsize):
     greedy_mm = cirq_ft.GreedyQubitManager(prefix="_a", maximize_reuse=True)
     gate = cirq_ft.ApplyGateToLthQubit(
-        cirq_ft.SelectionRegisters.build(selection=(selection_bitsize, target_bitsize)),
+        cirq_ft.SelectionRegisters(
+            [cirq_ft.SelectionRegister('selection', selection_bitsize, target_bitsize)]
+        ),
         lambda _: cirq.X,
     )
     g = cirq_ft.testing.GateHelper(gate, context=cirq.DecompositionContext(greedy_mm))
     # Upper bounded because not all ancillas may be used as part of unary iteration.
     assert (
         len(g.all_qubits)
-        <= target_bitsize + 2 * (selection_bitsize + gate.control_registers.bitsize) - 1
+        <= target_bitsize + 2 * (selection_bitsize + gate.control_registers.total_bits()) - 1
     )
 
     for n in range(target_bitsize):
         # Initial qubit values
         qubit_vals = {q: 0 for q in g.all_qubits}
         # All controls 'on' to activate circuit
         qubit_vals.update({c: 1 for c in g.quregs['control']})
@@ -48,15 +50,15 @@
             g.decomposed_circuit, g.all_qubits, initial_state, final_state
         )
 
 
 def test_apply_gate_to_lth_qubit_diagram():
     # Apply Z gate to all odd targets and Identity to even targets.
     gate = cirq_ft.ApplyGateToLthQubit(
-        cirq_ft.SelectionRegisters.build(selection=(3, 5)),
+        cirq_ft.SelectionRegisters([cirq_ft.SelectionRegister('selection', 3, 5)]),
         lambda n: cirq.Z if n & 1 else cirq.I,
         control_regs=cirq_ft.Registers.build(control=2),
     )
     circuit = cirq.Circuit(gate.on_registers(**gate.registers.get_named_qubits()))
     qubits = list(q for v in gate.registers.get_named_qubits().values() for q in v)
     cirq.testing.assert_has_diagram(
         circuit,
@@ -83,15 +85,15 @@
 """,
         qubit_order=qubits,
     )
 
 
 def test_apply_gate_to_lth_qubit_make_on():
     gate = cirq_ft.ApplyGateToLthQubit(
-        cirq_ft.SelectionRegisters.build(selection=(3, 5)),
+        cirq_ft.SelectionRegisters([cirq_ft.SelectionRegister('selection', 3, 5)]),
         lambda n: cirq.Z if n & 1 else cirq.I,
         control_regs=cirq_ft.Registers.build(control=2),
     )
     op = gate.on_registers(**gate.registers.get_named_qubits())
     op2 = cirq_ft.ApplyGateToLthQubit.make_on(
         nth_gate=lambda n: cirq.Z if n & 1 else cirq.I, **gate.registers.get_named_qubits()
     )
```

## cirq_ft/algos/arithmetic_gates.py

```diff
@@ -9,14 +9,15 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 from typing import Iterable, Optional, Sequence, Tuple, Union, List, Iterator
+from numpy.typing import NDArray
 
 from cirq._compat import cached_property
 import attr
 import cirq
 from cirq_ft import infra
 from cirq_ft.algos import and_gate
 
@@ -149,15 +150,18 @@
     def registers(self) -> infra.Registers:
         return infra.Registers.build(x=2, y=2, ancilla=3)
 
     def __repr__(self) -> str:
         return f'cirq_ft.algos.BiQubitsMixer({self.adjoint})'
 
     def decompose_from_registers(
-        self, *, context: cirq.DecompositionContext, **quregs: Sequence[cirq.Qid]
+        self,
+        *,
+        context: cirq.DecompositionContext,
+        **quregs: NDArray[cirq.Qid],  # type:ignore[type-var]
     ) -> cirq.OP_TREE:
         x, y, ancilla = quregs['x'], quregs['y'], quregs['ancilla']
         x_msb, x_lsb = x
         y_msb, y_lsb = y
 
         def _cswap(control: cirq.Qid, a: cirq.Qid, b: cirq.Qid, aux: cirq.Qid) -> cirq.OP_TREE:
             """A CSWAP with 4T complexity and whose adjoint has 0T complexity.
@@ -220,15 +224,15 @@
     def registers(self) -> infra.Registers:
         return infra.Registers.build(a=1, b=1, less_than=1, greater_than=1)
 
     def __repr__(self) -> str:
         return f'cirq_ft.algos.SingleQubitCompare({self.adjoint})'
 
     def decompose_from_registers(
-        self, *, context: cirq.DecompositionContext, **quregs: Sequence[cirq.Qid]
+        self, *, context: cirq.DecompositionContext, **quregs: NDArray[cirq.Qid]
     ) -> cirq.OP_TREE:
         a = quregs['a']
         b = quregs['b']
         less_than = quregs['less_than']
         greater_than = quregs['greater_than']
 
         def _decomposition() -> Iterator[cirq.Operation]:
```

## cirq_ft/algos/generic_select.py

```diff
@@ -11,14 +11,15 @@
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 """Gates for applying generic selected unitaries."""
 
 from typing import Collection, Optional, Sequence, Tuple, Union
+from numpy.typing import NDArray
 
 import attr
 import cirq
 import numpy as np
 from cirq._compat import cached_property
 from cirq_ft import infra
 from cirq_ft.algos import select_and_prepare, unary_iteration_gate
@@ -69,28 +70,34 @@
     @cached_property
     def control_registers(self) -> infra.Registers:
         registers = [] if self.control_val is None else [infra.Register('control', 1)]
         return infra.Registers(registers)
 
     @cached_property
     def selection_registers(self) -> infra.SelectionRegisters:
-        return infra.SelectionRegisters.build(
-            selection=(self.selection_bitsize, len(self.select_unitaries))
+        return infra.SelectionRegisters(
+            [
+                infra.SelectionRegister(
+                    'selection', self.selection_bitsize, len(self.select_unitaries)
+                )
+            ]
         )
 
     @cached_property
     def target_registers(self) -> infra.Registers:
         return infra.Registers.build(target=self.target_bitsize)
 
-    def decompose_from_registers(self, context, **qubit_regs: Sequence[cirq.Qid]) -> cirq.OP_TREE:
+    def decompose_from_registers(
+        self, context, **quregs: NDArray[cirq.Qid]  # type:ignore[type-var]
+    ) -> cirq.OP_TREE:
         if self.control_val == 0:
-            yield cirq.X(*qubit_regs['control'])
-        yield super(GenericSelect, self).decompose_from_registers(context=context, **qubit_regs)
+            yield cirq.X(*quregs['control'])
+        yield super(GenericSelect, self).decompose_from_registers(context=context, **quregs)
         if self.control_val == 0:
-            yield cirq.X(*qubit_regs['control'])
+            yield cirq.X(*quregs['control'])
 
     def nth_operation(  # type: ignore[override]
         self,
         context: cirq.DecompositionContext,
         selection: int,
         control: cirq.Qid,
         target: Sequence[cirq.Qid],
```

## cirq_ft/algos/hubbard_model.py

```diff
@@ -43,14 +43,15 @@
  - $V=1$, spin-spin ZZ term
  - $p<q$, XZX term
  - $p>q$, YZY term.
 
 See the documentation for `PrepareHubbard` and `SelectHubbard` for details.
 """
 from typing import Collection, Optional, Sequence, Tuple, Union
+from numpy.typing import NDArray
 
 import attr
 import cirq
 import numpy as np
 from cirq._compat import cached_property
 from cirq_ft import infra
 from cirq_ft.algos import and_gate, apply_gate_to_lth_target, arithmetic_gates
@@ -119,60 +120,69 @@
     @cached_property
     def control_registers(self) -> infra.Registers:
         registers = [] if self.control_val is None else [infra.Register('control', 1)]
         return infra.Registers(registers)
 
     @cached_property
     def selection_registers(self) -> infra.SelectionRegisters:
-        return infra.SelectionRegisters.build(
-            U=(1, 2),
-            V=(1, 2),
-            p_x=((self.x_dim - 1).bit_length(), self.x_dim),
-            p_y=((self.y_dim - 1).bit_length(), self.y_dim),
-            alpha=(1, 2),
-            q_x=((self.x_dim - 1).bit_length(), self.x_dim),
-            q_y=((self.y_dim - 1).bit_length(), self.y_dim),
-            beta=(1, 2),
+        return infra.SelectionRegisters(
+            [
+                infra.SelectionRegister('U', 1, 2),
+                infra.SelectionRegister('V', 1, 2),
+                infra.SelectionRegister('p_x', (self.x_dim - 1).bit_length(), self.x_dim),
+                infra.SelectionRegister('p_y', (self.y_dim - 1).bit_length(), self.y_dim),
+                infra.SelectionRegister('alpha', 1, 2),
+                infra.SelectionRegister('q_x', (self.x_dim - 1).bit_length(), self.x_dim),
+                infra.SelectionRegister('q_y', (self.y_dim - 1).bit_length(), self.y_dim),
+                infra.SelectionRegister('beta', 1, 2),
+            ]
         )
 
     @cached_property
     def target_registers(self) -> infra.Registers:
         return infra.Registers.build(target=self.x_dim * self.y_dim * 2)
 
     @cached_property
     def registers(self) -> infra.Registers:
         return infra.Registers(
             [*self.control_registers, *self.selection_registers, *self.target_registers]
         )
 
     def decompose_from_registers(
-        self, *, context: cirq.DecompositionContext, **quregs: Sequence[cirq.Qid]
+        self,
+        *,
+        context: cirq.DecompositionContext,
+        **quregs: NDArray[cirq.Qid],  # type:ignore[type-var]
     ) -> cirq.OP_TREE:
         p_x, p_y, q_x, q_y = quregs['p_x'], quregs['p_y'], quregs['q_x'], quregs['q_y']
         U, V, alpha, beta = quregs['U'], quregs['V'], quregs['alpha'], quregs['beta']
         control, target = quregs.get('control', ()), quregs['target']
 
         yield selected_majorana_fermion.SelectedMajoranaFermionGate(
-            selection_regs=infra.SelectionRegisters.build(
-                alpha=(1, 2),
-                p_y=(self.registers['p_y'].bitsize, self.y_dim),
-                p_x=(self.registers['p_x'].bitsize, self.x_dim),
+            selection_regs=infra.SelectionRegisters(
+                [
+                    infra.SelectionRegister('alpha', 1, 2),
+                    infra.SelectionRegister('p_y', self.registers['p_y'].total_bits(), self.y_dim),
+                    infra.SelectionRegister('p_x', self.registers['p_x'].total_bits(), self.x_dim),
+                ]
             ),
             control_regs=self.control_registers,
             target_gate=cirq.Y,
         ).on_registers(control=control, p_x=p_x, p_y=p_y, alpha=alpha, target=target)
 
         yield swap_network.MultiTargetCSwap.make_on(control=V, target_x=p_x, target_y=q_x)
         yield swap_network.MultiTargetCSwap.make_on(control=V, target_x=p_y, target_y=q_y)
         yield swap_network.MultiTargetCSwap.make_on(control=V, target_x=alpha, target_y=beta)
 
-        q_selection_regs = infra.SelectionRegisters.build(
-            beta=(1, 2),
-            q_y=(self.registers['q_y'].bitsize, self.y_dim),
-            q_x=(self.registers['q_x'].bitsize, self.x_dim),
+        q_selection_regs = infra.SelectionRegisters(
+            [
+                infra.SelectionRegister('beta', 1, 2),
+                infra.SelectionRegister('q_y', self.registers['q_y'].total_bits(), self.y_dim),
+                infra.SelectionRegister('q_x', self.registers['q_x'].total_bits(), self.x_dim),
+            ]
         )
         yield selected_majorana_fermion.SelectedMajoranaFermionGate(
             selection_regs=q_selection_regs, control_regs=self.control_registers, target_gate=cirq.X
         ).on_registers(control=control, q_x=q_x, q_y=q_y, beta=beta, target=target)
 
         yield swap_network.MultiTargetCSwap.make_on(control=V, target_x=alpha, target_y=beta)
         yield swap_network.MultiTargetCSwap.make_on(control=V, target_x=p_y, target_y=q_y)
@@ -186,20 +196,22 @@
         target_qubits_for_apply_to_lth_gate = [
             target[q_selection_regs.to_flat_idx(1, qy, qx)]
             for qx in range(self.x_dim)
             for qy in range(self.y_dim)
         ]
 
         yield apply_gate_to_lth_target.ApplyGateToLthQubit(
-            selection_regs=infra.SelectionRegisters.build(
-                q_y=(self.registers['q_y'].bitsize, self.y_dim),
-                q_x=(self.registers['q_x'].bitsize, self.x_dim),
+            selection_regs=infra.SelectionRegisters(
+                [
+                    infra.SelectionRegister('q_y', self.registers['q_y'].total_bits(), self.y_dim),
+                    infra.SelectionRegister('q_x', self.registers['q_x'].total_bits(), self.x_dim),
+                ]
             ),
             nth_gate=lambda *_: cirq.Z,
-            control_regs=infra.Registers.build(control=1 + self.control_registers.bitsize),
+            control_regs=infra.Registers.build(control=1 + self.control_registers.total_bits()),
         ).on_registers(
             q_x=q_x, q_y=q_y, control=[*V, *control], target=target_qubits_for_apply_to_lth_gate
         )
 
     def controlled(
         self,
         num_controls: Optional[int] = None,
@@ -276,35 +288,37 @@
 
     def __attrs_post_init__(self):
         if self.x_dim != self.y_dim:
             raise NotImplementedError("Currently only supports the case where x_dim=y_dim.")
 
     @cached_property
     def selection_registers(self) -> infra.SelectionRegisters:
-        return infra.SelectionRegisters.build(
-            U=(1, 2),
-            V=(1, 2),
-            p_x=((self.x_dim - 1).bit_length(), self.x_dim),
-            p_y=((self.y_dim - 1).bit_length(), self.y_dim),
-            alpha=(1, 2),
-            q_x=((self.x_dim - 1).bit_length(), self.x_dim),
-            q_y=((self.y_dim - 1).bit_length(), self.y_dim),
-            beta=(1, 2),
+        return infra.SelectionRegisters(
+            [
+                infra.SelectionRegister('U', 1, 2),
+                infra.SelectionRegister('V', 1, 2),
+                infra.SelectionRegister('p_x', (self.x_dim - 1).bit_length(), self.x_dim),
+                infra.SelectionRegister('p_y', (self.y_dim - 1).bit_length(), self.y_dim),
+                infra.SelectionRegister('alpha', 1, 2),
+                infra.SelectionRegister('q_x', (self.x_dim - 1).bit_length(), self.x_dim),
+                infra.SelectionRegister('q_y', (self.y_dim - 1).bit_length(), self.y_dim),
+                infra.SelectionRegister('beta', 1, 2),
+            ]
         )
 
     @cached_property
     def junk_registers(self) -> infra.Registers:
         return infra.Registers.build(temp=2)
 
     @cached_property
     def registers(self) -> infra.Registers:
         return infra.Registers([*self.selection_registers, *self.junk_registers])
 
     def decompose_from_registers(
-        self, *, context: cirq.DecompositionContext, **quregs: Sequence[cirq.Qid]
+        self, *, context: cirq.DecompositionContext, **quregs: NDArray[cirq.Qid]
     ) -> cirq.OP_TREE:
         p_x, p_y, q_x, q_y = quregs['p_x'], quregs['p_y'], quregs['q_x'], quregs['q_y']
         U, V, alpha, beta = quregs['U'], quregs['V'], quregs['alpha'], quregs['beta']
         temp = quregs['temp']
 
         N = self.x_dim * self.y_dim * 2
         qlambda = 2 * N * self.t + (N * self.mu) // 2
```

## cirq_ft/algos/multi_control_multi_target_pauli.py

```diff
@@ -8,15 +8,16 @@
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-from typing import Sequence, Tuple
+from typing import Tuple
+from numpy.typing import NDArray
 
 import attr
 import cirq
 import numpy as np
 from cirq._compat import cached_property
 from cirq_ft import infra
 from cirq_ft.algos import and_gate
@@ -34,19 +35,22 @@
         self._num_targets = num_targets
 
     @cached_property
     def registers(self) -> infra.Registers:
         return infra.Registers.build(control=1, targets=self._num_targets)
 
     def decompose_from_registers(
-        self, *, context: cirq.DecompositionContext, **quregs: Sequence[cirq.Qid]
+        self,
+        *,
+        context: cirq.DecompositionContext,
+        **quregs: NDArray[cirq.Qid],  # type:ignore[type-var]
     ):
         control, targets = quregs['control'], quregs['targets']
 
-        def cnots_for_depth_i(i: int, q: Sequence[cirq.Qid]) -> cirq.OP_TREE:
+        def cnots_for_depth_i(i: int, q: NDArray[cirq.Qid]) -> cirq.OP_TREE:
             for c, t in zip(q[: 2**i], q[2**i : min(len(q), 2 ** (i + 1))]):
                 yield cirq.CNOT(c, t)
 
         depth = len(targets).bit_length()
         for i in range(depth):
             yield cirq.Moment(cnots_for_depth_i(depth - i - 1, targets))
         yield cirq.CNOT(*control, targets[0])
@@ -73,15 +77,15 @@
     target_gate: cirq.Pauli = cirq.X
 
     @cached_property
     def registers(self) -> infra.Registers:
         return infra.Registers.build(controls=len(self.cvs), target=1)
 
     def decompose_from_registers(
-        self, *, context: cirq.DecompositionContext, **quregs: Sequence['cirq.Qid']
+        self, *, context: cirq.DecompositionContext, **quregs: NDArray['cirq.Qid']
     ) -> cirq.OP_TREE:
         controls, target = quregs['controls'], quregs['target']
         qm = context.qubit_manager
         and_ancilla, and_target = qm.qalloc(len(self.cvs) - 2), qm.qalloc(1)
         yield and_gate.And(self.cvs).on_registers(
             control=controls, ancilla=and_ancilla, target=and_target
         )
```

## cirq_ft/algos/prepare_uniform_superposition.py

```diff
@@ -8,15 +8,16 @@
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-from typing import Sequence, Tuple
+from typing import Tuple
+from numpy.typing import NDArray
 
 import attr
 import cirq
 import numpy as np
 from cirq._compat import cached_property
 from cirq_ft import infra
 from cirq_ft.algos import and_gate, arithmetic_gates
@@ -52,34 +53,37 @@
         return infra.Registers.build(controls=len(self.cv), target=(self.n - 1).bit_length())
 
     def __repr__(self) -> str:
         return f"cirq_ft.PrepareUniformSuperposition({self.n}, cv={self.cv})"
 
     def _circuit_diagram_info_(self, args: cirq.CircuitDiagramInfoArgs) -> cirq.CircuitDiagramInfo:
         control_symbols = ["@" if cv else "@(0)" for cv in self.cv]
-        target_symbols = ['target'] * self.registers['target'].bitsize
+        target_symbols = ['target'] * self.registers['target'].total_bits()
         target_symbols[0] = f"UNIFORM({self.n})"
         return cirq.CircuitDiagramInfo(wire_symbols=control_symbols + target_symbols)
 
     def decompose_from_registers(
-        self, *, context: cirq.DecompositionContext, **quregs: Sequence[cirq.Qid]
+        self,
+        *,
+        context: cirq.DecompositionContext,
+        **quregs: NDArray[cirq.Qid],  # type:ignore[type-var]
     ) -> cirq.OP_TREE:
         controls, target = quregs['controls'], quregs['target']
         # Find K and L as per https://arxiv.org/abs/1805.03662 Fig 12.
         n, k = self.n, 0
         while n > 1 and n % 2 == 0:
             k += 1
             n = n // 2
-        l, logL = int(n), self.registers['target'].bitsize - k
+        l, logL = int(n), self.registers['target'].total_bits() - k
         logL_qubits = target[:logL]
 
         yield [
             op.controlled_by(*controls, control_values=self.cv) for op in cirq.H.on_each(*target)
         ]
-        if not logL_qubits:
+        if not len(logL_qubits):
             return
 
         ancilla = context.qubit_manager.qalloc(1)
         theta = np.arccos(1 - (2 ** np.floor(np.log2(l))) / l)
         yield arithmetic_gates.LessThanGate(logL, l).on(*logL_qubits, *ancilla)
         yield cirq.Rz(rads=theta)(*ancilla)
         yield arithmetic_gates.LessThanGate(logL, l).on(*logL_qubits, *ancilla)
```

## cirq_ft/algos/prepare_uniform_superposition_test.py

```diff
@@ -47,15 +47,15 @@
     # and therefore the total complexity should come down to `8 * logN`
     assert result.t <= 12 * (n - 1).bit_length()
 
     gate = cirq_ft.PrepareUniformSuperposition(n, cv=(1,))
     result = cirq_ft.t_complexity(gate)
     # TODO(#233): Controlled-H is currently counted as a separate rotation, but it can be
     # implemented using 2 T-gates.
-    assert result.rotations <= 2 + 2 * gate.registers.bitsize
+    assert result.rotations <= 2 + 2 * gate.registers.total_bits()
     assert result.t <= 12 * (n - 1).bit_length()
 
 
 def test_prepare_uniform_superposition_consistent_protocols():
     gate = cirq_ft.PrepareUniformSuperposition(5, cv=(1, 0))
     # Repr
     cirq.testing.assert_equivalent_repr(gate, setup_code='import cirq_ft')
```

## cirq_ft/algos/programmable_rotation_gate_array.py

```diff
@@ -10,14 +10,15 @@
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 import abc
 from typing import Sequence, Tuple
+from numpy.typing import NDArray
 
 import cirq
 import numpy as np
 from cirq._compat import cached_method, cached_property
 from cirq_ft import infra
 from cirq_ft.algos import qrom
 from cirq_ft.infra.bit_tools import iter_bits
@@ -91,21 +92,23 @@
     @cached_method
     def rotation_gate(self, exponent: int = -1) -> cirq.Gate:
         """Returns `self._rotation_gate` ** 1 / (2 ** (1 + power))`"""
         power = 1 / 2 ** (1 + exponent)
         return cirq.pow(self._rotation_gate, power)
 
     @abc.abstractmethod
-    def interleaved_unitary(self, index: int, **qubit_regs: Sequence[cirq.Qid]) -> cirq.Operation:
+    def interleaved_unitary(
+        self, index: int, **qubit_regs: NDArray[cirq.Qid]  # type:ignore[type-var]
+    ) -> cirq.Operation:
         pass
 
     @cached_property
     def selection_registers(self) -> infra.SelectionRegisters:
-        return infra.SelectionRegisters.build(
-            selection=(self._selection_bitsize, len(self.angles[0]))
+        return infra.SelectionRegisters(
+            [infra.SelectionRegister('selection', self._selection_bitsize, len(self.angles[0]))]
         )
 
     @cached_property
     def kappa_load_target(self) -> infra.Registers:
         return infra.Registers.build(kappa_load_target=self.kappa)
 
     @cached_property
@@ -125,24 +128,24 @@
                 *self.kappa_load_target,
                 *self.rotations_target,
                 *self.interleaved_unitary_target,
             ]
         )
 
     def decompose_from_registers(
-        self, *, context: cirq.DecompositionContext, **quregs: Sequence[cirq.Qid]
+        self, *, context: cirq.DecompositionContext, **quregs: NDArray[cirq.Qid]
     ) -> cirq.OP_TREE:
         selection, kappa_load_target = quregs.pop('selection'), quregs.pop('kappa_load_target')
         rotations_target = quregs.pop('rotations_target')
         interleaved_unitary_target = quregs
 
         # 1. Find a convenient way to process batches of size kappa.
         num_bits = sum(max(thetas).bit_length() for thetas in self.angles)
         iteration_length = self.selection_registers[0].iteration_length
-        selection_bitsizes = [s.bitsize for s in self.selection_registers]
+        selection_bitsizes = [s.total_bits() for s in self.selection_registers]
         angles_bits = np.zeros(shape=(iteration_length, num_bits), dtype=int)
         angles_bit_pow = np.zeros(shape=(num_bits,), dtype=int)
         angles_idx = np.zeros(shape=(num_bits,), dtype=int)
         st, en = 0, 0
         for i, thetas in enumerate(self.angles):
             bit_width = max(thetas).bit_length()
             st, en = en, en + bit_width
@@ -188,19 +191,19 @@
         *angles: Sequence[int],
         kappa: int,
         rotation_gate: cirq.Gate,
         interleaved_unitaries: Sequence[cirq.Gate] = (),
     ):
         super().__init__(*angles, kappa=kappa, rotation_gate=rotation_gate)
         if not interleaved_unitaries:
-            identity_gate = cirq.IdentityGate(self.rotations_target.bitsize)
+            identity_gate = cirq.IdentityGate(self.rotations_target.total_bits())
             interleaved_unitaries = (identity_gate,) * (len(angles) - 1)
         assert len(interleaved_unitaries) == len(angles) - 1
         assert all(cirq.num_qubits(u) == self._target_bitsize for u in interleaved_unitaries)
         self._interleaved_unitaries = tuple(interleaved_unitaries)
 
-    def interleaved_unitary(self, index: int, **qubit_regs: Sequence[cirq.Qid]) -> cirq.Operation:
+    def interleaved_unitary(self, index: int, **qubit_regs: NDArray[cirq.Qid]) -> cirq.Operation:
         return self._interleaved_unitaries[index].on(*qubit_regs['rotations_target'])
 
     @cached_property
     def interleaved_unitary_target(self) -> infra.Registers:
         return infra.Registers.build()
```

## cirq_ft/algos/programmable_rotation_gate_array_test.py

```diff
@@ -8,26 +8,28 @@
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-from typing import Sequence
+from numpy.typing import NDArray
 
 import cirq
 import cirq_ft
 import numpy as np
 import pytest
 from cirq._compat import cached_property
 from cirq_ft.infra.bit_tools import iter_bits
 
 
 class CustomProgrammableRotationGateArray(cirq_ft.ProgrammableRotationGateArrayBase):
-    def interleaved_unitary(self, index: int, **qubit_regs: Sequence[cirq.Qid]) -> cirq.Operation:
+    def interleaved_unitary(
+        self, index: int, **qubit_regs: NDArray[cirq.Qid]  # type:ignore[type-var]
+    ) -> cirq.Operation:
         two_qubit_ops_factory = [
             cirq.X(*qubit_regs['unrelated_target']).controlled_by(*qubit_regs['rotations_target']),
             cirq.Z(*qubit_regs['unrelated_target']).controlled_by(*qubit_regs['rotations_target']),
         ]
         return two_qubit_ops_factory[index % 2]
 
     @cached_property
@@ -87,15 +89,15 @@
             if b == '1':
                 yield cirq.pow(rotation_gate.on(*g.quregs['rotations_target']), (1 / 2 ** (1 + i)))
 
     for selection_integer in range(len(angles[0])):
         # Set bits in initial_state s.t. selection register stores `selection_integer`.
         qubit_vals = {x: 0 for x in g.all_qubits}
         qubit_vals.update(
-            zip(g.quregs['selection'], iter_bits(selection_integer, g.r['selection'].bitsize))
+            zip(g.quregs['selection'], iter_bits(selection_integer, g.r['selection'].total_bits()))
         )
         initial_state = [qubit_vals[x] for x in g.all_qubits]
         # Actual circuit simulation.
         result = simulator.simulate(
             decomposed_circuit, initial_state=initial_state, qubit_order=g.all_qubits
         )
         ru_state_vector = cirq.sub_state_vector(
```

## cirq_ft/algos/qrom.py

```diff
@@ -85,23 +85,27 @@
             if self.num_controls
             else infra.Registers([])
         )
 
     @cached_property
     def selection_registers(self) -> infra.SelectionRegisters:
         if len(self.data[0].shape) == 1:
-            return infra.SelectionRegisters.build(
-                selection=(self.selection_bitsizes[0], self.data[0].shape[0])
+            return infra.SelectionRegisters(
+                [
+                    infra.SelectionRegister(
+                        'selection', self.selection_bitsizes[0], self.data[0].shape[0]
+                    )
+                ]
             )
         else:
-            return infra.SelectionRegisters.build(
-                **{
-                    f'selection{i}': (sb, len)
+            return infra.SelectionRegisters(
+                [
+                    infra.SelectionRegister(f'selection{i}', sb, len)
                     for i, (len, sb) in enumerate(zip(self.data[0].shape, self.selection_bitsizes))
-                }
+                ]
             )
 
     @cached_property
     def target_registers(self) -> infra.Registers:
         return infra.Registers.build(
             **{f'target{i}': len for i, len in enumerate(self.target_bitsizes)}
         )
@@ -115,24 +119,24 @@
             f"target_bitsizes={target_repr}, num_controls={self.num_controls})"
         )
 
     def _load_nth_data(
         self,
         selection_idx: Tuple[int, ...],
         gate: Callable[[cirq.Qid], cirq.Operation],
-        **target_regs: Sequence[cirq.Qid],
+        **target_regs: NDArray[cirq.Qid],  # type: ignore[type-var]
     ) -> cirq.OP_TREE:
         for i, d in enumerate(self.data):
             target = target_regs[f'target{i}']
             for q, bit in zip(target, f'{int(d[selection_idx]):0{len(target)}b}'):
                 if int(bit):
                     yield gate(q)
 
     def decompose_zero_selection(
-        self, context: cirq.DecompositionContext, **quregs: Sequence[cirq.Qid]
+        self, context: cirq.DecompositionContext, **quregs: NDArray[cirq.Qid]
     ) -> cirq.OP_TREE:
         controls = self.control_registers.merge_qubits(**quregs)
         target_regs = {k: v for k, v in quregs.items() if k in self.target_registers}
         zero_indx = (0,) * len(self.data[0].shape)
         if self.num_controls == 0:
             yield self._load_nth_data(zero_indx, cirq.X, **target_regs)
         elif self.num_controls == 1:
@@ -153,17 +157,17 @@
     ) -> cirq.OP_TREE:
         selection_idx = tuple(kwargs[reg.name] for reg in self.selection_registers)
         target_regs = {k: v for k, v in kwargs.items() if k in self.target_registers}
         yield self._load_nth_data(selection_idx, lambda q: cirq.CNOT(control, q), **target_regs)
 
     def _circuit_diagram_info_(self, _) -> cirq.CircuitDiagramInfo:
         wire_symbols = ["@"] * self.num_controls
-        wire_symbols += ["In"] * self.selection_registers.bitsize
+        wire_symbols += ["In"] * self.selection_registers.total_bits()
         for i, target in enumerate(self.target_registers):
-            wire_symbols += [f"QROM_{i}"] * target.bitsize
+            wire_symbols += [f"QROM_{i}"] * target.total_bits()
         return cirq.CircuitDiagramInfo(wire_symbols=wire_symbols)
 
     def __pow__(self, power: int):
         if power in [1, -1]:
             return self
         return NotImplemented  # coverage: ignore
```

## cirq_ft/algos/qrom_test.py

```diff
@@ -29,22 +29,27 @@
 def test_qrom_1d(data, num_controls):
     qrom = cirq_ft.QROM.build(*data, num_controls=num_controls)
     greedy_mm = cirq_ft.GreedyQubitManager('a', maximize_reuse=True)
     g = cirq_ft.testing.GateHelper(qrom, context=cirq.DecompositionContext(greedy_mm))
     decomposed_circuit = cirq.Circuit(cirq.decompose(g.operation, context=g.context))
     inverse = cirq.Circuit(cirq.decompose(g.operation**-1, context=g.context))
 
-    assert len(inverse.all_qubits()) <= g.r.bitsize + g.r['selection'].bitsize + num_controls
+    assert (
+        len(inverse.all_qubits()) <= g.r.total_bits() + g.r['selection'].total_bits() + num_controls
+    )
     assert inverse.all_qubits() == decomposed_circuit.all_qubits()
 
     for selection_integer in range(len(data[0])):
         for cval in range(2):
             qubit_vals = {x: 0 for x in g.all_qubits}
             qubit_vals.update(
-                zip(g.quregs['selection'], iter_bits(selection_integer, g.r['selection'].bitsize))
+                zip(
+                    g.quregs['selection'],
+                    iter_bits(selection_integer, g.r['selection'].total_bits()),
+                )
             )
             if num_controls:
                 qubit_vals.update(zip(g.quregs['control'], [cval] * num_controls))
 
             initial_state = [qubit_vals[x] for x in g.all_qubits]
             if cval or not num_controls:
                 for ti, d in enumerate(data):
@@ -127,19 +132,20 @@
     )
     greedy_mm = cirq_ft.GreedyQubitManager('a', maximize_reuse=True)
     g = cirq_ft.testing.GateHelper(qrom, context=cirq.DecompositionContext(greedy_mm))
     decomposed_circuit = cirq.Circuit(cirq.decompose(g.operation, context=g.context))
     inverse = cirq.Circuit(cirq.decompose(g.operation**-1, context=g.context))
 
     assert (
-        len(inverse.all_qubits()) <= g.r.bitsize + qrom.selection_registers.bitsize + num_controls
+        len(inverse.all_qubits())
+        <= g.r.total_bits() + qrom.selection_registers.total_bits() + num_controls
     )
     assert inverse.all_qubits() == decomposed_circuit.all_qubits()
 
-    lens = tuple(reg.bitsize for reg in qrom.selection_registers)
+    lens = tuple(reg.total_bits() for reg in qrom.selection_registers)
     for idxs in itertools.product(*[range(dim) for dim in data[0].shape]):
         qubit_vals = {x: 0 for x in g.all_qubits}
         for cval in range(2):
             if num_controls:
                 qubit_vals.update(zip(g.quregs['control'], [cval] * num_controls))
             for isel in range(len(idxs)):
                 qubit_vals.update(
```

## cirq_ft/algos/qubitization_walk_operator.py

```diff
@@ -9,14 +9,15 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 from typing import Collection, Optional, Sequence, Tuple, Union
+from numpy.typing import NDArray
 
 import attr
 import cirq
 from cirq._compat import cached_property
 from cirq_ft import infra
 from cirq_ft.algos import reflection_using_prepare, select_and_prepare
 
@@ -80,28 +81,30 @@
     @cached_property
     def reflect(self) -> reflection_using_prepare.ReflectionUsingPrepare:
         return reflection_using_prepare.ReflectionUsingPrepare(
             self.prepare, control_val=self.control_val
         )
 
     def decompose_from_registers(
-        self, context: cirq.DecompositionContext, **qubit_regs: Sequence[cirq.Qid]
+        self,
+        context: cirq.DecompositionContext,
+        **quregs: NDArray[cirq.Qid],  # type:ignore[type-var]
     ) -> cirq.OP_TREE:
-        select_reg = {reg.name: qubit_regs[reg.name] for reg in self.select.registers}
+        select_reg = {reg.name: quregs[reg.name] for reg in self.select.registers}
         select_op = self.select.on_registers(**select_reg)
 
-        reflect_reg = {reg.name: qubit_regs[reg.name] for reg in self.reflect.registers}
+        reflect_reg = {reg.name: quregs[reg.name] for reg in self.reflect.registers}
         reflect_op = self.reflect.on_registers(**reflect_reg)
         for _ in range(self.power):
             yield select_op
             yield reflect_op
 
     def _circuit_diagram_info_(self, args: cirq.CircuitDiagramInfoArgs) -> cirq.CircuitDiagramInfo:
-        wire_symbols = ['@' if self.control_val else '@(0)'] * self.control_registers.bitsize
-        wire_symbols += ['W'] * (self.registers.bitsize - self.control_registers.bitsize)
+        wire_symbols = ['@' if self.control_val else '@(0)'] * self.control_registers.total_bits()
+        wire_symbols += ['W'] * (self.registers.total_bits() - self.control_registers.total_bits())
         wire_symbols[-1] = f'W^{self.power}' if self.power != 1 else 'W'
         return cirq.CircuitDiagramInfo(wire_symbols=wire_symbols)
 
     def controlled(
         self,
         num_controls: Optional[int] = None,
         control_values: Optional[
```

## cirq_ft/algos/qubitization_walk_operator_test.py

```diff
@@ -27,15 +27,15 @@
     q = sorted(ham.qubits)
     ham_dps = [ps.dense(q) for ps in ham]
     ham_coeff = [abs(ps.coefficient.real) for ps in ham]
     prepare = cirq_ft.StatePreparationAliasSampling.from_lcu_probs(
         ham_coeff, probability_epsilon=eps
     )
     select = cirq_ft.GenericSelect(
-        prepare.selection_registers.bitsize, select_unitaries=ham_dps, target_bitsize=len(q)
+        prepare.selection_registers.total_bits(), select_unitaries=ham_dps, target_bitsize=len(q)
     )
     return cirq_ft.QubitizationWalkOperator(select=select, prepare=prepare)
 
 
 def get_walk_operator_for_1d_Ising_model(
     num_sites: int, eps: float
 ) -> cirq_ft.QubitizationWalkOperator:
```

## cirq_ft/algos/reflection_using_prepare.py

```diff
@@ -9,14 +9,15 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 from typing import Collection, Optional, Sequence, Tuple, Union
+from numpy.typing import NDArray
 
 import attr
 import cirq
 from cirq._compat import cached_property
 from cirq_ft import infra
 from cirq_ft.algos import multi_control_multi_target_pauli as mcmt
 from cirq_ft.algos import select_and_prepare
@@ -65,23 +66,25 @@
         return self.prepare_gate.selection_registers
 
     @cached_property
     def registers(self) -> infra.Registers:
         return infra.Registers([*self.control_registers, *self.selection_registers])
 
     def decompose_from_registers(
-        self, context: cirq.DecompositionContext, **qubit_regs: Sequence[cirq.Qid]
+        self,
+        context: cirq.DecompositionContext,
+        **quregs: NDArray[cirq.Qid],  # type:ignore[type-var]
     ) -> cirq.OP_TREE:
         qm = context.qubit_manager
         # 0. Allocate new ancillas, if needed.
-        phase_target = qm.qalloc(1)[0] if self.control_val is None else qubit_regs.pop('control')[0]
+        phase_target = qm.qalloc(1)[0] if self.control_val is None else quregs.pop('control')[0]
         state_prep_ancilla = {
-            reg.name: qm.qalloc(reg.bitsize) for reg in self.prepare_gate.junk_registers
+            reg.name: qm.qalloc(reg.total_bits()) for reg in self.prepare_gate.junk_registers
         }
-        state_prep_selection_regs = qubit_regs
+        state_prep_selection_regs = quregs
         prepare_op = self.prepare_gate.on_registers(
             **state_prep_selection_regs, **state_prep_ancilla
         )
         # 1. PREPARE†
         yield cirq.inverse(prepare_op)
         # 2. MultiControlled Z, controlled on |000..00> state.
         phase_control = self.selection_registers.merge_qubits(**state_prep_selection_regs)
@@ -95,16 +98,16 @@
 
         # 4. Deallocate ancilla.
         qm.qfree([q for anc in state_prep_ancilla.values() for q in anc])
         if self.control_val is None:
             qm.qfree([phase_target])
 
     def _circuit_diagram_info_(self, args: cirq.CircuitDiagramInfoArgs) -> cirq.CircuitDiagramInfo:
-        wire_symbols = ['@' if self.control_val else '@(0)'] * self.control_registers.bitsize
-        wire_symbols += ['R_L'] * self.selection_registers.bitsize
+        wire_symbols = ['@' if self.control_val else '@(0)'] * self.control_registers.total_bits()
+        wire_symbols += ['R_L'] * self.selection_registers.total_bits()
         return cirq.CircuitDiagramInfo(wire_symbols=wire_symbols)
 
     def __repr__(self):
         return f'cirq_ft.ReflectionUsingPrepare({self.prepare_gate}, {self.control_val})'
 
     def controlled(
         self,
```

## cirq_ft/algos/select_swap_qrom.py

```diff
@@ -9,21 +9,21 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 from typing import List, Optional, Sequence, Tuple
+from numpy.typing import NDArray
 
 import cirq
 import numpy as np
 from cirq._compat import cached_property
 from cirq_ft import infra
 from cirq_ft.algos import qrom, swap_network
-from numpy.typing import NDArray
 
 
 def find_optimal_log_block_size(iteration_length: int, target_bitsize: int) -> int:
     """Find optimal block size, which is a power of 2, for SelectSwapQROM.
 
     This functions returns the optimal `k` s.t.
         * k is in an integer and k >= 0.
@@ -135,16 +135,20 @@
         self.selection_q, self.selection_r = tuple(
             (L - 1).bit_length() for L in [self.num_blocks, self.block_size]
         )
         self._data = tuple(tuple(d) for d in data)
 
     @cached_property
     def selection_registers(self) -> infra.SelectionRegisters:
-        return infra.SelectionRegisters.build(
-            selection=(self.selection_q + self.selection_r, self._iteration_length)
+        return infra.SelectionRegisters(
+            [
+                infra.SelectionRegister(
+                    'selection', self.selection_q + self.selection_r, self._iteration_length
+                )
+            ]
         )
 
     @cached_property
     def target_registers(self) -> infra.Registers:
         clean_output = {}
         for sequence_id in range(self._num_sequences):
             clean_output[f'target{sequence_id}'] = self._target_bitsizes[sequence_id]
@@ -173,15 +177,18 @@
             f"cirq_ft.SelectSwapQROM("
             f"{data_repr}, "
             f"target_bitsizes={target_repr}, "
             f"block_size={self.block_size})"
         )
 
     def decompose_from_registers(
-        self, *, context: cirq.DecompositionContext, **quregs: Sequence[cirq.Qid]
+        self,
+        *,
+        context: cirq.DecompositionContext,
+        **quregs: NDArray[cirq.Qid],  # type:ignore[type-var]
     ) -> cirq.OP_TREE:
         # Divide each data sequence and corresponding target registers into
         # `self.num_blocks` batches of size `self.block_size`.
         selection, targets = quregs.pop('selection'), quregs
         qrom_data: List[NDArray] = []
         qrom_target_bitsizes: List[int] = []
         ordered_target_qubits: List[cirq.Qid] = []
@@ -204,15 +211,15 @@
             selection_bitsizes=(self.selection_q,),
             target_bitsizes=tuple(qrom_target_bitsizes),
         )
         qrom_op = qrom_gate.on_registers(
             selection=q, **qrom_gate.target_registers.split_qubits(ordered_target_qubits)
         )
         swap_with_zero_gate = swap_network.SwapWithZeroGate(
-            k, self.target_registers.bitsize, self.block_size
+            k, self.target_registers.total_bits(), self.block_size
         )
         swap_with_zero_op = swap_with_zero_gate.on_registers(
             selection=r, **swap_with_zero_gate.target_registers.split_qubits(ordered_target_qubits)
         )
         clean_targets = self.target_registers.merge_qubits(**targets)
         cnot_op = cirq.Moment(cirq.CNOT(s, t) for s, t in zip(ordered_target_qubits, clean_targets))
         # Yield the operations in correct order.
@@ -227,12 +234,12 @@
 
         context.qubit_manager.qfree(ordered_target_qubits)
 
     def _circuit_diagram_info_(self, _) -> cirq.CircuitDiagramInfo:
         wire_symbols = ["In_q"] * self.selection_q
         wire_symbols += ["In_r"] * self.selection_r
         for i, target in enumerate(self.target_registers):
-            wire_symbols += [f"QROAM_{i}"] * target.bitsize
+            wire_symbols += [f"QROAM_{i}"] * target.total_bits()
         return cirq.CircuitDiagramInfo(wire_symbols=wire_symbols)
 
     def _value_equality_values_(self):
         return self.block_size, self._target_bitsizes, self.data
```

## cirq_ft/algos/selected_majorana_fermion.py

```diff
@@ -8,18 +8,21 @@
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-from typing import Sequence
+from typing import Sequence, Union
+from numpy.typing import NDArray
 
 import attr
 import cirq
+import numpy as np
+
 from cirq._compat import cached_property
 from cirq_ft import infra
 from cirq_ft.algos import unary_iteration_gate
 
 
 @attr.frozen
 class SelectedMajoranaFermionGate(unary_iteration_gate.UnaryIterationGate):
@@ -41,19 +44,28 @@
     """
 
     selection_regs: infra.SelectionRegisters
     control_regs: infra.Registers = infra.Registers.build(control=1)
     target_gate: cirq.Gate = cirq.Y
 
     @classmethod
-    def make_on(cls, *, target_gate=cirq.Y, **quregs: Sequence[cirq.Qid]) -> cirq.Operation:
+    def make_on(
+        cls,
+        *,
+        target_gate=cirq.Y,
+        **quregs: Union[Sequence[cirq.Qid], NDArray[cirq.Qid]],  # type: ignore[type-var]
+    ) -> cirq.Operation:
         """Helper constructor to automatically deduce selection_regs attribute."""
         return cls(
-            selection_regs=infra.SelectionRegisters.build(
-                selection=(len(quregs['selection']), len(quregs['target']))
+            selection_regs=infra.SelectionRegisters(
+                [
+                    infra.SelectionRegister(
+                        'selection', len(quregs['selection']), len(quregs['target'])
+                    )
+                ]
             ),
             target_gate=target_gate,
         ).on_registers(**quregs)
 
     @cached_property
     def control_registers(self) -> infra.Registers:
         return self.control_regs
@@ -67,28 +79,28 @@
         return infra.Registers.build(target=self.selection_regs.total_iteration_size)
 
     @cached_property
     def extra_registers(self) -> infra.Registers:
         return infra.Registers.build(accumulator=1)
 
     def decompose_from_registers(
-        self, context: cirq.DecompositionContext, **qubit_regs: Sequence[cirq.Qid]
+        self, context: cirq.DecompositionContext, **quregs: NDArray[cirq.Qid]
     ) -> cirq.OP_TREE:
-        qubit_regs['accumulator'] = context.qubit_manager.qalloc(1)
-        control = qubit_regs[self.control_regs[0].name] if self.control_registers.bitsize else []
-        yield cirq.X(*qubit_regs['accumulator']).controlled_by(*control)
+        quregs['accumulator'] = np.array(context.qubit_manager.qalloc(1))
+        control = quregs[self.control_regs[0].name] if self.control_registers.total_bits() else []
+        yield cirq.X(*quregs['accumulator']).controlled_by(*control)
         yield super(SelectedMajoranaFermionGate, self).decompose_from_registers(
-            context=context, **qubit_regs
+            context=context, **quregs
         )
-        context.qubit_manager.qfree(qubit_regs['accumulator'])
+        context.qubit_manager.qfree(quregs['accumulator'])
 
     def _circuit_diagram_info_(self, args: cirq.CircuitDiagramInfoArgs) -> cirq.CircuitDiagramInfo:
-        wire_symbols = ["@"] * self.control_registers.bitsize
-        wire_symbols += ["In"] * self.selection_registers.bitsize
-        wire_symbols += [f"Z{self.target_gate}"] * self.target_registers.bitsize
+        wire_symbols = ["@"] * self.control_registers.total_bits()
+        wire_symbols += ["In"] * self.selection_registers.total_bits()
+        wire_symbols += [f"Z{self.target_gate}"] * self.target_registers.total_bits()
         return cirq.CircuitDiagramInfo(wire_symbols=wire_symbols)
 
     def nth_operation(  # type: ignore[override]
         self,
         context: cirq.DecompositionContext,
         control: cirq.Qid,
         target: Sequence[cirq.Qid],
```

## cirq_ft/algos/selected_majorana_fermion_test.py

```diff
@@ -20,19 +20,21 @@
 
 
 @pytest.mark.parametrize("selection_bitsize, target_bitsize", [(2, 4), (3, 8), (4, 9)])
 @pytest.mark.parametrize("target_gate", [cirq.X, cirq.Y])
 def test_selected_majorana_fermion_gate(selection_bitsize, target_bitsize, target_gate):
     greedy_mm = cirq_ft.GreedyQubitManager(prefix="_a", maximize_reuse=True)
     gate = cirq_ft.SelectedMajoranaFermionGate(
-        cirq_ft.SelectionRegisters.build(selection=(selection_bitsize, target_bitsize)),
+        cirq_ft.SelectionRegisters(
+            [cirq_ft.SelectionRegister('selection', selection_bitsize, target_bitsize)]
+        ),
         target_gate=target_gate,
     )
     g = cirq_ft.testing.GateHelper(gate, context=cirq.DecompositionContext(greedy_mm))
-    assert len(g.all_qubits) <= gate.registers.bitsize + selection_bitsize + 1
+    assert len(g.all_qubits) <= gate.registers.total_bits() + selection_bitsize + 1
 
     sim = cirq.Simulator(dtype=np.complex128)
     for n in range(target_bitsize):
         # Initial qubit values
         qubit_vals = {q: 0 for q in g.all_qubits}
         # All controls 'on' to activate circuit
         qubit_vals.update({c: 1 for c in g.quregs['control']})
@@ -60,15 +62,17 @@
             expected_target_state, final_target_state, atol=1e-6
         )
 
 
 def test_selected_majorana_fermion_gate_diagram():
     selection_bitsize, target_bitsize = 3, 5
     gate = cirq_ft.SelectedMajoranaFermionGate(
-        cirq_ft.SelectionRegisters.build(selection=(selection_bitsize, target_bitsize)),
+        cirq_ft.SelectionRegisters(
+            [cirq_ft.SelectionRegister('selection', selection_bitsize, target_bitsize)]
+        ),
         target_gate=cirq.X,
     )
     circuit = cirq.Circuit(gate.on_registers(**gate.registers.get_named_qubits()))
     qubits = list(q for v in gate.registers.get_named_qubits().values() for q in v)
     cirq.testing.assert_has_diagram(
         circuit,
         """
@@ -93,27 +97,31 @@
         qubit_order=qubits,
     )
 
 
 def test_selected_majorana_fermion_gate_decomposed_diagram():
     selection_bitsize, target_bitsize = 2, 3
     gate = cirq_ft.SelectedMajoranaFermionGate(
-        cirq_ft.SelectionRegisters.build(selection=(selection_bitsize, target_bitsize)),
+        cirq_ft.SelectionRegisters(
+            [cirq_ft.SelectionRegister('selection', selection_bitsize, target_bitsize)]
+        ),
         target_gate=cirq.X,
     )
     greedy_mm = cirq_ft.GreedyQubitManager(prefix="_a", maximize_reuse=True)
     g = cirq_ft.testing.GateHelper(gate)
     context = cirq.DecompositionContext(greedy_mm)
     circuit = cirq.Circuit(cirq.decompose_once(g.operation, context=context))
     ancillas = sorted(set(circuit.all_qubits()) - set(g.operation.qubits))
-    qubits = (
-        g.quregs['control']
-        + [q for qs in zip(g.quregs['selection'], ancillas[1:]) for q in qs]
-        + ancillas[0:1]
-        + g.quregs['target']
+    qubits = np.concatenate(
+        [
+            g.quregs['control'],
+            [q for qs in zip(g.quregs['selection'], ancillas[1:]) for q in qs],
+            ancillas[0:1],
+            g.quregs['target'],
+        ]
     )
     cirq.testing.assert_has_diagram(
         circuit,
         """
 control: ──────@───@──────────────────────────────────────@───────────@──────
                │   │                                      │           │
 selection0: ───┼───(0)────────────────────────────────────┼───────────@──────
@@ -134,15 +142,17 @@
         qubit_order=qubits,
     )
 
 
 def test_selected_majorana_fermion_gate_make_on():
     selection_bitsize, target_bitsize = 3, 5
     gate = cirq_ft.SelectedMajoranaFermionGate(
-        cirq_ft.SelectionRegisters.build(selection=(selection_bitsize, target_bitsize)),
+        cirq_ft.SelectionRegisters(
+            [cirq_ft.SelectionRegister('selection', selection_bitsize, target_bitsize)]
+        ),
         target_gate=cirq.X,
     )
     op = gate.on_registers(**gate.registers.get_named_qubits())
     op2 = cirq_ft.SelectedMajoranaFermionGate.make_on(
         target_gate=cirq.X, **gate.registers.get_named_qubits()
     )
     assert op == op2
```

## cirq_ft/algos/state_preparation.py

```diff
@@ -16,29 +16,29 @@
 
 In section III.D. of the [Linear T paper](https://arxiv.org/abs/1805.03662) the authors introduce
 a technique for initializing a state with $L$ unique coefficients (provided by a classical
 database) with a number of T gates scaling as 4L + O(log(1/eps)) where eps is the
 largest absolute error that one can tolerate in the prepared amplitudes.
 """
 
-from typing import List, Sequence
+from typing import List
+from numpy.typing import NDArray
 
 import attr
 import cirq
 import numpy as np
 from cirq._compat import cached_property
 from cirq_ft import infra, linalg
 from cirq_ft.algos import (
     arithmetic_gates,
     prepare_uniform_superposition,
     qrom,
     select_and_prepare,
     swap_network,
 )
-from numpy.typing import NDArray
 
 
 @cirq.value_equality()
 @attr.frozen
 class StatePreparationAliasSampling(select_and_prepare.PrepareOracle):
     r"""Initialize a state with $L$ unique coefficients using coherent alias sampling.
 
@@ -102,35 +102,37 @@
                 for more information.
         """
         alt, keep, mu = linalg.preprocess_lcu_coefficients_for_reversible_sampling(
             lcu_coefficients=lcu_probabilities, epsilon=probability_epsilon
         )
         N = len(lcu_probabilities)
         return StatePreparationAliasSampling(
-            selection_registers=infra.SelectionRegisters.build(selection=((N - 1).bit_length(), N)),
+            selection_registers=infra.SelectionRegisters(
+                [infra.SelectionRegister('selection', (N - 1).bit_length(), N)]
+            ),
             alt=np.array(alt),
             keep=np.array(keep),
             mu=mu,
         )
 
     @cached_property
     def sigma_mu_bitsize(self) -> int:
         return self.mu
 
     @cached_property
     def alternates_bitsize(self) -> int:
-        return self.selection_registers.bitsize
+        return self.selection_registers.total_bits()
 
     @cached_property
     def keep_bitsize(self) -> int:
         return self.mu
 
     @cached_property
     def selection_bitsize(self) -> int:
-        return self.selection_registers.bitsize
+        return self.selection_registers.total_bits()
 
     @cached_property
     def junk_registers(self) -> infra.Registers:
         return infra.Registers.build(
             sigma_mu=self.sigma_mu_bitsize,
             alt=self.alternates_bitsize,
             keep=self.keep_bitsize,
@@ -153,15 +155,18 @@
             f'{self.selection_registers}, '
             f'{alt_repr}, '
             f'{keep_repr}, '
             f'{self.mu})'
         )
 
     def decompose_from_registers(
-        self, *, context: cirq.DecompositionContext, **quregs: Sequence[cirq.Qid]
+        self,
+        *,
+        context: cirq.DecompositionContext,
+        **quregs: NDArray[cirq.Qid],  # type:ignore[type-var]
     ) -> cirq.OP_TREE:
         selection, less_than_equal = quregs['selection'], quregs['less_than_equal']
         sigma_mu, alt, keep = quregs['sigma_mu'], quregs['alt'], quregs['keep']
         N = self.selection_registers[0].iteration_length
         yield prepare_uniform_superposition.PrepareUniformSuperposition(N).on(*selection)
         yield cirq.H.on_each(*sigma_mu)
         qrom_gate = qrom.QROM(
```

## cirq_ft/algos/swap_network.py

```diff
@@ -8,15 +8,16 @@
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-from typing import Sequence
+from typing import Sequence, Union
+from numpy.typing import NDArray
 
 import attr
 import cirq
 from cirq._compat import cached_property
 from cirq_ft import infra
 from cirq_ft.algos import multi_control_multi_target_pauli as mcmtp
 
@@ -32,24 +33,26 @@
         (https://arxiv.org/abs/1812.00954).
         Low et. al. 2018. See Appendix B.2.c.
     """
 
     bitsize: int
 
     @classmethod
-    def make_on(cls, **quregs: Sequence[cirq.Qid]) -> cirq.Operation:
+    def make_on(
+        cls, **quregs: Union[Sequence[cirq.Qid], NDArray[cirq.Qid]]  # type: ignore[type-var]
+    ) -> cirq.Operation:
         """Helper constructor to automatically deduce bitsize attributes."""
         return cls(bitsize=len(quregs['target_x'])).on_registers(**quregs)
 
     @cached_property
     def registers(self) -> infra.Registers:
         return infra.Registers.build(control=1, target_x=self.bitsize, target_y=self.bitsize)
 
     def decompose_from_registers(
-        self, *, context: cirq.DecompositionContext, **quregs: Sequence[cirq.Qid]
+        self, *, context: cirq.DecompositionContext, **quregs: NDArray[cirq.Qid]
     ) -> cirq.OP_TREE:
         control, target_x, target_y = quregs['control'], quregs['target_x'], quregs['target_y']
         yield [cirq.CSWAP(*control, t_x, t_y) for t_x, t_y in zip(target_x, target_y)]
 
     def _circuit_diagram_info_(self, args: cirq.CircuitDiagramInfoArgs) -> cirq.CircuitDiagramInfo:
         if not args.use_unicode_characters:
             return cirq.CircuitDiagramInfo(
@@ -77,15 +80,15 @@
     References:
         [Trading T-gates for dirty qubits in state preparation and unitary synthesis]
         (https://arxiv.org/abs/1812.00954).
         Low et. al. 2018. See Appendix B.2.c.
     """
 
     def decompose_from_registers(
-        self, *, context: cirq.DecompositionContext, **quregs: Sequence[cirq.Qid]
+        self, *, context: cirq.DecompositionContext, **quregs: NDArray[cirq.Qid]
     ) -> cirq.OP_TREE:
         control, target_x, target_y = quregs['control'], quregs['target_x'], quregs['target_y']
 
         def g(q: cirq.Qid, adjoint=False) -> cirq.ops.op_tree.OpTree:
             yield [cirq.S(q), cirq.H(q)]
             yield cirq.T(q) ** (1 - 2 * adjoint)
             yield [cirq.H(q), cirq.S(q) ** -1]
@@ -139,33 +142,31 @@
     n_target_registers: int
 
     def __attrs_post_init__(self):
         assert self.n_target_registers <= 2**self.selection_bitsize
 
     @cached_property
     def selection_registers(self) -> infra.SelectionRegisters:
-        return infra.SelectionRegisters.build(
-            selection=(self.selection_bitsize, self.n_target_registers)
+        return infra.SelectionRegisters(
+            [infra.SelectionRegister('selection', self.selection_bitsize, self.n_target_registers)]
         )
 
     @cached_property
     def target_registers(self) -> infra.Registers:
-        return infra.Registers.build(
-            **{f'target{i}': self.target_bitsize for i in range(self.n_target_registers)}
-        )
+        return infra.Registers.build(target=(self.n_target_registers, self.target_bitsize))
 
     @cached_property
     def registers(self) -> infra.Registers:
         return infra.Registers([*self.selection_registers, *self.target_registers])
 
     def decompose_from_registers(
-        self, *, context: cirq.DecompositionContext, **quregs: Sequence[cirq.Qid]
+        self, *, context: cirq.DecompositionContext, **quregs: NDArray[cirq.Qid]
     ) -> cirq.OP_TREE:
-        selection, target_regs = quregs.pop('selection'), quregs
-        assert len(target_regs) == self.n_target_registers
+        selection, target = quregs['selection'], quregs['target']
+        assert target.shape == (self.n_target_registers, self.target_bitsize)
         cswap_n = MultiTargetCSwapApprox(self.target_bitsize)
         # Imagine a complete binary tree of depth `logN` with `N` leaves, each denoting a target
         # register. If the selection register stores index `r`, we want to bring the value stored
         # in leaf indexed `r` to the leaf indexed `0`. At each node of the binary tree, the left
         # subtree contains node with current bit 0 and right subtree contains nodes with current
         # bit 1. Thus, leaf indexed `0` is the leftmost node in the tree.
         # Start iterating from the root of the tree. If the j'th bit is set in the selection
@@ -175,16 +176,16 @@
         # takes (N / (2 ** (j + 1)) swaps at level `j`.
         # Therefore, in total, we need $\sum_{j=0}^{logN-1} \frac{N}{2 ^ {j + 1}}$ controlled swaps.
         for j in range(len(selection)):
             for i in range(0, self.n_target_registers - 2**j, 2 ** (j + 1)):
                 # The inner loop is executed at-most `N - 1` times, where `N:= len(target_regs)`.
                 yield cswap_n.on_registers(
                     control=selection[len(selection) - j - 1],
-                    target_x=target_regs[f'target{i}'],
-                    target_y=target_regs[f'target{i + 2**j}'],
+                    target_x=target[i],
+                    target_y=target[i + 2**j],
                 )
 
     def __repr__(self) -> str:
         return (
             "cirq_ft.SwapWithZeroGate("
             f"{self.selection_bitsize},"
             f"{self.target_bitsize},"
```

## cirq_ft/algos/swap_network_test.py

```diff
@@ -29,20 +29,17 @@
 )
 def test_swap_with_zero_gate(selection_bitsize, target_bitsize, n_target_registers):
     # Construct the gate.
     gate = cirq_ft.SwapWithZeroGate(selection_bitsize, target_bitsize, n_target_registers)
     # Allocate selection and target qubits.
     all_qubits = cirq.LineQubit.range(cirq.num_qubits(gate))
     selection = all_qubits[:selection_bitsize]
-    targets = {
-        f'target{i}': all_qubits[st : st + target_bitsize]
-        for i, st in enumerate(range(selection_bitsize, len(all_qubits), target_bitsize))
-    }
+    target = np.array(all_qubits[selection_bitsize:]).reshape((n_target_registers, target_bitsize))
     # Create a circuit.
-    circuit = cirq.Circuit(gate.on_registers(selection=selection, **targets))
+    circuit = cirq.Circuit(gate.on_registers(selection=selection, target=target))
 
     # Load data[i] in i'th target register; where each register is of size target_bitsize
     data = [random.randint(0, 2**target_bitsize - 1) for _ in range(n_target_registers)]
     target_state = [int(x) for d in data for x in format(d, f"0{target_bitsize}b")]
 
     sim = cirq.Simulator(dtype=np.complex128)
     expected_state_vector = np.zeros(2**target_bitsize)
```

## cirq_ft/algos/unary_iteration_gate.py

```diff
@@ -10,16 +10,19 @@
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 import abc
 from typing import Dict, Iterator, List, Sequence, Tuple
+from numpy.typing import NDArray
 
 import cirq
+import numpy as np
+
 from cirq._compat import cached_property
 from cirq_ft import infra
 from cirq_ft.algos import and_gate
 
 
 def _unary_iteration_segtree(
     ops: List[cirq.Operation],
@@ -130,15 +133,15 @@
     r_iter: int,
     qm: cirq.QubitManager,
 ) -> Iterator[Tuple[cirq.OP_TREE, cirq.Qid, int]]:
     num_controls = len(controls)
     and_ancilla = qm.qalloc(num_controls - 2)
     and_target = qm.qalloc(1)[0]
     multi_controlled_and = and_gate.And((1,) * len(controls)).on_registers(
-        control=controls, ancilla=and_ancilla, target=and_target
+        control=np.array(controls), ancilla=np.array(and_ancilla), target=and_target
     )
     ops.append(multi_controlled_and)
     yield from _unary_iteration_single_control(ops, and_target, selection, l_iter, r_iter, qm)
     ops.append(cirq.inverse(multi_controlled_and))
     qm.qfree(and_ancilla + [and_target])
 
 
@@ -278,37 +281,39 @@
             3) Register names in `self.target_registers`: Each argument corresponds to a target
             register and represents the sequence of qubits that represent the target register.
             4) Register names in `self.extra_regs`: Each argument corresponds to an extra
             register and represents the sequence of qubits that represent the extra register.
         """
 
     def decompose_zero_selection(
-        self, context: cirq.DecompositionContext, **quregs: Sequence[cirq.Qid]
+        self,
+        context: cirq.DecompositionContext,
+        **quregs: NDArray[cirq.Qid],  # type: ignore[type-var]
     ) -> cirq.OP_TREE:
         """Specify decomposition of the gate when selection register is empty
 
         By default, if the selection register is empty, the decomposition will raise a
         `NotImplementedError`. The derived classes can override this method and specify
         a custom decomposition that should be used if the selection register is empty,
-        i.e. `self.selection_registers.bitsize == 0`.
+        i.e. `self.selection_registers.total_bits() == 0`.
 
         The derived classes should specify the following arguments as `**kwargs`:
             1) Register names in `self.control_registers`: Each argument corresponds to a
             control register and represents sequence of qubits that represent the control register.
             2) Register names in `self.target_registers`: Each argument corresponds to a target
             register and represents the sequence of qubits that represent the target register.
             3) Register names in `self.extra_regs`: Each argument corresponds to an extra
             register and represents the sequence of qubits that represent the extra register.
         """
         raise NotImplementedError("Selection register must not be empty.")
 
     def decompose_from_registers(
-        self, *, context: cirq.DecompositionContext, **quregs: Sequence[cirq.Qid]
+        self, *, context: cirq.DecompositionContext, **quregs: NDArray[cirq.Qid]
     ) -> cirq.OP_TREE:
-        if self.selection_registers.bitsize == 0:
+        if self.selection_registers.total_bits() == 0:
             return self.decompose_zero_selection(context=context, **quregs)
 
         num_loops = len(self.selection_registers)
         target_regs = {k: v for k, v in quregs.items() if k in self.target_registers}
         extra_regs = {k: v for k, v in quregs.items() if k in self.extra_registers}
 
         def unary_iteration_loops(
@@ -348,15 +353,15 @@
             # Use recursion to write `num_loops` nested loops using unary_iteration().
             ops: List[cirq.Operation] = []
             ith_for_loop = unary_iteration(
                 l_iter=0,
                 r_iter=self.selection_registers[nested_depth].iteration_length,
                 flanking_ops=ops,
                 controls=controls,
-                selection=quregs[self.selection_registers[nested_depth].name],
+                selection=[*quregs[self.selection_registers[nested_depth].name]],
                 qubit_manager=context.qubit_manager,
             )
             for op_tree, control_qid, n in ith_for_loop:
                 yield op_tree
                 selection_reg_name_to_val[self.selection_registers[nested_depth].name] = n
                 yield from unary_iteration_loops(
                     nested_depth + 1, selection_reg_name_to_val, (control_qid,)
@@ -367,11 +372,11 @@
 
     def _circuit_diagram_info_(self, args: cirq.CircuitDiagramInfoArgs) -> cirq.CircuitDiagramInfo:
         """Basic circuit diagram.
 
         Descendants are encouraged to override this with more descriptive
         circuit diagram information.
         """
-        wire_symbols = ["@"] * self.control_registers.bitsize
-        wire_symbols += ["In"] * self.selection_registers.bitsize
-        wire_symbols += [self.__class__.__name__] * self.target_registers.bitsize
+        wire_symbols = ["@"] * self.control_registers.total_bits()
+        wire_symbols += ["In"] * self.selection_registers.total_bits()
+        wire_symbols += [self.__class__.__name__] * self.target_registers.total_bits()
         return cirq.CircuitDiagramInfo(wire_symbols=wire_symbols)
```

## cirq_ft/algos/unary_iteration_gate_test.py

```diff
@@ -31,16 +31,16 @@
 
     @cached_property
     def control_registers(self) -> cirq_ft.Registers:
         return cirq_ft.Registers.build(control=self._control_bitsize)
 
     @cached_property
     def selection_registers(self) -> cirq_ft.SelectionRegisters:
-        return cirq_ft.SelectionRegisters.build(
-            selection=(self._selection_bitsize, self._target_bitsize)
+        return cirq_ft.SelectionRegisters(
+            [cirq_ft.SelectionRegister('selection', self._selection_bitsize, self._target_bitsize)]
         )
 
     @cached_property
     def target_registers(self) -> cirq_ft.Registers:
         return cirq_ft.Registers.build(target=self._target_bitsize)
 
     def nth_operation(  # type: ignore[override]
@@ -59,15 +59,14 @@
 def test_unary_iteration_gate(selection_bitsize, target_bitsize, control_bitsize):
     greedy_mm = cirq_ft.GreedyQubitManager(prefix="_a", maximize_reuse=True)
     gate = ApplyXToLthQubit(selection_bitsize, target_bitsize, control_bitsize)
     g = cirq_ft.testing.GateHelper(gate, context=cirq.DecompositionContext(greedy_mm))
     assert len(g.all_qubits) <= 2 * (selection_bitsize + control_bitsize) + target_bitsize - 1
 
     for n in range(target_bitsize):
-
         # Initial qubit values
         qubit_vals = {q: 0 for q in g.operation.qubits}
         # All controls 'on' to activate circuit
         qubit_vals.update({c: 1 for c in g.quregs['control']})
         # Set selection according to `n`
         qubit_vals.update(zip(g.quregs['selection'], iter_bits(n, selection_bitsize)))
 
@@ -85,18 +84,21 @@
 
     @cached_property
     def control_registers(self) -> cirq_ft.Registers:
         return cirq_ft.Registers([])
 
     @cached_property
     def selection_registers(self) -> cirq_ft.SelectionRegisters:
-        return cirq_ft.SelectionRegisters.build(
-            i=((self._target_shape[0] - 1).bit_length(), self._target_shape[0]),
-            j=((self._target_shape[1] - 1).bit_length(), self._target_shape[1]),
-            k=((self._target_shape[2] - 1).bit_length(), self._target_shape[2]),
+        return cirq_ft.SelectionRegisters(
+            [
+                cirq_ft.SelectionRegister(
+                    'ijk'[i], (self._target_shape[i] - 1).bit_length(), self._target_shape[i]
+                )
+                for i in range(3)
+            ]
         )
 
     @cached_property
     def target_registers(self) -> cirq_ft.Registers:
         return cirq_ft.Registers.build(
             t1=self._target_shape[0], t2=self._target_shape[1], t3=self._target_shape[2]
         )
@@ -116,18 +118,20 @@
 
 
 @pytest.mark.parametrize("target_shape", [(2, 3, 2), (2, 2, 2)])
 def test_multi_dimensional_unary_iteration_gate(target_shape: Tuple[int, int, int]):
     greedy_mm = cirq_ft.GreedyQubitManager(prefix="_a", maximize_reuse=True)
     gate = ApplyXToIJKthQubit(target_shape)
     g = cirq_ft.testing.GateHelper(gate, context=cirq.DecompositionContext(greedy_mm))
-    assert len(g.all_qubits) <= gate.registers.bitsize + gate.selection_registers.bitsize - 1
+    assert (
+        len(g.all_qubits) <= gate.registers.total_bits() + gate.selection_registers.total_bits() - 1
+    )
 
     max_i, max_j, max_k = target_shape
-    i_len, j_len, k_len = tuple(reg.bitsize for reg in gate.selection_registers)
+    i_len, j_len, k_len = tuple(reg.total_bits() for reg in gate.selection_registers)
     for i, j, k in itertools.product(range(max_i), range(max_j), range(max_k)):
         qubit_vals = {x: 0 for x in g.operation.qubits}
         # Initialize selection bits appropriately:
         qubit_vals.update(zip(g.quregs['i'], iter_bits(i, i_len)))
         qubit_vals.update(zip(g.quregs['j'], iter_bits(j, j_len)))
         qubit_vals.update(zip(g.quregs['k'], iter_bits(k, k_len)))
         # Construct initial state
@@ -139,15 +143,17 @@
         cirq_ft.testing.assert_circuit_inp_out_cirqsim(
             g.circuit, g.operation.qubits, initial_state, final_state
         )
 
 
 def test_unary_iteration_loop():
     n_range, m_range = (3, 5), (6, 8)
-    selection_registers = cirq_ft.SelectionRegisters.build(n=(3, 5), m=(3, 8))
+    selection_registers = cirq_ft.SelectionRegisters(
+        [cirq_ft.SelectionRegister('n', 3, 5), cirq_ft.SelectionRegister('m', 3, 8)]
+    )
     selection = selection_registers.get_named_qubits()
     target = {(n, m): cirq.q(f't({n}, {m})') for n in range(*n_range) for m in range(*m_range)}
     qm = cirq_ft.GreedyQubitManager("ancilla", maximize_reuse=True)
     circuit = cirq.Circuit()
     i_ops = []
     # Build the unary iteration circuit
     for i_optree, i_ctrl, i in cirq_ft.unary_iteration(
```

## cirq_ft/algos/mean_estimation/complex_phase_oracle.py

```diff
@@ -8,15 +8,15 @@
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-from typing import Sequence
+from numpy.typing import NDArray
 
 import attr
 import cirq
 from cirq._compat import cached_property
 from cirq_ft import infra
 from cirq_ft.algos import select_and_prepare
 from cirq_ft.algos.mean_estimation import arctan
@@ -45,18 +45,23 @@
         return self.encoder.selection_registers
 
     @cached_property
     def registers(self) -> infra.Registers:
         return infra.Registers([*self.control_registers, *self.selection_registers])
 
     def decompose_from_registers(
-        self, *, context: cirq.DecompositionContext, **quregs: Sequence[cirq.Qid]
+        self,
+        *,
+        context: cirq.DecompositionContext,
+        **quregs: NDArray[cirq.Qid],  # type:ignore[type-var]
     ) -> cirq.OP_TREE:
         qm = context.qubit_manager
-        target_reg = {reg.name: qm.qalloc(reg.bitsize) for reg in self.encoder.target_registers}
+        target_reg = {
+            reg.name: qm.qalloc(reg.total_bits()) for reg in self.encoder.target_registers
+        }
         target_qubits = self.encoder.target_registers.merge_qubits(**target_reg)
         encoder_op = self.encoder.on_registers(**quregs, **target_reg)
 
         arctan_sign, arctan_target = qm.qalloc(1), qm.qalloc(self.arctan_bitsize)
         arctan_op = arctan.ArcTan(len(target_qubits), self.arctan_bitsize).on(
             *target_qubits, *arctan_sign, *arctan_target
         )
@@ -69,10 +74,10 @@
 
         yield cirq.inverse(arctan_op)
         yield cirq.inverse(encoder_op)
 
         qm.qfree([*arctan_sign, *arctan_target, *target_qubits])
 
     def _circuit_diagram_info_(self, args: cirq.CircuitDiagramInfoArgs) -> cirq.CircuitDiagramInfo:
-        wire_symbols = ['@'] * self.control_registers.bitsize
-        wire_symbols += ['ROTy'] * self.selection_registers.bitsize
+        wire_symbols = ['@'] * self.control_registers.total_bits()
+        wire_symbols += ['ROTy'] * self.selection_registers.total_bits()
         return cirq.CircuitDiagramInfo(wire_symbols=wire_symbols)
```

## cirq_ft/algos/mean_estimation/complex_phase_oracle_test.py

```diff
@@ -34,15 +34,15 @@
     @cached_property
     def control_registers(self) -> cirq_ft.Registers:
         registers = [] if self.control_val is None else [cirq_ft.Register('control', 1)]
         return cirq_ft.Registers(registers)
 
     @cached_property
     def selection_registers(self) -> cirq_ft.SelectionRegisters:
-        return cirq_ft.SelectionRegisters.build(selection=(self.bitsize, 2**self.bitsize))
+        return cirq_ft.SelectionRegisters.build(selection=self.bitsize)
 
     @cached_property
     def target_registers(self) -> cirq_ft.Registers:
         return cirq_ft.Registers.build(target=self.bitsize)
 
     def decompose_from_registers(self, context, selection, target):
         yield [cirq.CNOT(s, t) for s, t in zip(selection, target)]
```

## cirq_ft/algos/mean_estimation/mean_estimation_operator.py

```diff
@@ -9,14 +9,15 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 from typing import Collection, Optional, Sequence, Tuple, Union
+from numpy.typing import NDArray
 
 import attr
 import cirq
 from cirq._compat import cached_property
 from cirq_ft import infra
 from cirq_ft.algos import reflection_using_prepare as rup
 from cirq_ft.algos import select_and_prepare as sp
@@ -106,30 +107,35 @@
         return self.code.encoder.selection_registers
 
     @cached_property
     def registers(self) -> infra.Registers:
         return infra.Registers([*self.control_registers, *self.selection_registers])
 
     def decompose_from_registers(
-        self, *, context: cirq.DecompositionContext, **quregs: Sequence[cirq.Qid]
+        self,
+        *,
+        context: cirq.DecompositionContext,
+        **quregs: NDArray[cirq.Qid],  # type:ignore[type-var]
     ) -> cirq.OP_TREE:
         select_reg = {reg.name: quregs[reg.name] for reg in self.select.registers}
         reflect_reg = {reg.name: quregs[reg.name] for reg in self.reflect.registers}
         select_op = self.select.on_registers(**select_reg)
         reflect_op = self.reflect.on_registers(**reflect_reg)
         for _ in range(self.power):
             yield select_op
             # Add a -1 global phase since `ReflectUsingPrepare` applies $R_{s} = I - 2|s><s|$
             # but we want to apply $R_{s} = 2|s><s| - I$ and this algorithm is sensitive to global
             # phase.
             yield [reflect_op, cirq.global_phase_operation(-1)]
 
     def _circuit_diagram_info_(self, args: cirq.CircuitDiagramInfoArgs) -> cirq.CircuitDiagramInfo:
         wire_symbols = [] if self.cv == () else [["@(0)", "@"][self.cv[0]]]
-        wire_symbols += ['U_ko'] * (self.registers.bitsize - self.control_registers.bitsize)
+        wire_symbols += ['U_ko'] * (
+            self.registers.total_bits() - self.control_registers.total_bits()
+        )
         if self.power != 1:
             wire_symbols[-1] = f'U_ko^{self.power}'
         return cirq.CircuitDiagramInfo(wire_symbols=wire_symbols)
 
     def controlled(
         self,
         num_controls: Optional[int] = None,
```

## cirq_ft/algos/mean_estimation/mean_estimation_operator_test.py

```diff
@@ -29,15 +29,15 @@
     r"""Synthesizes the state $sqrt(1 - p)|00..00> + sqrt(p)|11..11>$"""
 
     p: float
     nqubits: int
 
     @cached_property
     def selection_registers(self) -> cirq_ft.SelectionRegisters:
-        return cirq_ft.SelectionRegisters.build(q=(self.nqubits, 2))
+        return cirq_ft.SelectionRegisters([cirq_ft.SelectionRegister('q', self.nqubits, 2)])
 
     def decompose_from_registers(  # type:ignore[override]
         self, context, q: Sequence[cirq.Qid]
     ) -> cirq.OP_TREE:
         theta = np.arccos(np.sqrt(1 - self.p))
         yield cirq.ry(2 * theta).on(q[0])
         yield [cirq.CNOT(q[0], q[i]) for i in range(1, len(q))]
@@ -56,15 +56,17 @@
     @cached_property
     def control_registers(self) -> cirq_ft.Registers:
         registers = [] if self.control_val is None else [cirq_ft.Register('control', 1)]
         return cirq_ft.Registers(registers)
 
     @cached_property
     def selection_registers(self) -> cirq_ft.SelectionRegisters:
-        return cirq_ft.SelectionRegisters.build(q=(self.selection_bitsize, 2))
+        return cirq_ft.SelectionRegisters(
+            [cirq_ft.SelectionRegister('q', self.selection_bitsize, 2)]
+        )
 
     @cached_property
     def target_registers(self) -> cirq_ft.Registers:
         return cirq_ft.Registers.build(t=self.target_bitsize)
 
     def decompose_from_registers(  # type:ignore[override]
         self, context, q: Sequence[cirq.Qid], t: Sequence[cirq.Qid]
@@ -122,15 +124,15 @@
 
     expected_hav = abs(mu) * np.sqrt(1 / (1 + s**2))
     expected_hav_low = expected_hav / (1 + c * s)
     expected_hav_high = expected_hav / (1 - c * s)
 
     overlap_sum = 0.0
     eigvals, eigvects = cirq.linalg.unitary_eig(u)
-    for (eig_val, eig_vect) in zip(eigvals, eigvects.T):
+    for eig_val, eig_vect in zip(eigvals, eigvects.T):
         theta = np.abs(np.angle(eig_val))
         hav_theta = np.sin(theta / 2)
         overlap_prob = overlap(prep_state, eig_vect)
         if expected_hav_low <= hav_theta <= expected_hav_high:
             overlap_sum += overlap_prob
     return overlap_sum >= 1 - 2 / (c**2) > 0
 
@@ -169,15 +171,15 @@
 class GroverSynthesizer(cirq_ft.PrepareOracle):
     r"""Prepare a uniform superposition over the first $2^n$ elements."""
 
     n: int
 
     @cached_property
     def selection_registers(self) -> cirq_ft.SelectionRegisters:
-        return cirq_ft.SelectionRegisters.build(selection=(self.n, 2**self.n))
+        return cirq_ft.SelectionRegisters.build(selection=self.n)
 
     def decompose_from_registers(  # type:ignore[override]
         self, *, context, selection: Sequence[cirq.Qid]
     ) -> cirq.OP_TREE:
         yield cirq.H.on_each(*selection)
 
     def __pow__(self, power):
@@ -196,25 +198,27 @@
 
     @cached_property
     def control_registers(self) -> cirq_ft.Registers:
         return cirq_ft.Registers([])
 
     @cached_property
     def selection_registers(self) -> cirq_ft.SelectionRegisters:
-        return cirq_ft.SelectionRegisters.build(selection=(self.n, 2**self.n))
+        return cirq_ft.SelectionRegisters.build(selection=self.n)
 
     @cached_property
     def target_registers(self) -> cirq_ft.Registers:
         return cirq_ft.Registers.build(target=self.marked_val.bit_length())
 
     def decompose_from_registers(  # type:ignore[override]
         self, context, *, selection: Sequence[cirq.Qid], target: Sequence[cirq.Qid]
     ) -> cirq.OP_TREE:
-        selection_cv = [*bit_tools.iter_bits(self.marked_item, self.selection_registers.bitsize)]
-        yval_bin = [*bit_tools.iter_bits(self.marked_val, self.target_registers.bitsize)]
+        selection_cv = [
+            *bit_tools.iter_bits(self.marked_item, self.selection_registers.total_bits())
+        ]
+        yval_bin = [*bit_tools.iter_bits(self.marked_val, self.target_registers.total_bits())]
 
         for b, q in zip(yval_bin, target):
             if b:
                 yield cirq.X(q).controlled_by(*selection, control_values=selection_cv)
 
     @cached_property
     def mu(self) -> float:
```

## cirq_ft/infra/gate_with_registers.py

```diff
@@ -9,35 +9,50 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 import abc
+import itertools
 from typing import Dict, Iterable, List, Optional, Sequence, Tuple, Union, overload
+from numpy.typing import NDArray
 
 import attr
 import cirq
 import numpy as np
 
 
 @attr.frozen
 class Register:
     """A quantum register used to define the input/output API of a `cirq_ft.GateWithRegister`
 
     Args:
         name: The string name of the register
-        bitsize: The number of (qu)bits in the register.
+        shape: Shape of the multi-dimensional qubit register.
     """
 
     name: str
-    bitsize: int
+    shape: Tuple[int, ...] = attr.field(
+        converter=lambda v: (v,) if isinstance(v, int) else tuple(v)
+    )
+
+    def all_idxs(self) -> Iterable[Tuple[int, ...]]:
+        """Iterate over all possible indices of a multidimensional register."""
+        yield from itertools.product(*[range(sh) for sh in self.shape])
+
+    def total_bits(self) -> int:
+        """The total number of bits in this register.
+
+        This is the product of bitsize and each of the dimensions in `shape`.
+        """
+        return int(np.product(self.shape))
 
     def __repr__(self):
-        return f'cirq_ft.Register("{self.name}", {self.bitsize})'
+        return f'cirq_ft.Register(name="{self.name}", shape={self.shape})'
 
 
 class Registers:
     """An ordered collection of `cirq_ft.Register`.
 
     Args:
         registers: an iterable of the contained `cirq_ft.Register`.
@@ -48,21 +63,20 @@
         self._register_dict = {r.name: r for r in self._registers}
         if len(self._registers) != len(self._register_dict):
             raise ValueError("Please provide unique register names.")
 
     def __repr__(self):
         return f'cirq_ft.Registers({self._registers})'
 
-    @property
-    def bitsize(self) -> int:
-        return sum(reg.bitsize for reg in self)
+    def total_bits(self) -> int:
+        return sum(reg.total_bits() for reg in self)
 
     @classmethod
-    def build(cls, **registers: int) -> 'Registers':
-        return cls(Register(name=k, bitsize=v) for k, v in registers.items())
+    def build(cls, **registers: Union[int, Tuple[int, ...]]) -> 'Registers':
+        return cls(Register(name=k, shape=v) for k, v in registers.items())
 
     @overload
     def __getitem__(self, key: int) -> Register:
         pass
 
     @overload
     def __getitem__(self, key: str) -> Register:
@@ -87,43 +101,59 @@
 
     def __iter__(self):
         yield from self._registers
 
     def __len__(self) -> int:
         return len(self._registers)
 
-    def split_qubits(self, qubits: Sequence[cirq.Qid]) -> Dict[str, Sequence[cirq.Qid]]:
+    def split_qubits(
+        self, qubits: Sequence[cirq.Qid]
+    ) -> Dict[str, NDArray[cirq.Qid]]:  # type: ignore[type-var]
         qubit_regs = {}
         base = 0
         for reg in self:
-            qubit_regs[reg.name] = qubits[base : base + reg.bitsize]
-            base += reg.bitsize
+            qubit_regs[reg.name] = np.array(qubits[base : base + reg.total_bits()]).reshape(
+                reg.shape
+            )
+            base += reg.total_bits()
         return qubit_regs
 
-    def merge_qubits(self, **qubit_regs: Union[cirq.Qid, Sequence[cirq.Qid]]) -> List[cirq.Qid]:
+    def merge_qubits(
+        self, **qubit_regs: Union[cirq.Qid, Sequence[cirq.Qid], NDArray[cirq.Qid]]
+    ) -> List[cirq.Qid]:
         ret: List[cirq.Qid] = []
         for reg in self:
             assert reg.name in qubit_regs, "All qubit registers must pe present"
             qubits = qubit_regs[reg.name]
-            qubits = [qubits] if isinstance(qubits, cirq.Qid) else qubits
+            qubits = np.array([qubits] if isinstance(qubits, cirq.Qid) else qubits)
             assert (
-                len(qubits) == reg.bitsize
-            ), f"{reg.name} register must of length {reg.bitsize} but is of length {len(qubits)}"
-            ret += qubits
+                qubits.shape == reg.shape
+            ), f'{reg.name} register must of shape {reg.shape} but is of shape {qubits.shape}'
+            ret += qubits.flatten().tolist()
         return ret
 
-    def get_named_qubits(self) -> Dict[str, List[cirq.Qid]]:
-        def qubits_for_reg(name: str, bitsize: int):
-            return (
-                [cirq.NamedQubit(f"{name}")]
-                if bitsize == 1
-                else cirq.NamedQubit.range(bitsize, prefix=name)
+    def get_named_qubits(self) -> Dict[str, NDArray[cirq.Qid]]:
+        def _qubit_array(reg: Register):
+            qubits = np.empty(reg.shape, dtype=object)
+            for ii in reg.all_idxs():
+                qubits[ii] = cirq.NamedQubit(f'{reg.name}[{", ".join(str(i) for i in ii)}]')
+            return qubits
+
+        def _qubits_for_reg(reg: Register):
+            if len(reg.shape) > 1:
+                return _qubit_array(reg)
+
+            return np.array(
+                [cirq.NamedQubit(f"{reg.name}")]
+                if reg.total_bits() == 1
+                else cirq.NamedQubit.range(reg.total_bits(), prefix=reg.name),
+                dtype=object,
             )
 
-        return {reg.name: qubits_for_reg(reg.name, reg.bitsize) for reg in self}
+        return {reg.name: _qubits_for_reg(reg) for reg in self._registers}
 
     def __eq__(self, other) -> bool:
         return self._registers == other._registers
 
     def __hash__(self):
         return hash(self._registers)
 
@@ -134,21 +164,32 @@
 
     `SelectionRegister` extends the `Register` class to store the iteration length
     corresponding to that register along with its size.
     """
 
     iteration_length: int = attr.field()
 
+    @iteration_length.default
+    def _default_iteration_length(self):
+        return 2 ** self.shape[0]
+
     @iteration_length.validator
     def validate_iteration_length(self, attribute, value):
-        if not (0 <= value <= 2**self.bitsize):
-            raise ValueError(f'iteration length must be in range [0, 2^{self.bitsize}]')
+        if len(self.shape) != 1:
+            raise ValueError(f'Selection register {self.name} should be flat. Found {self.shape=}')
+        if not (0 <= value <= 2 ** self.shape[0]):
+            raise ValueError(f'iteration length must be in range [0, 2^{self.shape[0]}]')
 
     def __repr__(self) -> str:
-        return f'cirq_ft.SelectionRegister("{self.name}", {self.bitsize}, {self.iteration_length})'
+        return (
+            f'cirq_ft.SelectionRegister('
+            f'name="{self.name}", '
+            f'shape={self.shape}, '
+            f'iteration_length={self.iteration_length})'
+        )
 
 
 class SelectionRegisters(Registers):
     """Registers used to represent SELECT registers for various LCU methods.
 
     LCU methods often make use of coherent for-loops via UnaryIteration, iterating over a range
     of values stored as a superposition over the `SELECT` register. The `SelectionRegisters` class
@@ -199,24 +240,16 @@
         return sum(v * self._suffix_prod[i + 1] for i, v in enumerate(selection_vals))
 
     @property
     def total_iteration_size(self) -> int:
         return int(np.product(self.iteration_lengths))
 
     @classmethod
-    def build(cls, **registers: Union[int, Tuple[int, int]]) -> 'SelectionRegisters':
-        reg_dict: Dict[str, Tuple[int, int]] = {
-            k: v if isinstance(v, tuple) else (v, 2**v) for k, v in registers.items()
-        }
-        return SelectionRegisters(
-            [
-                SelectionRegister(name=k, bitsize=v[0], iteration_length=v[1])
-                for k, v in reg_dict.items()
-            ]
-        )
+    def build(cls, **registers: Union[int, Tuple[int, ...]]) -> 'SelectionRegisters':
+        return cls(SelectionRegister(name=k, shape=v) for k, v in registers.items())
 
     @overload
     def __getitem__(self, key: int) -> SelectionRegister:
         pass
 
     @overload
     def __getitem__(self, key: str) -> SelectionRegister:
@@ -290,39 +323,41 @@
 
     @property
     @abc.abstractmethod
     def registers(self) -> Registers:
         ...
 
     def _num_qubits_(self) -> int:
-        return self.registers.bitsize
+        return self.registers.total_bits()
 
     def decompose_from_registers(
-        self, *, context: cirq.DecompositionContext, **quregs: Sequence[cirq.Qid]
+        self, *, context: cirq.DecompositionContext, **quregs: NDArray[cirq.Qid]
     ) -> cirq.OP_TREE:
         return NotImplemented
 
     def _decompose_with_context_(
         self, qubits: Sequence[cirq.Qid], context: Optional[cirq.DecompositionContext] = None
     ) -> cirq.OP_TREE:
         qubit_regs = self.registers.split_qubits(qubits)
         if context is None:
             context = cirq.DecompositionContext(cirq.ops.SimpleQubitManager())
         return self.decompose_from_registers(context=context, **qubit_regs)
 
     def _decompose_(self, qubits: Sequence[cirq.Qid]) -> cirq.OP_TREE:
         return self._decompose_with_context_(qubits)
 
-    def on_registers(self, **qubit_regs: Union[cirq.Qid, Sequence[cirq.Qid]]) -> cirq.Operation:
+    def on_registers(
+        self, **qubit_regs: Union[cirq.Qid, Sequence[cirq.Qid], NDArray[cirq.Qid]]
+    ) -> cirq.Operation:
         return self.on(*self.registers.merge_qubits(**qubit_regs))
 
     def _circuit_diagram_info_(self, args: cirq.CircuitDiagramInfoArgs) -> cirq.CircuitDiagramInfo:
         """Default diagram info that uses register names to name the boxes in multi-qubit gates.
 
         Descendants can override this method with more meaningful circuit diagram information.
         """
         wire_symbols = []
         for reg in self.registers:
-            wire_symbols += [reg.name] * reg.bitsize
+            wire_symbols += [reg.name] * reg.total_bits()
 
         wire_symbols[0] = self.__class__.__name__
         return cirq.CircuitDiagramInfo(wire_symbols=wire_symbols)
```

## cirq_ft/infra/gate_with_registers_test.py

```diff
@@ -10,21 +10,22 @@
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 import cirq
 import cirq_ft
+import numpy as np
 import pytest
 from cirq_ft.infra.jupyter_tools import execute_notebook
 
 
 def test_register():
     r = cirq_ft.Register("my_reg", 5)
-    assert r.bitsize == 5
+    assert r.shape == (5,)
 
 
 def test_registers():
     r1 = cirq_ft.Register("r1", 5)
     r2 = cirq_ft.Register("r2", 2)
     r3 = cirq_ft.Register("r3", 1)
     regs = cirq_ft.Registers([r1, r2, r3])
@@ -46,66 +47,82 @@
     assert regs["r2"] == r2
     assert regs["r3"] == r3
 
     assert list(regs) == [r1, r2, r3]
 
     qubits = cirq.LineQubit.range(8)
     qregs = regs.split_qubits(qubits)
-    assert qregs["r1"] == cirq.LineQubit.range(5)
-    assert qregs["r2"] == cirq.LineQubit.range(5, 5 + 2)
-    assert qregs["r3"] == [cirq.LineQubit(7)]
+    assert qregs["r1"].tolist() == cirq.LineQubit.range(5)
+    assert qregs["r2"].tolist() == cirq.LineQubit.range(5, 5 + 2)
+    assert qregs["r3"].tolist() == [cirq.LineQubit(7)]
 
     qubits = qubits[::-1]
     merged_qregs = regs.merge_qubits(r1=qubits[:5], r2=qubits[5:7], r3=qubits[-1])
     assert merged_qregs == qubits
 
     expected_named_qubits = {
         "r1": cirq.NamedQubit.range(5, prefix="r1"),
         "r2": cirq.NamedQubit.range(2, prefix="r2"),
         "r3": [cirq.NamedQubit("r3")],
     }
-    assert regs.get_named_qubits() == expected_named_qubits
+
+    named_qregs = regs.get_named_qubits()
+    for reg_name in expected_named_qubits:
+        assert np.array_equal(named_qregs[reg_name], expected_named_qubits[reg_name])
+
     # Python dictionaries preserve insertion order, which should be same as insertion order of
     # initial registers.
     for reg_order in [[r1, r2, r3], [r2, r3, r1]]:
         flat_named_qubits = [
             q for v in cirq_ft.Registers(reg_order).get_named_qubits().values() for q in v
         ]
         expected_qubits = [q for r in reg_order for q in expected_named_qubits[r.name]]
         assert flat_named_qubits == expected_qubits
 
 
 @pytest.mark.parametrize('n, N, m, M', [(4, 10, 5, 19), (4, 16, 5, 32)])
 def test_selection_registers_indexing(n, N, m, M):
-    reg = cirq_ft.SelectionRegisters.build(x=(n, N), y=(m, M))
+    reg = cirq_ft.SelectionRegisters(
+        [cirq_ft.SelectionRegister('x', n, N), cirq_ft.SelectionRegister('y', m, M)]
+    )
     assert reg.iteration_lengths == (N, M)
     for x in range(N):
         for y in range(M):
             assert reg.to_flat_idx(x, y) == x * M + y
 
     assert reg.total_iteration_size == N * M
 
 
 def test_selection_registers_consistent():
     with pytest.raises(ValueError, match="iteration length must be in "):
         _ = cirq_ft.SelectionRegister('a', 3, 10)
 
-    selection_reg = cirq_ft.SelectionRegisters.build(n=(3, 5), m=(4, 12))
+    with pytest.raises(ValueError, match="should be flat"):
+        _ = cirq_ft.SelectionRegister('a', (3, 5), 5)
+
+    selection_reg = cirq_ft.SelectionRegisters(
+        [
+            cirq_ft.SelectionRegister('n', shape=3, iteration_length=5),
+            cirq_ft.SelectionRegister('m', shape=4, iteration_length=12),
+        ]
+    )
     assert selection_reg[0] == cirq_ft.SelectionRegister('n', 3, 5)
     assert selection_reg['n'] == cirq_ft.SelectionRegister('n', 3, 5)
     assert selection_reg[1] == cirq_ft.SelectionRegister('m', 4, 12)
     assert selection_reg[:1] == cirq_ft.SelectionRegisters([cirq_ft.SelectionRegister('n', 3, 5)])
 
 
 def test_registers_getitem_raises():
     g = cirq_ft.Registers.build(a=4, b=3, c=2)
     with pytest.raises(IndexError, match="must be of the type"):
         _ = g[2.5]
 
-    selection_reg = cirq_ft.SelectionRegisters.build(n=(3, 5))
+    selection_reg = cirq_ft.SelectionRegisters(
+        [cirq_ft.SelectionRegister('n', shape=3, iteration_length=5)]
+    )
     with pytest.raises(IndexError, match='must be of the type'):
         _ = selection_reg[2.5]
 
 
 def test_registers_build():
     regs1 = cirq_ft.Registers([cirq_ft.Register("r1", 5), cirq_ft.Register("r2", 2)])
     regs2 = cirq_ft.Registers.build(r1=5, r2=2)
```

## cirq_ft/infra/testing.py

```diff
@@ -10,15 +10,15 @@
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 from dataclasses import dataclass
 from typing import Any, Dict, List, Sequence, Tuple
-
+from numpy.typing import NDArray
 import cirq
 import numpy as np
 from cirq._compat import cached_property
 from cirq_ft.infra import gate_with_registers, t_complexity_protocol
 from cirq_ft.infra.decompose_protocol import _decompose_once_considering_known_decomposition
 
 
@@ -38,15 +38,15 @@
 
     @cached_property
     def r(self) -> gate_with_registers.Registers:
         """The Registers system for the gate."""
         return self.gate.registers
 
     @cached_property
-    def quregs(self) -> Dict[str, List[cirq.Qid]]:
+    def quregs(self) -> Dict[str, NDArray[cirq.Qid]]:  # type: ignore[type-var]
         """A dictionary of named qubits appropriate for the registers for the gate."""
         return self.r.get_named_qubits()
 
     @cached_property
     def all_qubits(self) -> List[cirq.Qid]:
         """All qubits in Register order."""
         merged_qubits = self.r.merge_qubits(**self.quregs)
```

## cirq_ft/infra/testing_test.py

```diff
@@ -10,14 +10,15 @@
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 import cirq
 import cirq_ft
+import numpy as np
 import pytest
 
 
 def test_assert_circuit_inp_out_cirqsim():
     qubits = cirq.LineQubit.range(4)
     initial_state = [0, 1, 0, 0]
     circuit = cirq.Circuit(cirq.X(qubits[3]))
@@ -30,19 +31,21 @@
         cirq_ft.testing.assert_circuit_inp_out_cirqsim(circuit, qubits, initial_state, final_state)
 
 
 def test_gate_helper():
     g = cirq_ft.testing.GateHelper(cirq_ft.And(cv=(1, 0, 1, 0)))
     assert g.gate == cirq_ft.And(cv=(1, 0, 1, 0))
     assert g.r == cirq_ft.Registers.build(control=4, ancilla=2, target=1)
-    assert g.quregs == {
+    expected_quregs = {
         'control': cirq.NamedQubit.range(4, prefix='control'),
         'ancilla': cirq.NamedQubit.range(2, prefix='ancilla'),
         'target': [cirq.NamedQubit('target')],
     }
+    for key in expected_quregs:
+        assert np.array_equal(g.quregs[key], expected_quregs[key])
     assert g.operation.qubits == tuple(g.all_qubits)
     assert len(g.circuit) == 1
 
 
 class DoesNotDecompose(cirq.Operation):
     def _t_complexity_(self) -> cirq_ft.TComplexity:
         return cirq_ft.TComplexity(t=1, clifford=2, rotations=3)
```

## Comparing `cirq_ft-1.2.0.dev20230717193821.dist-info/LICENSE` & `cirq_ft-1.2.0.dev20230717204825.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `cirq_ft-1.2.0.dev20230717193821.dist-info/METADATA` & `cirq_ft-1.2.0.dev20230717204825.dist-info/METADATA`

 * *Files 3% similar despite different names*

```diff
@@ -1,24 +1,24 @@
 Metadata-Version: 2.1
 Name: cirq-ft
-Version: 1.2.0.dev20230717193821
+Version: 1.2.0.dev20230717204825
 Summary: A Cirq package for fault-tolerant algorithms
 Home-page: http://github.com/quantumlib/cirq
 Author: The Cirq Developers
 Author-email: cirq-dev@googlegroups.com
 License: Apache 2
 Platform: UNKNOWN
 Requires-Python: >=3.9.0
 License-File: LICENSE
 Requires-Dist: attrs
 Requires-Dist: cachetools (>=5.3)
 Requires-Dist: ipywidgets
 Requires-Dist: nbconvert
 Requires-Dist: nbformat
-Requires-Dist: cirq-core (==1.2.0.dev20230717193821)
+Requires-Dist: cirq-core (==1.2.0.dev20230717204825)
 
 **This is a development version of Cirq-ft and may be unstable.**
 
 **For the latest stable release of Cirq-ft see**
 `here <https://pypi.org/project/cirq-ft>`__.
 
 .. image:: https://raw.githubusercontent.com/quantumlib/Cirq/master/docs/images/Cirq_logo_color.png
```

## Comparing `cirq_ft-1.2.0.dev20230717193821.dist-info/RECORD` & `cirq_ft-1.2.0.dev20230717204825.dist-info/RECORD`

 * *Files 8% similar despite different names*

```diff
@@ -1,70 +1,70 @@
 cirq_ft/__init__.py,sha256=kjDotbiwECFjkQxV_PWQ25epHm-K3SHzVbHV9zONJbs,1546
-cirq_ft/_version.py,sha256=aryIycGhjE0aI6j8U1leqqpGRftLFWDV1O0oIXwLarA,40
+cirq_ft/_version.py,sha256=wzqWAuuEJhp5Th1SOsiavWXmsZr7z-QoNMrgpC_ke1Q,40
 cirq_ft/algos/__init__.py,sha256=zwN5_e9ZvanHMI8IMVMu1Yr44vlgWMZ0O1xMjGSwZic,1978
-cirq_ft/algos/and_gate.py,sha256=8DVGHIXyfbqcr3G2bfb-ZzQ0_2Tdkeim-lpe-JtH9C0,6324
-cirq_ft/algos/and_gate_test.py,sha256=79vPBHBirFA2mmoJBizYTbATzR6PWOEg_yl4bqrxbqE,9377
-cirq_ft/algos/apply_gate_to_lth_target.py,sha256=yYPUw010EOlYuSvrN0w4zMNTj3gohcJcdBj5PCplrDo,3822
-cirq_ft/algos/apply_gate_to_lth_target_test.py,sha256=K-5rliUAfWfl5eoIRdpoxSuH3UeQ-bCZ1VRCxo5d8WY,4001
-cirq_ft/algos/arithmetic_gates.py,sha256=GA0zg2pjc5-0658KV7ub11HlkSzhDt7e90Atlyo3UZw,27134
+cirq_ft/algos/and_gate.py,sha256=wpQsKwkDLrC9px7VlXLkQeTqcFDJlaOlux9WcmAbTJ0,6416
+cirq_ft/algos/and_gate_test.py,sha256=mBUk6eizWW-im6CFDd54ucA7InrxqxM_mptxb242rQM,9436
+cirq_ft/algos/apply_gate_to_lth_target.py,sha256=P_QTiWNt-ozdfuuAnFn24ashb6WLc50I12gv3-gQHEw,3938
+cirq_ft/algos/apply_gate_to_lth_target_test.py,sha256=u0aiZ8EAWWnyeB0XkpTvhClH3g9AG09U0qePPTN27lc,4100
+cirq_ft/algos/arithmetic_gates.py,sha256=xWm6EmudUppK7DDA8_wxHDPWY_jS7e9T8g9SHbRIoo0,27215
 cirq_ft/algos/arithmetic_gates_test.py,sha256=7XTDzxzc5Eqid7nv1Q9FOMjehvTddapWmgS1_JS65wM,17717
-cirq_ft/algos/generic_select.py,sha256=_gzvevO7sTZ7H4pXRIWglnUFlmudcIP4hqrx0b1Wpx0,5630
+cirq_ft/algos/generic_select.py,sha256=C39VuT4M2SJuMsx4G5ADivTbs9upGptYsjGMJft_Im4,5775
 cirq_ft/algos/generic_select_test.py,sha256=CoUln2E00yorjZJtb7ek1lzZ2-SxNjx0WzXHHc-PrWQ,11576
-cirq_ft/algos/hubbard_model.py,sha256=jp7fJVM9xLrtdQY_c3-Zmw_lQitF-K83qI4r3WieSVs,14455
+cirq_ft/algos/hubbard_model.py,sha256=4rfAIyZJ2PMF3HCgYhtVPdkVyKU2VxNF2njrgF9VCVg,15417
 cirq_ft/algos/hubbard_model_test.py,sha256=pHFYDnStVLLTeL81nJUu98lcTLG_HLDlloD5aL-9Lmg,2984
-cirq_ft/algos/multi_control_multi_target_pauli.py,sha256=b43paZCXJ1-QSD6zGZI54jB77f_Tzmxsm2LOCrk55tY,4341
+cirq_ft/algos/multi_control_multi_target_pauli.py,sha256=hr1H18rxn3j6UcO1iswxGGZPEeVhBgiq_8Rm2VX4A68,4411
 cirq_ft/algos/multi_control_multi_target_pauli_test.py,sha256=Pal6zIp2hmYvaHUDWpi9rSkEqDttrxHbEXMD4OcYXVc,1584
-cirq_ft/algos/prepare_uniform_superposition.py,sha256=qKd6oHIamN81nQzBfUIZ4MDPhIU-RfTwQc5hiY-LreM,4016
-cirq_ft/algos/prepare_uniform_superposition_test.py,sha256=MT8tRyL6sTRF5hrpaNQZPutMztoTg0shgkb4ON99Cro,3398
-cirq_ft/algos/programmable_rotation_gate_array.py,sha256=BPO4LL1KGMAvxqSVy5kH33jIf5Sc8jciE8eoNyujzJ4,9267
-cirq_ft/algos/programmable_rotation_gate_array_test.py,sha256=GtP6ET72pASAckpvO3m1MbSFXC86hWvBnoUODj8mVFA,5966
-cirq_ft/algos/qrom.py,sha256=WoABhq7gNuCUFfmnVekA13kdoZkGe84HmOrDT9jEQzw,7451
-cirq_ft/algos/qrom_test.py,sha256=OGohL2GKeilISfuDWlwKRX7Q3NOK6WF_WCfXrGaxC98,7101
-cirq_ft/algos/qubitization_walk_operator.py,sha256=KtQLDxtskCg7qqU6iMDxPUZ_iIgJrq1tk2oRmGIC0VU,6350
-cirq_ft/algos/qubitization_walk_operator_test.py,sha256=txni8hsWthY7j53WKfT_ynTVIz9Wd_j5sYSZZO-oCY4,13615
-cirq_ft/algos/reflection_using_prepare.py,sha256=ObcTNlzTPceR6m6mvG4bC0fsov-KTiAQFmrmdeokd0I,5399
+cirq_ft/algos/prepare_uniform_superposition.py,sha256=91JZ0T_4gxwzDyjRmRD1yUXStnhWUHIa82wZAqnQS1Y,4103
+cirq_ft/algos/prepare_uniform_superposition_test.py,sha256=gc17z6QOATqtGuTpmEkOOgAEp7ERoeU9MtnW0VNt9dA,3403
+cirq_ft/algos/programmable_rotation_gate_array.py,sha256=BKfUaLdF8FVyM-Gp5H95y3HG0ETA2RPKgMMYAXIXJvY,9368
+cirq_ft/algos/programmable_rotation_gate_array_test.py,sha256=9u9wmZ28RFE4mUYUhvuJcfkAhES-QnRcm6flZI6hMn4,6014
+cirq_ft/algos/qrom.py,sha256=Y_S3sjJm4FNrQuU_pEiI68xl3QQRvT3tNoA3jJikQQs,7606
+cirq_ft/algos/qrom_test.py,sha256=ZLYcLvqmXtWXXCUrrd3o6AmsfzHEUWSLUOEsB7gh-zU,7214
+cirq_ft/algos/qubitization_walk_operator.py,sha256=nnZNqkbowxHIfBP-JacFzi9jYsvsx92S_p04KqXURcU,6427
+cirq_ft/algos/qubitization_walk_operator_test.py,sha256=LXpoWMQCV36UdKvBoqxnUtfvzybEY2KFDQ--aJY59lY,13620
+cirq_ft/algos/reflection_using_prepare.py,sha256=LlZgHgTulrwearlWVbstuy8E9OCsCNluElaoVLoUF2Q,5476
 cirq_ft/algos/reflection_using_prepare_test.py,sha256=vpV9v4FZExbozpmCD5Nb8dJPbaec-gHCI6dNbzKSlI8,14779
 cirq_ft/algos/select_and_prepare.py,sha256=oULWEZewbNzEyKWuQf139CC71GrxMkXBRoct8wkVyUM,2827
-cirq_ft/algos/select_swap_qrom.py,sha256=9tq4M78ZXjPO1f8ynUNcyDFj5Yoo5tHeWe5B92PGr8E,10850
+cirq_ft/algos/select_swap_qrom.py,sha256=D17JOQA3QN_BGb_Kq5DprtLUMa9mrYN5BNFjtLV3NUg,10999
 cirq_ft/algos/select_swap_qrom_test.py,sha256=DiGxbRrk6LajqJaavOZ-CyRQ-JT4hkNpHOX99zsTaHA,3976
-cirq_ft/algos/selected_majorana_fermion.py,sha256=jeLkQMuSecnwWtZDwem-66DOZRBmYHFz6mqDMlHTHhA,4223
-cirq_ft/algos/selected_majorana_fermion_test.py,sha256=T_RwXMd4cVfBKX2kjxweRyIuzSDEdc3llB75wjJH2us,7405
-cirq_ft/algos/state_preparation.py,sha256=HIN_rdkv5Hakz8pniNshdcWTCdTCCJnWdd3OWPvohk4,6871
+cirq_ft/algos/selected_majorana_fermion.py,sha256=tfWLOIi2ZXxo9upnk3T2l9-JHNhCAzJy3lYQ1cl3goQ,4485
+cirq_ft/algos/selected_majorana_fermion_test.py,sha256=jJDhl-AfHzXdA2e832CiBN1Ul9CU51Dn39FgtbmZT-0,7642
+cirq_ft/algos/state_preparation.py,sha256=wBEPgKUCyFWxrevtCBxQYBJRaClvJMwgPZNnnxOYT-o,6972
 cirq_ft/algos/state_preparation_test.py,sha256=pIg1kmS5Qk9lOxaCAX4QSlCvLbtLtWgSsy72glHqh-c,6673
-cirq_ft/algos/swap_network.py,sha256=zTwYcBuXGHc0I4h3VAE056oQPzDfqfijhniGYPAOvQY,8722
-cirq_ft/algos/swap_network_test.py,sha256=REKn81DdlnHwJlGhKYVFXFTIVC4iq-Kfivtsp6kBruY,6530
-cirq_ft/algos/unary_iteration_gate.py,sha256=vidFB22o27pckiZwiwy7gcn6MFSloGRzYNsY4XvhkTo,17396
-cirq_ft/algos/unary_iteration_gate_test.py,sha256=LgkasXx-jAXkrhzotQFPtmijq8x1-XsLVBf_IjkzM9E,8003
+cirq_ft/algos/swap_network.py,sha256=Ba8htymofq8qNHntyugIV0Cw792ZFwr93L4vvQi_qAE,8789
+cirq_ft/algos/swap_network_test.py,sha256=YAboSWT25xNOH6bY_SxREMCoWgm2y4siMBgQ3sioThU,6463
+cirq_ft/algos/unary_iteration_gate.py,sha256=zM21z8gFnQZ24-023T8AsK5DVEkWh7zIvvUMovY-bgQ,17538
+cirq_ft/algos/unary_iteration_gate_test.py,sha256=_C6fgdkd7Ea1IWJiRFYrLLtZCcB6WfFINo8idOKG3-E,8091
 cirq_ft/algos/mean_estimation/__init__.py,sha256=s2u-R5oVBxxktlcIilJ9Tf487EeqlcDYCUB4yENPhBY,849
 cirq_ft/algos/mean_estimation/arctan.py,sha256=Aegt_hvHoaIGnGEAzGU93_6HXKj7yUlGdKx6-sowSGg,2263
 cirq_ft/algos/mean_estimation/arctan_test.py,sha256=aa1wvtjeEu4GM-5Na_IDn21JfPTwCWltwVLrvuFe-Dk,1875
-cirq_ft/algos/mean_estimation/complex_phase_oracle.py,sha256=h-vtaYbqhK7wB1ycYs1JS6Wmjv8zl1K4N7yGwN-07bg,3195
-cirq_ft/algos/mean_estimation/complex_phase_oracle_test.py,sha256=m2GgTdBgUcVnXYXyQ1QXrRtx2ha538N07YzGNHBjNX8,3407
-cirq_ft/algos/mean_estimation/mean_estimation_operator.py,sha256=dM5BGg6FFDKqRbY7JWdHPK_81f-Eg7W50Jbd9t8p5H8,7049
-cirq_ft/algos/mean_estimation/mean_estimation_operator_test.py,sha256=baKfKnHo4a-9ZJ0i1KswaHawmYF31igzNGHum-W2IfI,10399
+cirq_ft/algos/mean_estimation/complex_phase_oracle.py,sha256=yNx5qtci7uaG9-ae2f-YohATCeIUEgbblYfYdSDQ1CQ,3286
+cirq_ft/algos/mean_estimation/complex_phase_oracle_test.py,sha256=dJAYPf-toeZY-M6Fui_mxuOAoVFxuyzzeKEWhsP7z4c,3388
+cirq_ft/algos/mean_estimation/mean_estimation_operator.py,sha256=x8QLOhKHH0UcOLVFYj4Xnpnh_e8JlphC0B_02jum8Sc,7163
+cirq_ft/algos/mean_estimation/mean_estimation_operator_test.py,sha256=9k75kDozHCXn29UlP9qSffmT9SIR1LrOPKs5mB2qcSI,10473
 cirq_ft/infra/__init__.py,sha256=AMBWWUtleXWPiw82CJDDmA0z3RlIqJ5mitWEJJMIb_M,1006
 cirq_ft/infra/bit_tools.py,sha256=JbppXGMvWPXPB0lZB489su4p_Vh3JkMHaghFtK4wKxc,3520
 cirq_ft/infra/bit_tools_test.py,sha256=OWfkYXTNoJ_gHBmj0ZEHEjN2OwEyMHOxGbGxvoXCSes,2838
 cirq_ft/infra/decompose_protocol.py,sha256=L7jeKyyzgCTZihJqsenDkPOHnroNoCIYGByP7TJ9lsA,3647
 cirq_ft/infra/decompose_protocol_test.py,sha256=xW6-J82eNtyDy1vWoboWWGgC_vFDO8y_ePb6OmbpSWk,1784
-cirq_ft/infra/gate_with_registers.py,sha256=WTxWOzWqigAVX78MrS19IcZUrdyXfF5K-7NpFR31S-I,12231
-cirq_ft/infra/gate_with_registers_test.py,sha256=Y8JnRX9OX3ciPhx34aZ-Nbe6xY9C3mpULHRFkbgNBvU,4949
+cirq_ft/infra/gate_with_registers.py,sha256=KpyK2eJgj3zOrqbKaWKz60z5FuLhSNcq2pwaBkVMIPs,13514
+cirq_ft/infra/gate_with_registers_test.py,sha256=tFJlM-eFXg9K4T5Jx9tg3Ro2Y-skjiw2_JXdqH4DIlo,5498
 cirq_ft/infra/jupyter_tools.py,sha256=W3C2muUyoOEnQIK86q3Qz7eS5Hdocqkp2DOga-VXeKo,3938
 cirq_ft/infra/jupyter_tools_test.py,sha256=Q5_bR6iEk1GywsEqcRQBKo5JItmSocSOdJNpNl5oE6c,1992
 cirq_ft/infra/qubit_management_transformers.py,sha256=lVvpzbC7PuKLpUka1koVJEwL9omay8PBemjKFD8dApc,9405
 cirq_ft/infra/qubit_management_transformers_test.py,sha256=jlMrICYSW0eAc8AZIGXaRa3BJEU-UMFPblr0RfJxC9M,13631
 cirq_ft/infra/qubit_manager.py,sha256=mlNZhLHT92Eewyv3514rfZC39EthnvbnvkH3hmjb0ns,3853
 cirq_ft/infra/qubit_manager_test.py,sha256=EsbIC2QZ1HYCMblD27MrD2TNVuE6A9O0oviKoD_KVmQ,3126
 cirq_ft/infra/t_complexity_protocol.py,sha256=vrGlhJmo91ihw6OlhRa2TuBPC1cEPlZlF5YQZaps-ts,6693
 cirq_ft/infra/t_complexity_protocol_test.py,sha256=equxhpL9yqDxlywkpv-cVJnH0ye-eMk45j-C2u-vlLE,7836
-cirq_ft/infra/testing.py,sha256=0aJOkAmuLcyQE9fC2d8f1T-8awaOUh9M53O6ujLov34,5244
-cirq_ft/infra/testing_test.py,sha256=1x_NFb9tc_Ej3H6zNUsnkUu1dHinazY7hSUDb_mmtc4,2683
+cirq_ft/infra/testing.py,sha256=gMcLzR-ww4rbYJYYoJrVmC96m_l0gpVZtjuDySE5cIk,5305
+cirq_ft/infra/testing_test.py,sha256=NgIj_S5L1BOYE8hkv3WZEcAFb7CQzSEkaPIRdU-jjoo,2800
 cirq_ft/infra/type_convertors.py,sha256=XtGCyGVkWi-iZQhIxz-CqxnHugwo2Sl_0b_a3Qglz0s,809
 cirq_ft/infra/type_convertors_test.py,sha256=FHny6Ubxbla8LRBJg2RsuEMgofRjqF82C6yMHhvLGbk,772
 cirq_ft/linalg/__init__.py,sha256=T67aZHhaDq9hZ8SwhPMDLVq-VzzOxKeqOb0m3Ofkle4,673
 cirq_ft/linalg/lcu_util.py,sha256=2RJ6SBifVXN6aJMfXqb98Ec5_8fRWWNmjn93P_bvdNc,8140
 cirq_ft/linalg/lcu_util_test.py,sha256=FejxO4ajd0t1t3TO7o677NDGjjuac3yD4uLFgVuCt14,6420
-cirq_ft-1.2.0.dev20230717193821.dist-info/LICENSE,sha256=tAkwu8-AdEyGxGoSvJ2gVmQdcicWw3j1ZZueVV74M-E,11357
-cirq_ft-1.2.0.dev20230717193821.dist-info/METADATA,sha256=n3YvOEX1HX4SVOlPE9NyRD8Z6gPwZk6I3niRGHeEbkM,1509
-cirq_ft-1.2.0.dev20230717193821.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-cirq_ft-1.2.0.dev20230717193821.dist-info/top_level.txt,sha256=H8KJHkgeicc6P99pLIx51PGnLymjmgmVoKeeGGZxP_M,8
-cirq_ft-1.2.0.dev20230717193821.dist-info/RECORD,,
+cirq_ft-1.2.0.dev20230717204825.dist-info/LICENSE,sha256=tAkwu8-AdEyGxGoSvJ2gVmQdcicWw3j1ZZueVV74M-E,11357
+cirq_ft-1.2.0.dev20230717204825.dist-info/METADATA,sha256=dleUGjcFc7CpsPev37IYnKuDPpRY7puaQj_8WaIquIg,1509
+cirq_ft-1.2.0.dev20230717204825.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+cirq_ft-1.2.0.dev20230717204825.dist-info/top_level.txt,sha256=H8KJHkgeicc6P99pLIx51PGnLymjmgmVoKeeGGZxP_M,8
+cirq_ft-1.2.0.dev20230717204825.dist-info/RECORD,,
```

