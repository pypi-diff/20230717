# Comparing `tmp/BitCash-0.6.8-py3-none-any.whl.zip` & `tmp/BitCash-1.0.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,44 +1,48 @@
-Zip file size: 49242 bytes, number of entries: 42
--rw-r--r--  2.0 unx      312 b- defN 23-May-11 03:06 bitcash/__init__.py
--rw-r--r--  2.0 unx     5199 b- defN 23-May-11 03:06 bitcash/_ripemd160.py
--rw-r--r--  2.0 unx     1819 b- defN 23-May-11 03:06 bitcash/base58.py
--rw-r--r--  2.0 unx     7517 b- defN 23-May-11 03:06 bitcash/cashaddress.py
--rw-r--r--  2.0 unx      309 b- defN 23-May-11 03:06 bitcash/cli.py
--rw-r--r--  2.0 unx      576 b- defN 23-May-11 03:06 bitcash/crypto.py
--rw-r--r--  2.0 unx      483 b- defN 23-May-11 03:06 bitcash/curve.py
--rw-r--r--  2.0 unx      189 b- defN 23-May-11 03:06 bitcash/exceptions.py
--rw-r--r--  2.0 unx     4859 b- defN 23-May-11 03:06 bitcash/format.py
--rw-r--r--  2.0 unx     2386 b- defN 23-May-11 03:06 bitcash/keygen.py
--rw-r--r--  2.0 unx    12522 b- defN 23-May-11 03:06 bitcash/transaction.py
--rw-r--r--  2.0 unx     1218 b- defN 23-May-11 03:06 bitcash/utils.py
--rw-r--r--  2.0 unx    21610 b- defN 23-May-11 03:06 bitcash/wallet.py
--rw-r--r--  2.0 unx      170 b- defN 23-May-11 03:06 bitcash/network/__init__.py
--rw-r--r--  2.0 unx     1166 b- defN 23-May-11 03:06 bitcash/network/meta.py
--rw-r--r--  2.0 unx    20839 b- defN 23-May-11 03:06 bitcash/network/rates.py
--rw-r--r--  2.0 unx     7301 b- defN 23-May-11 03:06 bitcash/network/services.py
--rw-r--r--  2.0 unx     2032 b- defN 23-May-11 03:06 bitcash/network/transaction.py
--rw-r--r--  2.0 unx     4939 b- defN 23-May-11 03:06 bitcash/network/APIs/BitcoinDotComAPI.py
--rw-r--r--  2.0 unx        0 b- defN 23-May-11 03:06 bitcash/network/APIs/__init__.py
--rw-r--r--  2.0 unx      241 b- defN 23-May-11 03:06 bitcash/network/http/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-May-11 03:06 tests/__init__.py
--rw-r--r--  2.0 unx     4713 b- defN 23-May-11 03:06 tests/samples.py
--rw-r--r--  2.0 unx     1036 b- defN 23-May-11 03:06 tests/test_base58.py
--rw-r--r--  2.0 unx     9509 b- defN 23-May-11 03:06 tests/test_cashaddress.py
--rw-r--r--  2.0 unx      900 b- defN 23-May-11 03:06 tests/test_curve.py
--rw-r--r--  2.0 unx    10596 b- defN 23-May-11 03:06 tests/test_format.py
--rw-r--r--  2.0 unx    14436 b- defN 23-May-11 03:06 tests/test_transaction.py
--rw-r--r--  2.0 unx     2690 b- defN 23-May-11 03:06 tests/test_utils.py
--rw-r--r--  2.0 unx    15886 b- defN 23-May-11 03:06 tests/test_wallet.py
--rw-r--r--  2.0 unx      672 b- defN 23-May-11 03:06 tests/utils.py
--rw-r--r--  2.0 unx        0 b- defN 23-May-11 03:06 tests/network/__init__.py
--rw-r--r--  2.0 unx     1012 b- defN 23-May-11 03:06 tests/network/test_meta.py
--rw-r--r--  2.0 unx     2614 b- defN 23-May-11 03:06 tests/network/test_rates.py
--rw-r--r--  2.0 unx    15408 b- defN 23-May-11 03:06 tests/network/test_services.py
--rw-r--r--  2.0 unx      428 b- defN 23-May-11 03:08 BitCash-0.6.8.dist-info/AUTHORS.md
--rw-r--r--  2.0 unx     1052 b- defN 23-May-11 03:08 BitCash-0.6.8.dist-info/LICENSE.txt
--rw-r--r--  2.0 unx     4294 b- defN 23-May-11 03:08 BitCash-0.6.8.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-May-11 03:08 BitCash-0.6.8.dist-info/WHEEL
--rw-r--r--  2.0 unx       49 b- defN 23-May-11 03:08 BitCash-0.6.8.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       14 b- defN 23-May-11 03:08 BitCash-0.6.8.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     3333 b- defN 23-May-11 03:08 BitCash-0.6.8.dist-info/RECORD
-42 files, 184421 bytes uncompressed, 44006 bytes compressed:  76.1%
+Zip file size: 69021 bytes, number of entries: 46
+-rw-r--r--  2.0 unx      312 b- defN 23-Jul-17 07:37 bitcash/__init__.py
+-rw-r--r--  2.0 unx     5199 b- defN 23-Jul-17 07:37 bitcash/_ripemd160.py
+-rw-r--r--  2.0 unx     1819 b- defN 23-Jul-17 07:37 bitcash/base58.py
+-rw-r--r--  2.0 unx    12890 b- defN 23-Jul-17 07:37 bitcash/cashaddress.py
+-rw-r--r--  2.0 unx    22719 b- defN 23-Jul-17 07:37 bitcash/cashtoken.py
+-rw-r--r--  2.0 unx      309 b- defN 23-Jul-17 07:37 bitcash/cli.py
+-rw-r--r--  2.0 unx      576 b- defN 23-Jul-17 07:37 bitcash/crypto.py
+-rw-r--r--  2.0 unx      483 b- defN 23-Jul-17 07:37 bitcash/curve.py
+-rw-r--r--  2.0 unx      236 b- defN 23-Jul-17 07:37 bitcash/exceptions.py
+-rw-r--r--  2.0 unx     7674 b- defN 23-Jul-17 07:37 bitcash/format.py
+-rw-r--r--  2.0 unx     2386 b- defN 23-Jul-17 07:37 bitcash/keygen.py
+-rw-r--r--  2.0 unx     5737 b- defN 23-Jul-17 07:37 bitcash/op.py
+-rw-r--r--  2.0 unx    11113 b- defN 23-Jul-17 07:37 bitcash/transaction.py
+-rw-r--r--  2.0 unx     1742 b- defN 23-Jul-17 07:37 bitcash/utils.py
+-rw-r--r--  2.0 unx    25034 b- defN 23-Jul-17 07:37 bitcash/wallet.py
+-rw-r--r--  2.0 unx      170 b- defN 23-Jul-17 07:37 bitcash/network/__init__.py
+-rw-r--r--  2.0 unx     3910 b- defN 23-Jul-17 07:37 bitcash/network/meta.py
+-rw-r--r--  2.0 unx    20839 b- defN 23-Jul-17 07:37 bitcash/network/rates.py
+-rw-r--r--  2.0 unx     9636 b- defN 23-Jul-17 07:37 bitcash/network/services.py
+-rw-r--r--  2.0 unx     3305 b- defN 23-Jul-17 07:37 bitcash/network/transaction.py
+-rw-r--r--  2.0 unx     8860 b- defN 23-Jul-17 07:37 bitcash/network/APIs/BitcoinDotComAPI.py
+-rw-r--r--  2.0 unx    14017 b- defN 23-Jul-17 07:37 bitcash/network/APIs/ChaingraphAPI.py
+-rw-r--r--  2.0 unx     2764 b- defN 23-Jul-17 07:37 bitcash/network/APIs/__init__.py
+-rw-r--r--  2.0 unx      241 b- defN 23-Jul-17 07:37 bitcash/network/http/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-17 07:37 tests/__init__.py
+-rw-r--r--  2.0 unx     6206 b- defN 23-Jul-17 07:37 tests/samples.py
+-rw-r--r--  2.0 unx     1036 b- defN 23-Jul-17 07:37 tests/test_base58.py
+-rw-r--r--  2.0 unx    10810 b- defN 23-Jul-17 07:37 tests/test_cashaddress.py
+-rw-r--r--  2.0 unx    21615 b- defN 23-Jul-17 07:37 tests/test_cashtoken.py
+-rw-r--r--  2.0 unx      900 b- defN 23-Jul-17 07:37 tests/test_curve.py
+-rw-r--r--  2.0 unx    13615 b- defN 23-Jul-17 07:37 tests/test_format.py
+-rw-r--r--  2.0 unx    20473 b- defN 23-Jul-17 07:37 tests/test_transaction.py
+-rw-r--r--  2.0 unx     3312 b- defN 23-Jul-17 07:37 tests/test_utils.py
+-rw-r--r--  2.0 unx    16157 b- defN 23-Jul-17 07:37 tests/test_wallet.py
+-rw-r--r--  2.0 unx      672 b- defN 23-Jul-17 07:37 tests/utils.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-17 07:37 tests/network/__init__.py
+-rw-r--r--  2.0 unx     2554 b- defN 23-Jul-17 07:37 tests/network/test_meta.py
+-rw-r--r--  2.0 unx     2614 b- defN 23-Jul-17 07:37 tests/network/test_rates.py
+-rw-r--r--  2.0 unx    17092 b- defN 23-Jul-17 07:37 tests/network/test_services.py
+-rw-r--r--  2.0 unx      428 b- defN 23-Jul-17 07:39 BitCash-1.0.0.dist-info/AUTHORS.md
+-rw-r--r--  2.0 unx     1052 b- defN 23-Jul-17 07:39 BitCash-1.0.0.dist-info/LICENSE.txt
+-rw-r--r--  2.0 unx     4294 b- defN 23-Jul-17 07:39 BitCash-1.0.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jul-17 07:39 BitCash-1.0.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       49 b- defN 23-Jul-17 07:39 BitCash-1.0.0.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       14 b- defN 23-Jul-17 07:39 BitCash-1.0.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     3662 b- defN 23-Jul-17 07:39 BitCash-1.0.0.dist-info/RECORD
+46 files, 288618 bytes uncompressed, 63295 bytes compressed:  78.1%
```

## zipnote {}

```diff
@@ -6,14 +6,17 @@
 
 Filename: bitcash/base58.py
 Comment: 
 
 Filename: bitcash/cashaddress.py
 Comment: 
 
+Filename: bitcash/cashtoken.py
+Comment: 
+
 Filename: bitcash/cli.py
 Comment: 
 
 Filename: bitcash/crypto.py
 Comment: 
 
 Filename: bitcash/curve.py
@@ -24,14 +27,17 @@
 
 Filename: bitcash/format.py
 Comment: 
 
 Filename: bitcash/keygen.py
 Comment: 
 
+Filename: bitcash/op.py
+Comment: 
+
 Filename: bitcash/transaction.py
 Comment: 
 
 Filename: bitcash/utils.py
 Comment: 
 
 Filename: bitcash/wallet.py
@@ -51,14 +57,17 @@
 
 Filename: bitcash/network/transaction.py
 Comment: 
 
 Filename: bitcash/network/APIs/BitcoinDotComAPI.py
 Comment: 
 
+Filename: bitcash/network/APIs/ChaingraphAPI.py
+Comment: 
+
 Filename: bitcash/network/APIs/__init__.py
 Comment: 
 
 Filename: bitcash/network/http/__init__.py
 Comment: 
 
 Filename: tests/__init__.py
@@ -69,14 +78,17 @@
 
 Filename: tests/test_base58.py
 Comment: 
 
 Filename: tests/test_cashaddress.py
 Comment: 
 
+Filename: tests/test_cashtoken.py
+Comment: 
+
 Filename: tests/test_curve.py
 Comment: 
 
 Filename: tests/test_format.py
 Comment: 
 
 Filename: tests/test_transaction.py
@@ -99,29 +111,29 @@
 
 Filename: tests/network/test_rates.py
 Comment: 
 
 Filename: tests/network/test_services.py
 Comment: 
 
-Filename: BitCash-0.6.8.dist-info/AUTHORS.md
+Filename: BitCash-1.0.0.dist-info/AUTHORS.md
 Comment: 
 
-Filename: BitCash-0.6.8.dist-info/LICENSE.txt
+Filename: BitCash-1.0.0.dist-info/LICENSE.txt
 Comment: 
 
-Filename: BitCash-0.6.8.dist-info/METADATA
+Filename: BitCash-1.0.0.dist-info/METADATA
 Comment: 
 
-Filename: BitCash-0.6.8.dist-info/WHEEL
+Filename: BitCash-1.0.0.dist-info/WHEEL
 Comment: 
 
-Filename: BitCash-0.6.8.dist-info/entry_points.txt
+Filename: BitCash-1.0.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: BitCash-0.6.8.dist-info/top_level.txt
+Filename: BitCash-1.0.0.dist-info/top_level.txt
 Comment: 
 
-Filename: BitCash-0.6.8.dist-info/RECORD
+Filename: BitCash-1.0.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## bitcash/__init__.py

```diff
@@ -5,8 +5,8 @@
     Key,
     PrivateKey,
     PrivateKeyTestnet,
     PrivateKeyRegtest,
     wif_to_key,
 )
 
-__version__ = "0.6.8"
+__version__ = "1.0.0"
```

## bitcash/cashaddress.py

```diff
@@ -1,8 +1,11 @@
+import io
 from bitcash.exceptions import InvalidAddress
+from bitcash.op import OpCodes
+from bitcash.utils import varint_to_int
 
 CHARSET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l"
 
 
 def polymod(values):
     chk = 1
     generator = [
@@ -70,29 +73,97 @@
 
 
 def prefix_expand(prefix):
     return [ord(x) & 0x1F for x in prefix] + [0]
 
 
 class Address:
+    """
+    Class to handle CashAddr.
+
+    :param version: Version of CashAddr
+    :type version: ``str``
+    :param payload: Payload of CashAddr as int list of the bytearray
+    :type payload: ``list`` of ``int``
+    """
+
     VERSIONS = {
-        "P2SH": {"prefix": "bitcoincash", "version_bit": 8, "network": "mainnet"},
+        "P2SH20": {"prefix": "bitcoincash", "version_bit": 8, "network": "mainnet"},
+        "P2SH32": {"prefix": "bitcoincash", "version_bit": 11, "network": "mainnet"},
         "P2PKH": {"prefix": "bitcoincash", "version_bit": 0, "network": "mainnet"},
-        "P2SH-TESTNET": {"prefix": "bchtest", "version_bit": 8, "network": "testnet"},
+        "P2SH20-TESTNET": {"prefix": "bchtest", "version_bit": 8, "network": "testnet"},
+        "P2SH32-TESTNET": {
+            "prefix": "bchtest",
+            "version_bit": 11,
+            "network": "testnet",
+        },
         "P2PKH-TESTNET": {"prefix": "bchtest", "version_bit": 0, "network": "testnet"},
-        "P2SH-REGTEST": {"prefix": "bchreg", "version_bit": 8, "network": "regtest"},
+        "P2SH20-REGTEST": {"prefix": "bchreg", "version_bit": 8, "network": "regtest"},
+        "P2SH32-REGTEST": {"prefix": "bchreg", "version_bit": 11, "network": "regtest"},
         "P2PKH-REGTEST": {"prefix": "bchreg", "version_bit": 0, "network": "regtest"},
+        "P2SH20-CATKN": {
+            "prefix": "bitcoincash",
+            "version_bit": 24,
+            "network": "mainnet",
+        },
+        "P2SH32-CATKN": {
+            "prefix": "bitcoincash",
+            "version_bit": 27,
+            "network": "mainnet",
+        },
+        "P2PKH-CATKN": {
+            "prefix": "bitcoincash",
+            "version_bit": 16,
+            "network": "mainnet",
+        },
+        "P2SH20-CATKN-TESTNET": {
+            "prefix": "bchtest",
+            "version_bit": 24,
+            "network": "testnet",
+        },
+        "P2SH32-CATKN-TESTNET": {
+            "prefix": "bchtest",
+            "version_bit": 27,
+            "network": "testnet",
+        },
+        "P2PKH-CATKN-TESTNET": {
+            "prefix": "bchtest",
+            "version_bit": 16,
+            "network": "testnet",
+        },
+        "P2SH20-CATKN-REGTEST": {
+            "prefix": "bchreg",
+            "version_bit": 24,
+            "network": "regtest",
+        },
+        "P2SH32-CATKN-REGTEST": {
+            "prefix": "bchreg",
+            "version_bit": 27,
+            "network": "regtest",
+        },
+        "P2PKH-CATKN-REGTEST": {
+            "prefix": "bchreg",
+            "version_bit": 16,
+            "network": "regtest",
+        },
     }
 
     VERSION_SUFFIXES = {"bitcoincash": "", "bchtest": "-TESTNET", "bchreg": "-REGTEST"}
 
-    ADDRESS_TYPES = {0: "P2PKH", 8: "P2SH"}
+    ADDRESS_TYPES = {
+        0: "P2PKH",
+        8: "P2SH20",
+        11: "P2SH32",
+        16: "P2PKH-CATKN",
+        24: "P2SH20-CATKN",
+        27: "P2SH32-CATKN",
+    }
 
     def __init__(self, version, payload):
-        if not version in Address.VERSIONS:
+        if version not in Address.VERSIONS:
             raise ValueError("Invalid address version provided")
 
         self.version = version
         self.payload = payload
         self.prefix = Address.VERSIONS[self.version]["prefix"]
 
     def __str__(self):
@@ -111,22 +182,119 @@
         else:
             raise ValueError(
                 "Address can be compared to a string address"
                 " or an instance of Address"
             )
 
     def cash_address(self):
+        """
+        Generate CashAddr of the Address
+
+        :rtype: ``str``
+        """
         version_bit = Address.VERSIONS[self.version]["version_bit"]
         payload = [version_bit] + self.payload
         payload = convertbits(payload, 8, 5)
         checksum = calculate_checksum(self.prefix, payload)
         return self.prefix + ":" + b32encode(payload + checksum)
 
+    @property
+    def scriptcode(self):
+        """
+        Generate the locking script of the Address
+
+        :rtype: ``bytes``
+        """
+        if "P2PKH" in self.version:
+            return (
+                OpCodes.OP_DUP.binary
+                + OpCodes.OP_HASH160.binary
+                + OpCodes.OP_DATA_20.binary
+                + bytes(self.payload)
+                + OpCodes.OP_EQUALVERIFY.binary
+                + OpCodes.OP_CHECKSIG.binary
+            )
+        if "P2SH20" in self.version:
+            return (
+                OpCodes.OP_HASH160.binary
+                + OpCodes.OP_DATA_20.binary
+                + bytes(self.payload)
+                + OpCodes.OP_EQUAL.binary
+            )
+        if "P2SH32" in self.version:
+            return (
+                OpCodes.OP_HASH256.binary
+                + OpCodes.OP_DATA_32.binary
+                + bytes(self.payload)
+                + OpCodes.OP_EQUAL.binary
+            )
+
+    @classmethod
+    def from_script(cls, scriptcode):
+        """
+        Generate Address from a locking script
+
+        :param scriptcode: The locking script
+        :type scriptcode: ``bytes``
+        :returns: Instance of :class:~bitcash.cashaddress.Address
+        """
+        # cashtoken suffix
+        catkn = ""
+        if scriptcode.startswith(OpCodes.OP_TOKENPREFIX.binary):
+            catkn = "-CATKN"
+            stream = io.BytesIO(scriptcode[33:])
+
+            token_bitfield = stream.read(1).hex()
+            # 4 bit prefix
+            _ = bin(int(token_bitfield[0], 16))[2:]
+            _ = "0" * (4 - len(_)) + _
+            prefix_structure = [bit == "1" for bit in _]
+            if prefix_structure[1]:
+                # has commitment length
+                length = varint_to_int(stream)
+                _ = stream.read(length)
+            if prefix_structure[3]:
+                # has amount
+                _ = varint_to_int(stream)
+            # only use locking script for the rest
+            scriptcode = stream.read()
+
+        # P2PKH
+        if len(scriptcode) == 25:
+            if scriptcode.startswith(
+                OpCodes.OP_DUP.binary
+                + OpCodes.OP_HASH160.binary
+                + OpCodes.OP_DATA_20.binary
+            ) and scriptcode.endswith(
+                OpCodes.OP_EQUALVERIFY.binary + OpCodes.OP_CHECKSIG.binary
+            ):
+                return cls("P2PKH" + catkn, list(scriptcode[3:23]))
+        # P2SH20
+        if len(scriptcode) == 23:
+            if scriptcode.startswith(
+                OpCodes.OP_HASH160.binary + OpCodes.OP_DATA_20.binary
+            ) and scriptcode.endswith(OpCodes.OP_EQUAL.binary):
+                return cls("P2SH20" + catkn, list(scriptcode[2:22]))
+        # P2SH32
+        if len(scriptcode) == 35:
+            if scriptcode.startswith(
+                OpCodes.OP_HASH256.binary + OpCodes.OP_DATA_32.binary
+            ) and scriptcode.endswith(OpCodes.OP_EQUAL.binary):
+                return cls("P2SH32" + catkn, list(scriptcode[2:34]))
+        raise ValueError("Unknown script")
+
     @staticmethod
     def from_string(address):
+        """
+        Generate Address from a cashadress string
+
+        :param scriptcode: The cashaddress string
+        :type scriptcode: ``str``
+        :returns: Instance of :class:~bitcash.cashaddress.Address
+        """
         try:
             address = str(address)
         except Exception:
             raise InvalidAddress("Expected string as input")
 
         if address.upper() != address and address.lower() != address:
             raise InvalidAddress(
```

## bitcash/exceptions.py

```diff
@@ -8,7 +8,11 @@
 
 class InvalidNetwork(Exception):
     pass
 
 
 class InvalidEndpointURLProvided(Exception):
     pass
+
+
+class InvalidCashToken(ValueError):
+    pass
```

## bitcash/format.py

```diff
@@ -1,14 +1,14 @@
 from coincurve import verify_signature as _vs
 
 from bitcash.base58 import b58decode_check, b58encode_check
 from bitcash.cashaddress import Address
 from bitcash.crypto import ripemd160_sha256
 from bitcash.curve import x_to_y
-from bitcash.exceptions import InvalidAddress
+from bitcash.op import OpCodes
 
 MAIN_PUBKEY_HASH = b"\x00"
 MAIN_SCRIPT_HASH = b"\x05"
 MAIN_PRIVATE_KEY = b"\x80"
 MAIN_BIP32_PUBKEY = b"\x04\x88\xb2\x1e"
 MAIN_BIP32_PRIVKEY = b"\x04\x88\xad\xe4"
 
@@ -156,7 +156,97 @@
         return y + x.to_bytes(32, "big")
 
     return PUBLIC_KEY_UNCOMPRESSED + x.to_bytes(32, "big") + y.to_bytes(32, "big")
 
 
 def point_to_public_key(point, compressed=True):
     return coords_to_public_key(point.x, point.y, compressed)
+
+
+def address_to_cashtokenaddress(address):
+    """
+    Converts regular cashaddress to cashtoken signalling address
+
+    :param address: Cashaddress
+    :type address: ``str``
+    :returns: Cashtoken signalling cashaddress
+    :rtype: ``str``
+    """
+    address = Address.from_string(address)
+    if "CATKN" in address.version:
+        return address.cash_address()
+    version = address.version.split("-")
+    version.insert(1, "CATKN")
+    address.version = "-".join(version)
+    return address.cash_address()
+
+
+def cashtokenaddress_to_address(address):
+    """
+    Converts cashtoken signalling cashaddress to regular cashaddress
+
+    :param address: Cashtoken signalling cashaddress
+    :type address: ``str``
+    :returns: Cashaddress
+    :rtype: ``str``
+    """
+    address = Address.from_string(address)
+    if "CATKN" not in address.version:
+        return address.cash_address()
+    version = address.version.split("-")
+    version.pop(1)
+    address.version = "-".join(version)
+    return address.cash_address()
+
+
+def hex_to_asm(data):
+    def _add_value(next_len, indx):
+        next_len *= 2  # hex byte
+        # !TODO: add Signature hash type delineation
+        value = data[indx : indx + next_len]
+        if len(value) != next_len:
+            raise RuntimeError("Data ended prematurely")
+        indx += next_len
+        return value, indx
+
+    indx = 0
+    out = []
+    while indx < len(data):
+        op_code = data[indx : indx + 2]
+        op_code = OpCodes(int(op_code, 16))
+        if op_code == OpCodes.OP_PUSHDATA1:
+            indx += 2
+            next_len = int(data[indx : indx + 2], 16)
+            indx += 2
+            value, indx = _add_value(next_len, indx)
+        elif op_code == OpCodes.OP_PUSHDATA2:
+            indx += 2
+            a = data[indx : indx + 2]
+            indx += 2
+            b = data[indx : indx + 2]
+            next_len = int(b + a, 16)
+            indx += 2
+            value, indx = _add_value(next_len, indx)
+        elif op_code == OpCodes.OP_PUSHDATA4:
+            indx += 2
+            a = data[indx : indx + 2]
+            indx += 2
+            b = data[indx : indx + 2]
+            indx += 2
+            c = data[indx : indx + 2]
+            indx += 2
+            d = data[indx : indx + 2]
+            next_len = int(d + c + b + a, 16)
+            indx += 2
+            value, indx = _add_value(next_len, indx)
+        elif op_code.name.startswith("OP_DATA"):
+            next_len = int(data[indx : indx + 2], 16)
+            indx += 2
+            value, indx = _add_value(next_len, indx)
+            if next_len <= 8:
+                # !TODO: check implementation
+                value = str(int.from_bytes(bytes.fromhex(value), "little"))
+        else:
+            indx += 2
+            value = op_code.name
+        out.append(value)
+    return " ".join(out)
```

## bitcash/transaction.py

```diff
@@ -1,14 +1,20 @@
 import logging
 from collections import namedtuple
+from copy import deepcopy
 
 from bitcash.crypto import double_sha256, sha256
 from bitcash.exceptions import InsufficientFunds
-from bitcash.format import Address
-from bitcash.network.rates import currency_to_satoshi_cached
+from bitcash.cashtoken import (
+    prepare_output,
+    Unspents,
+    select_cashtoken_utxo,
+    generate_cashtoken_prefix,
+)
+from bitcash.op import OpCodes
 from bitcash.utils import (
     bytes_to_hex,
     chunk_data,
     hex_to_bytes,
     int_to_unknown_bytes,
     int_to_varint,
 )
@@ -22,136 +28,95 @@
 HASH_TYPE = 0x01.to_bytes(4, byteorder="little")
 # BitcoinCash fork ID.
 SIGHASH_FORKID = 0x40.to_bytes(4, byteorder="little")
 # So we just do this for now. FIXME
 HASH_TYPE = 0x41.to_bytes(4, byteorder="little")
 ##
 
-OP_0 = b"\x00"
-OP_CHECKLOCKTIMEVERIFY = b"\xb1"
-OP_CHECKSIG = b"\xac"
-OP_DUP = b"v"
-OP_EQUAL = b"\x87"
-OP_EQUALVERIFY = b"\x88"
-OP_HASH160 = b"\xa9"
-OP_PUSH_20 = b"\x14"
-OP_RETURN = b"\x6a"
-OP_PUSHDATA1 = b"\x4c"
-OP_PUSHDATA2 = b"\x4d"
-OP_PUSHDATA4 = b"\x4e"
-
 MESSAGE_LIMIT = 220
 
 
 class TxIn:
-    __slots__ = ("script", "script_len", "txid", "txindex", "amount")
+    __slots__ = ("script", "script_len", "txid", "txindex", "amount", "token_prefix")
 
-    def __init__(self, script, script_len, txid, txindex, amount):
+    def __init__(self, script, script_len, txid, txindex, amount, token_prefix=b""):
         self.script = script
         self.script_len = script_len
         self.txid = txid
         self.txindex = txindex
         self.amount = amount
+        self.token_prefix = token_prefix
 
     def __eq__(self, other):
         return (
             self.script == other.script
             and self.script_len == other.script_len
             and self.txid == other.txid
             and self.txindex == other.txindex
             and self.amount == other.amount
+            and self.token_prefix == other.token_prefix
         )
 
+    def to_dict(self):
+        return {attr: getattr(self, attr) for attr in TxIn.__slots__}
+
     def __repr__(self):
         return (
             f"TxIn({repr(self.script)}, "
             f"{repr(self.script_len)}, "
             f"{repr(self.txid)}, "
             f"{repr(self.txindex)}, "
-            f"{repr(self.amount)})"
+            f"{repr(self.amount)}, {repr(self.token_prefix)})"
         )
 
 
 Output = namedtuple("Output", ("address", "amount", "currency"))
 
 
 def calc_txid(tx_hex):
     return bytes_to_hex(double_sha256(hex_to_bytes(tx_hex))[::-1])
 
 
-def estimate_tx_fee(
-    n_in, n_out_p2pkh, n_out_p2sh, satoshis, compressed, op_return_size=0
-):
+def estimate_tx_fee(n_in, output_script_list, satoshis, compressed):
     if not satoshis:
         return 0
 
-    n_out = n_out_p2sh + n_out_p2pkh
+    n_out = len(output_script_list)
 
     estimated_size = (
-        4
-        + n_in * (148 if compressed else 180)  # version
+        4  # version
         + len(int_to_unknown_bytes(n_in, byteorder="little"))
-        # excluding op_return outputs, dealt with separately
-        + n_out_p2pkh * 34
-        + n_out_p2sh * 32
+        + n_in * (148 if compressed else 180)
         + len(int_to_unknown_bytes(n_out, byteorder="little"))
-        # grand total size of op_return outputs(s) and related field(s)
-        + op_return_size
+        + n_out * 9  # satoshi_value + script_len
+        + sum([len(script) for script in output_script_list])
         + 4  # time lock
     )
 
     estimated_fee = estimated_size * satoshis
 
-    logging.debug(
-        f"Estimated fee: {estimated_fee}" f" satoshis for {estimated_size} bytes"
-    )
+    logging.debug(f"Estimated fee: {estimated_fee} satoshis for {estimated_size} bytes")
 
     return estimated_fee
 
 
-def get_op_return_size(message, custom_pushdata=False):
-    # calculate op_return size for each individual message
-    if custom_pushdata is False:
-        op_return_size = (
-            8  # int64_t amount 0x00000000
-            + len(OP_RETURN)  # 1 byte
-            + len(
-                get_op_pushdata_code(message)
-            )  # 1 byte if <75 bytes, 2 bytes if OP_PUSHDATA1...
-            + len(message)  # Max 220 bytes at present
-        )
-
-    if custom_pushdata is True:
-        op_return_size = (
-            8  # int64_t amount 0x00000000
-            + len(OP_RETURN)  # 1 byte
-            + len(
-                message
-            )  # Unsure if Max size will be >220 bytes due to extra OP_PUSHDATA codes...
-        )
-
-    # "Var_Int" that preceeds OP_RETURN - 0xdf is max value with current 220 byte limit (so only adds 1 byte)
-    op_return_size += len(int_to_varint(op_return_size))
-    return op_return_size
-
-
 def get_op_pushdata_code(dest):
     length_data = len(dest)
     if length_data <= 0x4C:  # (https://en.bitcoin.it/wiki/Script)
         return length_data.to_bytes(1, byteorder="little")
     elif length_data <= 0xFF:
-        return OP_PUSHDATA1 + length_data.to_bytes(
+        return OpCodes.OP_PUSHDATA1.binary + length_data.to_bytes(
             1, byteorder="little"
         )  # OP_PUSHDATA1 format
     elif length_data <= 0xFFFF:
-        return OP_PUSHDATA2 + length_data.to_bytes(
+        return OpCodes.OP_PUSHDATA2.binary + length_data.to_bytes(
             2, byteorder="little"
         )  # OP_PUSHDATA2 format
     else:
-        return OP_PUSHDATA4 + length_data.to_bytes(
+        return OpCodes.OP_PUSHDATA4.binary + length_data.to_bytes(
             4, byteorder="little"
         )  # OP_PUSHDATA4 format
 
 
 def sanitize_tx_data(
     unspents,
     outputs,
@@ -163,162 +128,137 @@
     custom_pushdata=False,
 ):
     """
     sanitize_tx_data()
 
     fee is in satoshis per byte.
     """
-
+    unspents = deepcopy(unspents)
     outputs = outputs.copy()
 
-    for i, output in enumerate(outputs):
-        dest, amount, currency = output
-        dest = Address.from_string(dest)
-
-        if "P2PKH" not in dest.version and "P2SH" not in dest.version:
-            # Bitcash currently only supports P2PKH, P2SH transaction outputs
-            # others will raise ValueError
-            raise ValueError("Bitcash currently only supports" " P2PKH/P2SH outputs")
-
-        outputs[i] = (dest, currency_to_satoshi_cached(amount, currency))
-
     if not unspents:
         raise ValueError("Transactions must have at least one unspent.")
 
+    for i, output in enumerate(outputs):
+        # (script, satoshi value, category_id, nft_capability, nft_commitment,
+        # token_amount)
+        outputs[i] = prepare_output(output)
+
     # Temporary storage so all outputs precede messages.
     messages = []
-    total_op_return_size = 0
 
     if message and (custom_pushdata is False):
         try:
             message = message.encode("utf-8")
         except AttributeError:
             pass  # assume message is already a bytes-like object
 
         message_chunks = chunk_data(message, MESSAGE_LIMIT)
 
         for message in message_chunks:
-            messages.append((message, 0))
-            total_op_return_size += get_op_return_size(message, custom_pushdata=False)
+            script = OpCodes.OP_RETURN.binary + get_op_pushdata_code(message) + message
+            messages.append((script, 0, None, None, None, None))
 
     elif message and (custom_pushdata is True):
         if len(message) >= 220:
             # FIXME add capability for >220 bytes for custom pushdata elements
-            raise ValueError(
-                "Currently cannot exceed 220 " "bytes with custom_pushdata."
-            )
+            raise ValueError("Currently cannot exceed 220 bytes with custom_pushdata.")
         else:
-            messages.append((message, 0))
-            total_op_return_size += get_op_return_size(message, custom_pushdata=True)
+            # manual control over number of bytes in each batch of pushdata
+            if type(message) != bytes:
+                raise TypeError("custom pushdata must be of type: bytes")
+            else:
+                script = OpCodes.OP_RETURN.binary + message
+            messages.append((script, 0, None, None, None, None))
 
-    # Include return address in fee estimate.
-    total_in = 0
-    num_p2pkh_outputs = sum(["P2PKH" in out[0].version for out in outputs])
-    # Bitcash only supports P2PKH utxos, return address is added as P2PKH
-    num_p2pkh_outputs += 1
-    # counting P2SH outs, will adjust fee estimate
-    num_p2sh_outputs = sum(["P2SH" in out[0].version for out in outputs])
-    sum_outputs = sum(out[1] for out in outputs)
+    # counting outs, will adjust fee estimate
+    output_script_list = [_[0] for _ in outputs]
+    output_script_list += [_[0] for _ in messages]
 
     if combine:
+        cashtoken = Unspents(unspents)
+        for output in outputs:
+            cashtoken.subtract_output(output)
+        leftover_outputs, leftover_amount = cashtoken.get_outputs(leftover)
+        output_script_list += [_[0] for _ in leftover_outputs]
         # calculated_fee is in total satoshis.
         calculated_fee = estimate_tx_fee(
             len(unspents),
-            num_p2pkh_outputs,
-            num_p2sh_outputs,
+            output_script_list,
             fee,
             compressed,
-            total_op_return_size,
         )
-        total_out = sum_outputs + calculated_fee
-        unspents = unspents.copy()
-        total_in += sum(unspent.amount for unspent in unspents)
+        if calculated_fee > leftover_amount:
+            raise InsufficientFunds("leftover balance cannot cover fee")
+        if calculated_fee:
+            last_out = list(leftover_outputs[-1])
+            last_out[1] -= calculated_fee
+            leftover_outputs[-1] = tuple(last_out)
 
-    else:
-        unspents = sorted(unspents, key=lambda x: x.amount)
+        outputs += leftover_outputs
 
-        index = 0
+    else:
+        unspents, unspents_used = select_cashtoken_utxo(unspents, outputs)
 
+        error = None
+        # the first unspent is added regardless because of how selection is,
+        # easiest is to pop the last unspent used and add to unspents searched
+        if len(unspents_used) > 0:
+            unspents = [unspents_used[-1]] + unspents
+            unspents_used = unspents_used[:-1]
+        cashtoken = Unspents(unspents_used)
         for index, unspent in enumerate(unspents):
-            total_in += unspent.amount
+            cashtoken.add_unspent(unspent)
+            test_token = deepcopy(cashtoken)
+            try:
+                for output in outputs:
+                    test_token.subtract_output(output)
+                (leftover_outputs, leftover_amount) = test_token.get_outputs(leftover)
+            except InsufficientFunds as err:
+                error = err
+                continue
+
+            output_script_list += [_[0] for _ in leftover_outputs]
+
             calculated_fee = estimate_tx_fee(
-                len(unspents[: index + 1]),
-                num_p2pkh_outputs,
-                num_p2sh_outputs,
+                len(unspents[: index + 1]) + len(unspents_used),
+                output_script_list,
                 fee,
                 compressed,
-                total_op_return_size,
             )
-            total_out = sum_outputs + calculated_fee
-
-            if total_in >= total_out:
+            if calculated_fee < leftover_amount:
                 break
+        else:
+            raise InsufficientFunds(error or f"{cashtoken.amount} is insufficient")
 
-        unspents[:] = unspents[: index + 1]
-
-    remaining = total_in - total_out
+        if calculated_fee:
+            last_out = list(leftover_outputs[-1])
+            last_out[1] -= calculated_fee
+            leftover_outputs[-1] = tuple(last_out)
 
-    if remaining > 0:
-        outputs.append((Address.from_string(leftover), remaining))
-    elif remaining < 0:
-        raise InsufficientFunds(
-            f"Balance {total_in} is less than " f"{total_out} (including fee)."
-        )
+        unspents[:] = unspents_used + unspents[: index + 1]
+        outputs += leftover_outputs
 
     outputs.extend(messages)
 
     return unspents, outputs
 
 
-def construct_output_block(outputs, custom_pushdata=False):
+def construct_output_block(outputs):
     output_block = b""
 
     for data in outputs:
-        dest, amount = data
+        script, amount, _, _, _, _ = data
 
-        # Real recipient
-        if amount:
-            if isinstance(dest, str):
-                dest = Address.from_string(dest)
-            if "P2PKH" in dest.version:
-                script = (
-                    OP_DUP
-                    + OP_HASH160
-                    + OP_PUSH_20
-                    + bytes(dest.payload)
-                    + OP_EQUALVERIFY
-                    + OP_CHECKSIG
-                )
-            elif "P2SH" in dest.version:
-                script = OP_HASH160 + OP_PUSH_20 + bytes(dest.payload) + OP_EQUAL
-            else:
-                raise ValueError(
-                    "Bitcash currently only supports" " P2PKH/P2SH outputs"
-                )
-
-            output_block += amount.to_bytes(8, byteorder="little")
-
-        # Blockchain storage
-        else:
-            if custom_pushdata is False:
-                script = OP_RETURN + get_op_pushdata_code(dest) + dest
-
-                output_block += b"\x00\x00\x00\x00\x00\x00\x00\x00"
+        output_block += amount.to_bytes(8, byteorder="little")
 
-            elif custom_pushdata is True:
-                # manual control over number of bytes in each batch of pushdata
-                if type(dest) != bytes:
-                    raise TypeError("custom pushdata must be of type: bytes")
-                else:
-                    script = OP_RETURN + dest
-
-                output_block += b"\x00\x00\x00\x00\x00\x00\x00\x00"
-
-        # Script length in wiki is "Var_int" but there's a note of "modern BitcoinQT" using a more compact "CVarInt"
-        # CVarInt is what I believe we have here - No changes made. If incorrect - only breaks if 220 byte limit is increased.
+        # Script length in wiki is "Var_int" but there's a note of
+        # "modern BitcoinQT" using a more compact "CVarInt"
+        # CVarInt is what I believe we have here - No changes made.
+        # If incorrect - only breaks if 220 byte limit is increased.
         output_block += int_to_unknown_bytes(len(script), byteorder="little")
         output_block += script
 
     return output_block
 
 
 def construct_input_block(inputs):
@@ -329,55 +269,60 @@
         input_block += (
             txin.txid + txin.txindex + txin.script_len + txin.script + sequence
         )
 
     return input_block
 
 
-def create_p2pkh_transaction(private_key, unspents, outputs, custom_pushdata=False):
+def create_p2pkh_transaction(private_key, unspents, outputs):
     public_key = private_key.public_key
     public_key_len = len(public_key).to_bytes(1, byteorder="little")
 
-    scriptCode = private_key.scriptcode
-    scriptCode_len = int_to_varint(len(scriptCode))
-
     version = VERSION_1
     lock_time = LOCK_TIME
     # sequence = SEQUENCE
     hash_type = HASH_TYPE
     input_count = int_to_unknown_bytes(len(unspents), byteorder="little")
     output_count = int_to_unknown_bytes(len(outputs), byteorder="little")
 
-    output_block = construct_output_block(outputs, custom_pushdata=custom_pushdata)
+    output_block = construct_output_block(outputs)
 
     # Optimize for speed, not memory, by pre-computing values.
     inputs = []
     for unspent in unspents:
         script = hex_to_bytes(unspent.script)
-        script_len = int_to_unknown_bytes(len(script), byteorder="little")
+        script_len = int_to_varint(len(script))
+        # get cashtoken prefix
+        token_prefix = generate_cashtoken_prefix(
+            unspent.category_id,
+            unspent.nft_capability,
+            unspent.nft_commitment,
+            unspent.token_amount,
+        )
         txid = hex_to_bytes(unspent.txid)[::-1]
         txindex = unspent.txindex.to_bytes(4, byteorder="little")
         amount = unspent.amount.to_bytes(8, byteorder="little")
 
-        inputs.append(TxIn(script, script_len, txid, txindex, amount))
+        inputs.append(TxIn(script, script_len, txid, txindex, amount, token_prefix))
 
     hashPrevouts = double_sha256(b"".join([i.txid + i.txindex for i in inputs]))
     hashSequence = double_sha256(b"".join([SEQUENCE for i in inputs]))
     hashOutputs = double_sha256(output_block)
 
     # scriptCode_len is part of the script.
     for i, txin in enumerate(inputs):
         to_be_hashed = (
             version
             + hashPrevouts
             + hashSequence
             + txin.txid
             + txin.txindex
-            + scriptCode_len
-            + scriptCode
+            + txin.token_prefix
+            + txin.script_len
+            + txin.script
             + txin.amount
             + SEQUENCE
             + hashOutputs
             + lock_time
             + hash_type
         )
         hashed = sha256(to_be_hashed)  # BIP-143: Used for Bitcoin Cash
```

## bitcash/utils.py

```diff
@@ -46,7 +46,25 @@
         return val.to_bytes(1, "little")
     elif val <= 65535:
         return b"\xfd" + val.to_bytes(2, "little")
     elif val <= 4294967295:
         return b"\xfe" + val.to_bytes(4, "little")
     else:
         return b"\xff" + val.to_bytes(8, "little")
+
+
+def varint_to_int(val):
+    """
+    Converts varint to int from incoming bytestream.
+
+    :param val: the bytecode starting with varint
+    :type val: ``io.BytesIO``
+    :returns: ``int``
+    """
+    start_byte = val.read(1)
+    if start_byte == b"\xff":
+        return int.from_bytes(val.read(8), "little")
+    if start_byte == b"\xfe":
+        return int.from_bytes(val.read(4), "little")
+    if start_byte == b"\xfd":
+        return int.from_bytes(val.read(2), "little")
+    return int.from_bytes(start_byte, "little")
```

## bitcash/wallet.py

```diff
@@ -1,31 +1,25 @@
 import json
 
 from bitcash.crypto import ECPrivateKey
+from bitcash.cashtoken import Unspents
 from bitcash.curve import Point
 from bitcash.exceptions import InvalidNetwork
 from bitcash.format import (
     bytes_to_wif,
     public_key_to_address,
     public_key_to_coords,
     wif_to_bytes,
     address_to_public_key_hash,
+    address_to_cashtokenaddress,
 )
 from bitcash.network import NetworkAPI, satoshi_to_currency_cached
 from bitcash.network.meta import Unspent
-from bitcash.transaction import (
-    calc_txid,
-    create_p2pkh_transaction,
-    sanitize_tx_data,
-    OP_CHECKSIG,
-    OP_DUP,
-    OP_EQUALVERIFY,
-    OP_HASH160,
-    OP_PUSH_20,
-)
+from bitcash.op import OpCodes
+from bitcash.transaction import calc_txid, create_p2pkh_transaction, sanitize_tx_data
 
 
 NETWORKS = {"main": "mainnet", "test": "testnet", "regtest": "regtest"}
 DEFAULT_FEE = 1
 
 
 def wif_to_key(wif, regtest=False):
@@ -161,36 +155,42 @@
         self._address = None
         self._scriptcode = None
         if network in NETWORKS.keys():
             self._network = network
         else:
             raise InvalidNetwork
         self.balance = 0
+        self.cashtoken_balance = {}
         self.unspents = []
         self.transactions = []
 
     @property
     def address(self):
         """The public address you share with others to receive funds."""
         if self._address is None:
             self._address = public_key_to_address(
                 self._public_key, version=self._network
             )
 
         return self._address
 
     @property
+    def cashtoken_address(self):
+        """The public address you share with others to receive cashtokens."""
+        return address_to_cashtokenaddress(self.address)
+
+    @property
     def scriptcode(self):
         self._scriptcode = (
-            OP_DUP
-            + OP_HASH160
-            + OP_PUSH_20
+            OpCodes.OP_DUP.binary
+            + OpCodes.OP_HASH160.binary
+            + OpCodes.OP_DATA_20.binary
             + address_to_public_key_hash(self.address)
-            + OP_EQUALVERIFY
-            + OP_CHECKSIG
+            + OpCodes.OP_EQUALVERIFY.binary
+            + OpCodes.OP_CHECKSIG.binary
         )
         return self._scriptcode
 
     def to_wif(self):
         return bytes_to_wif(
             self._pk.secret, version=self._network, compressed=self.is_compressed()
         )
@@ -209,29 +209,38 @@
         :func:`~bitcash.PrivateKey.get_balance` and returns it using
         :func:`~bitcash.PrivateKey.balance_as`.
 
         :param currency: One of the :ref:`supported currencies`.
         :type currency: ``str``
         :rtype: ``str``
         """
-        self.unspents[:] = NetworkAPI.get_unspent(
-            self.address, network=NETWORKS[self._network]
-        )
-        self.balance = sum(unspent.amount for unspent in self.unspents)
+        _ = self.get_unspents()
         return self.balance_as(currency)
 
+    def get_cashtokenbalance(self):
+        """Fetches the current cashtoken balance by calling
+        :func:`~bitcash.PrivateKey.get_balance` and returns it as
+        a token dictionary.
+
+        :rtype: ``dict``
+        """
+        _ = self.get_unspents()
+        return self.cashtoken_balance
+
     def get_unspents(self):
         """Fetches all available unspent transaction outputs.
 
         :rtype: ``list`` of :class:`~bitcash.network.meta.Unspent`
         """
         self.unspents[:] = NetworkAPI.get_unspent(
             self.address, network=NETWORKS[self._network]
         )
-        self.balance = sum(unspent.amount for unspent in self.unspents)
+        _ = Unspents(self.unspents)
+        self.balance = _.amount
+        self.cashtoken_balance = _.tokendata
         return self.unspents
 
     def get_transactions(self):
         """Fetches transaction history.
 
         :rtype: ``list`` of ``str`` transaction IDs
         """
@@ -253,14 +262,25 @@
         """Creates a signed P2PKH transaction.
 
         :param outputs: A sequence of outputs you wish to send in the form
                         ``(destination, amount, currency)``. The amount can
                         be either an int, float, or string as long as it is
                         a valid input to ``decimal.Decimal``. The currency
                         must be :ref:`supported <supported currencies>`.
+                        To send CashToken, the list of output is made in the
+                        form ``(destination, amount, currency, category_id,
+                        nft_capability, nft_commitment, token_amount)``. The category_id
+                        is hex of tx-id as ``str``. The nft_capability is the capability
+                        of non-fungible token in ("none", "mutable", "minting"). The
+                        nft_commitment is the commitment of the non-fungible token in
+                        ``bytes``.
+                        The CashToken property nft_capability, nft_commitment, or
+                        the token_amount can be None if not to be sent. If
+                        category_id is tx-id of unspent with tx-index 0, then
+                        tx is treated as a genesis tx.
         :type outputs: ``list`` of ``tuple``
         :param fee: The number of satoshi per byte to pay to miners. By default
                     Bitcash will poll `<https://bitcoincashfees.earn.com>`_ and use a fee
                     that will allow your transaction to be confirmed as soon as
                     possible.
         :type fee: ``int``
         :param leftover: The destination that will receive any change from the
@@ -279,27 +299,25 @@
                          communicate with the blockchain itself.
         :type unspents: ``list`` of :class:`~bitcash.network.meta.Unspent`
         :returns: The signed transaction as hex.
         :rtype: ``str``
         """
 
         unspents, outputs = sanitize_tx_data(
-            unspents or self.unspents,
+            unspents or self.get_unspents(),
             outputs,
             fee or DEFAULT_FEE,
             leftover or self.address,
             combine=combine,
             message=message,
             compressed=self.is_compressed(),
             custom_pushdata=custom_pushdata,
         )
 
-        return create_p2pkh_transaction(
-            self, unspents, outputs, custom_pushdata=custom_pushdata
-        )
+        return create_p2pkh_transaction(self, unspents, outputs)
 
     def send(
         self,
         outputs,
         fee=None,
         leftover=None,
         combine=True,
@@ -311,14 +329,25 @@
         :func:`~bitcash.PrivateKey.create_transaction`.
 
         :param outputs: A sequence of outputs you wish to send in the form
                         ``(destination, amount, currency)``. The amount can
                         be either an int, float, or string as long as it is
                         a valid input to ``decimal.Decimal``. The currency
                         must be :ref:`supported <supported currencies>`.
+                        To send CashToken, the list of output is made in the
+                        form ``(destination, amount, currency, category_id,
+                        nft_capability, nft_commitment, token_amount)``. The category_id
+                        is hex of tx-id as ``str``. The nft_capability is the capability
+                        of non-fungible token in ("none", "mutable", "minting"). The
+                        nft_commitment is the commitment of the non-fungible token in
+                        ``bytes``.
+                        The CashToken property nft_capability, nft_commitment, or
+                        the token_amount can be None if not to be sent. If
+                        category_id is tx-id of unspent with tx-index 0, then
+                        tx is treated as a genesis tx.
         :type outputs: ``list`` of ``tuple``
         :param fee: The number of satoshi per byte to pay to miners. By default
                     Bitcash will poll `<https://bitcoincashfees.earn.com>`_ and use a fee
                     that will allow your transaction to be confirmed as soon as
                     possible.
         :type fee: ``int``
         :param leftover: The destination that will receive any change from the
@@ -370,14 +399,25 @@
         :param address: The address the funds will be sent from.
         :type address: ``str``
         :param outputs: A sequence of outputs you wish to send in the form
                         ``(destination, amount, currency)``. The amount can
                         be either an int, float, or string as long as it is
                         a valid input to ``decimal.Decimal``. The currency
                         must be :ref:`supported <supported currencies>`.
+                        To send CashToken, the list of output is made in the
+                        form ``(destination, amount, currency, category_id,
+                        nft_capability, nft_commitment, token_amount)``. The category_id
+                        is hex of tx-id as ``str``. The nft_capability is the capability
+                        of non-fungible token in ("none", "mutable", "minting"). The
+                        nft_commitment is the commitment of the non-fungible token in
+                        ``bytes``.
+                        The CashToken property nft_capability, nft_commitment, or
+                        the token_amount can be None if not to be sent. If
+                        category_id is tx-id of unspent with tx-index 0, then
+                        tx is treated as a genesis tx.
         :type outputs: ``list`` of ``tuple``
         :param compressed: Whether or not the ``address`` corresponds to a
                            compressed public key. This influences the fee.
         :type compressed: ``bool``
         :param fee: The number of satoshi per byte to pay to miners. By default
                     Bitcash will poll `<https://bitcoincashfees.earn.com>`_ and use a fee
                     that will allow your transaction to be confirmed as soon as
@@ -407,14 +447,22 @@
             fee or DEFAULT_FEE,
             leftover or address,
             combine=combine,
             message=message,
             compressed=compressed,
         )
 
+        outputs = list(map(list, outputs))
+        for output in outputs:
+            # script
+            output[0] = output[0].hex()
+            # nft_commitment
+            if output[4] is not None:
+                output[4] = output[4].hex()
+
         data = {
             "unspents": [unspent.to_dict() for unspent in unspents],
             "outputs": outputs,
         }
 
         return json.dumps(data, separators=(",", ":"))
 
@@ -427,14 +475,21 @@
         :returns: The signed transaction as hex.
         :rtype: ``str``
         """
         data = json.loads(tx_data)
 
         unspents = [Unspent.from_dict(unspent) for unspent in data["unspents"]]
         outputs = data["outputs"]
+        for output in outputs:
+            # script
+            output[0] = bytes.fromhex(output[0])
+            # nft_commitment
+            if output[4] is not None:
+                output[4] = bytes.fromhex(output[4])
+        outputs = list(map(tuple, outputs))
 
         return create_p2pkh_transaction(self, unspents, outputs)
 
     @classmethod
     def from_hex(cls, hexed):
         """
         :param hexed: A private key previously encoded as hex.
```

## bitcash/network/meta.py

```diff
@@ -1,40 +1,129 @@
 TX_TRUST_LOW = 1
 TX_TRUST_MEDIUM = 6
 TX_TRUST_HIGH = 30
 
 
 class Unspent:
-    """Represents an unspent transaction output (UTXO)."""
+    """
+    Represents an unspent transaction output (UTXO) with CashToken
 
-    __slots__ = ("amount", "confirmations", "script", "txid", "txindex")
-
-    def __init__(self, amount, confirmations, script, txid, txindex):
+    :param amount: Amount in satoshi
+    :type amount: ``int``
+    :param confirmations: Number of confirmations of the UTXO
+    :type confirmations: ``int``
+    :param script: locking bytecode hex of the UTXO, with no cashtoken prefix
+    :type script: ``str``
+    :param txid: txid hex of the transaction of UTXO
+    :type txid: ``str``
+    :param txindex: transaction output index of UTXO
+    :type txindex: ``int``
+    :param category_id: category_id of cashtoken attached to the UTXO
+    :type category_id: ``str``
+    :param nft_capability: nft_capability of the cashtoken attached
+    :type nft_capability: ``str``
+    :param nft_commitment: nft_commitment of the cashtoken attached
+    :type nft_commitment: ``bytes``
+    :param token_amount: fungible token amount of the cashtoken attached
+    :type token_amount: ``int``
+    """
+
+    __slots__ = (
+        "amount",
+        "confirmations",
+        "script",
+        "txid",
+        "txindex",
+        "category_id",
+        "nft_capability",
+        "nft_commitment",
+        "token_amount",
+    )
+
+    NFT_CAPABILITY = ["none", "mutable", "minting"]
+
+    def __init__(
+        self,
+        amount,
+        confirmations,
+        script,
+        txid,
+        txindex,
+        category_id=None,
+        nft_capability=None,
+        nft_commitment=None,
+        token_amount=None,
+    ):
         self.amount = amount
         self.confirmations = confirmations
         self.script = script
         self.txid = txid
         self.txindex = txindex
+        self.category_id = category_id
+        self.nft_capability = nft_capability
+        self.nft_commitment = nft_commitment
+        self.token_amount = token_amount
 
     def to_dict(self):
-        return {attr: getattr(self, attr) for attr in Unspent.__slots__}
+        dict_ = {attr: getattr(self, attr) for attr in Unspent.__slots__}
+        # save nft_commitment as hex
+        if dict_["nft_commitment"] is not None:
+            dict_["nft_commitment"] = dict_["nft_commitment"].hex()
+        return dict_
 
     @classmethod
     def from_dict(cls, d):
+        # convert nft_commitment to bytes
+        if d["nft_commitment"] is not None:
+            d["nft_commitment"] = bytes.fromhex(d["nft_commitment"])
         return Unspent(**{attr: d[attr] for attr in Unspent.__slots__})
 
+    @property
+    def has_nft(self):
+        return self.nft_capability is not None
+
+    @property
+    def has_amount(self):
+        return self.token_amount is not None
+
+    @property
+    def has_cashtoken(self):
+        return self.has_amount or self.has_nft
+
     def __eq__(self, other):
-        return (
-            self.amount == other.amount
-            and self.script == other.script
-            and self.txid == other.txid
-            and self.txindex == other.txindex
-        )
+        return self.to_dict() == other.to_dict()
+
+    def __gt__(self, other):
+        """
+        Method to help sorting of Unspents during spending
+        """
+        if self.has_nft:
+            if not other.has_nft:
+                return True
+            if Unspent.NFT_CAPABILITY.index(
+                self.nft_capability
+            ) > Unspent.NFT_CAPABILITY.index(other.nft_capability):
+                return True
+            if Unspent.NFT_CAPABILITY.index(
+                self.nft_capability
+            ) < Unspent.NFT_CAPABILITY.index(other.nft_capability):
+                return False
+        elif other.has_nft:
+            return False
+        if self.has_amount:
+            if not other.has_amount:
+                return True
+            if self.token_amount > other.token_amount:
+                return True
+            if self.token_amount < other.token_amount:
+                return False
+        elif other.has_amount:
+            return False
+        return self.amount > other.amount
 
     def __repr__(self):
-        return (
-            f"Unspent(amount={repr(self.amount)}, "
-            f"confirmations={repr(self.confirmations)}, "
-            f"script={repr(self.script)}, "
-            f"txid={repr(self.txid)}, "
-            f"txindex={repr(self.txindex)})"
-        )
+        var_list = [
+            f"{key}={repr(value)}"
+            for key, value in self.to_dict().items()
+            if value is not None
+        ]
+        return "Unspent({})".format(", ".join(var_list))
```

## bitcash/network/services.py

```diff
@@ -1,15 +1,19 @@
 import os
 import requests
 
 # Import supported endpoint APIs
 from bitcash.network.APIs.BitcoinDotComAPI import BitcoinDotComAPI
+from bitcash.network.APIs.ChaingraphAPI import ChaingraphAPI
 
 # Dictionary of supported endpoint APIs
-ENDPOINT_ENV_VARIABLES = {"BITCOINCOM": BitcoinDotComAPI}
+ENDPOINT_ENV_VARIABLES = {
+    "CHAINGRAPH": ChaingraphAPI,
+    "BITCOINCOM": BitcoinDotComAPI,
+}
 
 # Default API call total time timeout
 DEFAULT_TIMEOUT = 5
 
 BCH_TO_SAT_MULTIPLIER = 100000000
 
 NETWORKS = {"mainnet", "testnet", "regtest"}
@@ -30,36 +34,78 @@
     # Where 'N' is a number starting at 1 and increasing to
     # however many endpoints you'd like.
     # If neither of these env variables have been set, it returns
     # the instantiated result of <NAME>.get_default_endpoints(network)
 
     endpoints = []
     for endpoint in ENDPOINT_ENV_VARIABLES.keys():
-        if os.getenv(f"{endpoint}_API_{network}".upper()):
-            endpoints.append(
-                ENDPOINT_ENV_VARIABLES[endpoint](
-                    os.getenv(f"{endpoint}_API_{network}".upper())
+        if endpoint == "CHAINGRAPH":
+            if os.getenv(f"{endpoint}_API".upper()):
+                endpoints.append(
+                    ENDPOINT_ENV_VARIABLES[endpoint](
+                        os.getenv(f"{endpoint}_API".upper()),
+                        os.getenv(f"{endpoint}_API_{network}".upper()),
+                    )
                 )
-            )
-        elif os.getenv(f"{endpoint}_API_{network}_1".upper()):
-            counter = 1
-            finished = False
-            while not finished:
-                next_endpoint = os.getenv(f"{endpoint}_API_{network}_{counter}".upper())
-                if next_endpoint:
-                    endpoints.append(ENDPOINT_ENV_VARIABLES[endpoint](next_endpoint))
-                    counter += 1
-                else:
-                    finished = True
+            elif os.getenv(f"{endpoint}_API_1".upper()):
+                counter = 1
+                finished = False
+                while not finished:
+                    next_endpoint = os.getenv(f"{endpoint}_API_{counter}".upper())
+                    next_pattern = os.getenv(
+                        f"{endpoint}_API_{network}_{counter}".upper()
+                    )
+                    if next_endpoint:
+                        endpoints.append(
+                            ENDPOINT_ENV_VARIABLES[endpoint](
+                                next_endpoint, next_pattern
+                            )
+                        )
+                        counter += 1
+                    else:
+                        finished = True
+            else:
+                defaults_endpoints = ENDPOINT_ENV_VARIABLES[
+                    endpoint
+                ].get_default_endpoints(network)
+                for each in defaults_endpoints:
+                    if hasattr(each, "__iter__") and not isinstance(each, str):
+                        endpoints.append(ENDPOINT_ENV_VARIABLES[endpoint](*each))
+                    else:
+                        endpoints.append(ENDPOINT_ENV_VARIABLES[endpoint](each))
         else:
-            defaults_endpoints = ENDPOINT_ENV_VARIABLES[endpoint].get_default_endpoints(
-                network
-            )
-            for each in defaults_endpoints:
-                endpoints.append(ENDPOINT_ENV_VARIABLES[endpoint](each))
+            if os.getenv(f"{endpoint}_API_{network}".upper()):
+                endpoints.append(
+                    ENDPOINT_ENV_VARIABLES[endpoint](
+                        os.getenv(f"{endpoint}_API_{network}".upper())
+                    )
+                )
+            elif os.getenv(f"{endpoint}_API_{network}_1".upper()):
+                counter = 1
+                finished = False
+                while not finished:
+                    next_endpoint = os.getenv(
+                        f"{endpoint}_API_{network}_{counter}".upper()
+                    )
+                    if next_endpoint:
+                        endpoints.append(
+                            ENDPOINT_ENV_VARIABLES[endpoint](next_endpoint)
+                        )
+                        counter += 1
+                    else:
+                        finished = True
+            else:
+                defaults_endpoints = ENDPOINT_ENV_VARIABLES[
+                    endpoint
+                ].get_default_endpoints(network)
+                for each in defaults_endpoints:
+                    if hasattr(each, "__iter__") and not isinstance(each, str):
+                        endpoints.append(ENDPOINT_ENV_VARIABLES[endpoint](*each))
+                    else:
+                        endpoints.append(ENDPOINT_ENV_VARIABLES[endpoint](each))
 
     return endpoints
 
 
 class NetworkAPI:
     IGNORED_ERRORS = (
         requests.exceptions.RequestException,
@@ -81,15 +127,14 @@
         """Gets the balance of an address in satoshi.
 
         :param address: The address in question.
         :type address: ``str``
         :raises ConnectionError: If all API services fail.
         :rtype: ``int``
         """
-
         for endpoint in get_endpoints_for(network):
             try:
                 return endpoint.get_balance(address, timeout=DEFAULT_TIMEOUT)
             except cls.IGNORED_ERRORS:  # pragma: no cover
                 pass
 
         raise ConnectionError("All APIs are unreachable.")  # pragma: no cover
@@ -99,15 +144,14 @@
         """Gets the ID of all transactions related to an address.
 
         :param address: The address in question.
         :type address: ``str``
         :raises ConnectionError: If all API services fail.
         :rtype: ``list`` of ``str``
         """
-
         for endpoint in get_endpoints_for(network):
             try:
                 return endpoint.get_transactions(address, timeout=DEFAULT_TIMEOUT)
             except cls.IGNORED_ERRORS:  # pragma: no cover
                 pass
 
         raise ConnectionError("All APIs are unreachable.")  # pragma: no cover
@@ -193,14 +237,19 @@
         :param tx_hex: A signed transaction in hex form.
         :type tx_hex: ``str``
         :raises ConnectionError: If all API services fail.
         """
         success = None
 
         for endpoint in get_endpoints_for(network):
+            _ = [end[0] for end in ChaingraphAPI.get_default_endpoints(network)]
+            if endpoint in _ and network == "mainnet":
+                # Default chaingraph endpoints do not indicate failed broadcast
+                # no other testnet api
+                continue
             try:
                 success = endpoint.broadcast_tx(tx_hex, timeout=DEFAULT_TIMEOUT)
                 if not success:
                     continue
                 return
             except cls.IGNORED_ERRORS:
                 pass
```

## bitcash/network/transaction.py

```diff
@@ -1,7 +1,10 @@
+from bitcash.format import hex_to_asm
+
+
 class Transaction:
     """
     Representation of a transaction returned from the network.
     """
 
     def __init__(self, txid, block, amount_in, amount_out, amount_fee):
         self.txid = txid
@@ -13,14 +16,28 @@
         self.amount_in = amount_in
         self.amount_out = amount_out
         self.amount_fee = amount_fee
 
         self.inputs = []
         self.outputs = []
 
+    def to_dict(self):
+        return {
+            "txid": self.txid,
+            "block": self.block,
+            "amount_in": self.amount_in,
+            "amount_out": self.amount_out,
+            "amount_fee": self.amount_fee,
+            "inputs": [input_.to_dict() for input_ in self.inputs],
+            "outputs": [output.to_dict() for output in self.outputs],
+        }
+
+    def __eq__(self, other):
+        return self.to_dict() == other.to_dict()
+
     def add_input(self, part):
         self.inputs.append(part)
 
     def add_output(self, part):
         self.outputs.append(part)
 
     def __repr__(self):
@@ -38,25 +55,53 @@
 
 
 class TxPart:
     """
     Representation of a single input or output.
     """
 
-    def __init__(self, address, amount, asm=None):
+    def __init__(
+        self,
+        address,
+        amount,
+        category_id=None,
+        nft_capability=None,
+        nft_commitment=None,
+        token_amount=None,
+        asm=None,
+        data_hex=None,
+    ):
         self.address = address
         self.amount = amount
+        self.category_id = category_id
+        self.nft_capability = nft_capability
+        self.nft_commitment = nft_commitment
+        self.token_amount = token_amount
         self.op_return = None
 
+        if data_hex is not None:
+            asm = hex_to_asm(data_hex)
+
         if address is None and asm is not None:
             if asm.startswith("OP_RETURN "):
                 self.op_return = asm[10:]
             elif asm.startswith("return ["):
                 self.op_return = asm[8:-1]
 
+    def to_dict(self):
+        return {
+            "address": self.address,
+            "amount": self.amount,
+            "category_id": self.category_id,
+            "nft_capability": self.nft_capability,
+            "nft_commitment": self.nft_commitment,
+            "token_amount": self.token_amount,
+            "op_return": self.op_return,
+        }
+
     def message(self):
         """Attempt to decode the op_return value (if there is one) as a UTF-8 string."""
 
         if self.op_return is None:
             return None
 
         return bytearray.fromhex(self.op_return).decode("utf-8")
```

## bitcash/network/APIs/BitcoinDotComAPI.py

```diff
@@ -1,32 +1,35 @@
 from bitcash.network.http import session
 from decimal import Decimal
 from bitcash.exceptions import InvalidEndpointURLProvided
 from bitcash.network import currency_to_satoshi
+from bitcash.network.APIs import BaseAPI
 from bitcash.network.meta import Unspent
 from bitcash.network.transaction import Transaction, TxPart
+from bitcash.format import cashtokenaddress_to_address
 
 # This class is the interface for Bitcash to interact with
 # Bitcoin.com based RESTful interfaces.
 
 BCH_TO_SAT_MULTIPLIER = 100000000
 # TODO: Refactor constant above into a 'constants.py' file
 
 
-class BitcoinDotComAPI:
+class BitcoinDotComAPI(BaseAPI):
     """rest.bitcoin.com API"""
 
     def __init__(self, network_endpoint: str):
         try:
             assert isinstance(network_endpoint, str)
             assert network_endpoint[:4] == "http"
             assert network_endpoint[-4:] == "/v2/"
         except AssertionError:
             raise InvalidEndpointURLProvided(
-                f"Provided endpoint '{network_endpoint}' is not a valid URL for a Bitcoin.com-based REST endpoint"
+                f"Provided endpoint '{network_endpoint}' is not a valid URL for a "
+                f"Bitcoin.com-based REST endpoint"
             )
 
         self.network_endpoint = network_endpoint
 
     # Default endpoints to use for this interface
     DEFAULT_ENDPOINTS = {
         "mainnet": [
@@ -49,84 +52,180 @@
     def get_default_endpoints(cls, network):
         return cls.DEFAULT_ENDPOINTS[network]
 
     def make_endpoint_url(self, path):
         return self.network_endpoint + self.PATHS[path]
 
     def get_balance(self, address, *args, **kwargs):
+        address = cashtokenaddress_to_address(address)
         api_url = self.make_endpoint_url("address").format(address)
         r = session.get(api_url, *args, **kwargs)
         r.raise_for_status()
         data = r.json()
         return data["balanceSat"] + data["unconfirmedBalanceSat"]
 
     def get_transactions(self, address, *args, **kwargs):
+        address = cashtokenaddress_to_address(address)
         api_url = self.make_endpoint_url("address").format(address)
         r = session.get(api_url, *args, **kwargs)
         r.raise_for_status()
         return r.json()["transactions"]
 
     def get_transaction(self, txid, *args, **kwargs):
         api_url = self.make_endpoint_url("tx-details").format(txid)
         r = session.get(api_url, *args, **kwargs)
         r.raise_for_status()
         response = r.json(parse_float=Decimal)
 
         tx = Transaction(
             response["txid"],
-            response["blockheight"],
-            (Decimal(response["valueIn"]) * BCH_TO_SAT_MULTIPLIER).normalize(),
-            (Decimal(response["valueOut"]) * BCH_TO_SAT_MULTIPLIER).normalize(),
-            (Decimal(response["fees"]) * BCH_TO_SAT_MULTIPLIER).normalize(),
+            response.get("blockheight", None),
+            int(
+                (
+                    Decimal(response["valueIn"]) * BCH_TO_SAT_MULTIPLIER
+                ).to_integral_value()
+            ),
+            int(
+                (
+                    Decimal(response["valueOut"]) * BCH_TO_SAT_MULTIPLIER
+                ).to_integral_value()
+            ),
+            int(
+                (Decimal(response["fees"]) * BCH_TO_SAT_MULTIPLIER).to_integral_value()
+            ),
         )
 
         for txin in response["vin"]:
-            part = TxPart(txin["cashAddress"], txin["value"], txin["scriptSig"]["asm"])
+            part = TxPart(
+                txin["cashAddress"],
+                int(
+                    (Decimal(txin["value"]) * BCH_TO_SAT_MULTIPLIER).to_integral_value()
+                ),
+                asm=txin["scriptSig"]["asm"],
+            )
             tx.add_input(part)
 
         for txout in response["vout"]:
             addr = None
             if (
                 "cashAddrs" in txout["scriptPubKey"]
                 and txout["scriptPubKey"]["cashAddrs"] is not None
             ):
                 addr = txout["scriptPubKey"]["cashAddrs"][0]
 
+            category_id = None
+            nft_capability = None
+            nft_commitment = None
+            token_amount = None
+            if "tokenData" in txout:
+                token_data = txout["tokenData"]
+                category_id = token_data["category"]
+                token_amount = int(token_data["amount"]) or None
+                if "nft" in token_data:
+                    nft_capability = token_data["nft"]["capability"]
+                    nft_commitment = token_data["nft"]["commitment"] or None
             part = TxPart(
                 addr,
-                (Decimal(txout["value"]) * BCH_TO_SAT_MULTIPLIER).normalize(),
-                txout["scriptPubKey"]["asm"],
+                int(
+                    (
+                        Decimal(txout["value"]) * BCH_TO_SAT_MULTIPLIER
+                    ).to_integral_value()
+                ),
+                category_id,
+                nft_capability,
+                nft_commitment,
+                token_amount,
+                asm=txout["scriptPubKey"]["asm"],
             )
             tx.add_output(part)
 
         return tx
 
     def get_tx_amount(self, txid, txindex, *args, **kwargs):
         api_url = self.make_endpoint_url("tx-details").format(txid)
         r = session.get(api_url, *args, **kwargs)
         r.raise_for_status()
         response = r.json(parse_float=Decimal)
-        return (
-            Decimal(response["vout"][txindex]["value"]) * BCH_TO_SAT_MULTIPLIER
-        ).normalize()
+        return int(
+            (
+                Decimal(response["vout"][txindex]["value"]) * BCH_TO_SAT_MULTIPLIER
+            ).to_integral_value()
+        )
 
     def get_unspent(self, address, *args, **kwargs):
+        return self._get_unspent_cashtoken(address, *args, **kwargs)
+        address = cashtokenaddress_to_address(address)
         api_url = self.make_endpoint_url("unspent").format(address)
         r = session.get(api_url, *args, **kwargs)
         r.raise_for_status()
-        return [
+        unspents = []
+        for tx in r.json()["utxos"]:
+            category_id = None
+            nft_capability = None
+            nft_commitment = None
+            token_amount = None
+            if "tokenData" in tx:
+                token_data = tx["tokenData"]
+                category_id = token_data["category"]
+                token_amount = int(token_data["amount"]) or None
+                if "nft" in token_data:
+                    nft_capability = token_data["nft"]["capability"]
+                    _ = token_data["nft"]["commitment"]
+                    nft_commitment = bytes.fromhex(_) or None
+            unspents.append(
+                Unspent(
+                    currency_to_satoshi(tx["amount"], "bch"),
+                    tx["confirmations"],
+                    r.json()["scriptPubKey"],
+                    tx["txid"],
+                    tx["vout"],
+                    category_id,
+                    nft_capability,
+                    nft_commitment,
+                    token_amount,
+                )
+            )
+        return unspents
+
+    def _get_unspent_cashtoken(self, address, *args, **kwargs):
+        """
+        Makeshift function to get cashtoken info in unspents by querying tx details.
+        Should be deprecated once BitcoinDotComAPI supports cashtokens in unspents
+        """
+        address = cashtokenaddress_to_address(address)
+        api_url = self.make_endpoint_url("unspent").format(address)
+        r = session.get(api_url, *args, **kwargs)
+        r.raise_for_status()
+        unspents = [
             Unspent(
                 currency_to_satoshi(tx["amount"], "bch"),
                 tx["confirmations"],
                 r.json()["scriptPubKey"],
                 tx["txid"],
                 tx["vout"],
             )
             for tx in r.json()["utxos"]
         ]
+        api_url = self.make_endpoint_url("tx-details").format("")
+        r = session.post(
+            api_url, {"txids": [unspent.txid for unspent in unspents]}, *args, **kwargs
+        )
+        r.raise_for_status()
+        response = r.json(parse_float=Decimal)
+        for i, unspent in enumerate(unspents):
+            txout = response[i]["vout"][unspent.txindex]
+            if "tokenData" in txout:
+                token_data = txout["tokenData"]
+                unspent.category_id = token_data["category"]
+                unspent.token_amount = int(token_data["amount"]) or None
+                if "nft" in token_data:
+                    unspent.nft_capability = token_data["nft"]["capability"]
+                    _ = bytes.fromhex(token_data["nft"]["commitment"])
+                    unspent.nft_commitment = _ or None
+        return unspents
 
     def get_raw_transaction(self, txid, *args, **kwargs):
         api_url = self.make_endpoint_url("tx-details").format(txid)
         r = session.get(api_url, *args, **kwargs)
         r.raise_for_status()
         return r.json(parse_float=Decimal)
```

## bitcash/network/APIs/__init__.py

```diff
@@ -0,0 +1,173 @@
+00000000: 6672 6f6d 2061 6263 2069 6d70 6f72 7420  from abc import 
+00000010: 4142 432c 2061 6273 7472 6163 746d 6574  ABC, abstractmet
+00000020: 686f 640a 0a0a 636c 6173 7320 4261 7365  hod...class Base
+00000030: 4150 4928 4142 4329 3a0a 2020 2020 2222  API(ABC):.    ""
+00000040: 220a 2020 2020 4162 7374 7261 6374 2063  ".    Abstract c
+00000050: 6c61 7373 2066 6f72 2041 5049 2063 6c61  lass for API cla
+00000060: 7373 6573 0a0a 2020 2020 3a70 6172 616d  sses..    :param
+00000070: 206e 6574 776f 726b 5f65 6e64 706f 696e   network_endpoin
+00000080: 743a 204e 6574 776f 726b 2065 6e64 706f  t: Network endpo
+00000090: 696e 7420 746f 2073 656e 6420 7265 7175  int to send requ
+000000a0: 6573 7473 0a20 2020 203a 7479 7065 206e  ests.    :type n
+000000b0: 6574 776f 726b 5f65 6e64 706f 696e 743a  etwork_endpoint:
+000000c0: 2060 6073 7472 6060 0a20 2020 2022 2222   ``str``.    """
+000000d0: 0a0a 2020 2020 6465 6620 5f5f 696e 6974  ..    def __init
+000000e0: 5f5f 2873 656c 662c 206e 6574 776f 726b  __(self, network
+000000f0: 5f65 6e64 706f 696e 743a 2073 7472 293a  _endpoint: str):
+00000100: 0a20 2020 2020 2020 2073 656c 662e 6e65  .        self.ne
+00000110: 7477 6f72 6b5f 656e 6470 6f69 6e74 203d  twork_endpoint =
+00000120: 206e 6574 776f 726b 5f65 6e64 706f 696e   network_endpoin
+00000130: 740a 0a20 2020 2040 6162 7374 7261 6374  t..    @abstract
+00000140: 6d65 7468 6f64 0a20 2020 2064 6566 2067  method.    def g
+00000150: 6574 5f64 6566 6175 6c74 5f65 6e64 706f  et_default_endpo
+00000160: 696e 7473 2873 656c 662c 206e 6574 776f  ints(self, netwo
+00000170: 726b 293a 0a20 2020 2020 2020 2022 2222  rk):.        """
+00000180: 0a20 2020 2020 2020 2052 6574 7572 6e20  .        Return 
+00000190: 6465 6661 756c 7420 656e 6470 6f69 6e74  default endpoint
+000001a0: 7320 666f 7220 6120 6e65 7477 6f72 6b0a  s for a network.
+000001b0: 0a20 2020 2020 2020 203a 7061 7261 6d20  .        :param 
+000001c0: 6e65 7477 6f72 6b3a 206e 6574 776f 726b  network: network
+000001d0: 2069 6e20 5b22 6d61 696e 6e65 7422 2c20   in ["mainnet", 
+000001e0: 2274 6573 746e 6574 222c 2022 7265 6774  "testnet", "regt
+000001f0: 6573 7422 5d0a 2020 2020 2020 2020 3a74  est"].        :t
+00000200: 7970 6520 6e65 7477 6f72 6b3a 2060 6073  ype network: ``s
+00000210: 7472 6060 0a20 2020 2020 2020 203a 7265  tr``.        :re
+00000220: 7475 726e 733a 204c 6973 7420 6f66 2065  turns: List of e
+00000230: 6e64 706f 696e 7473 0a20 2020 2020 2020  ndpoints.       
+00000240: 203a 7274 7970 653a 2060 606c 6973 7460   :rtype: ``list`
+00000250: 6020 6f66 2060 6073 7472 6060 0a20 2020  ` of ``str``.   
+00000260: 2020 2020 2022 2222 0a0a 2020 2020 4061       """..    @a
+00000270: 6273 7472 6163 746d 6574 686f 640a 2020  bstractmethod.  
+00000280: 2020 6465 6620 6765 745f 6261 6c61 6e63    def get_balanc
+00000290: 6528 7365 6c66 2c20 6164 6472 6573 732c  e(self, address,
+000002a0: 202a 6172 6773 2c20 2a2a 6b77 6172 6773   *args, **kwargs
+000002b0: 293a 0a20 2020 2020 2020 2022 2222 0a20  ):.        """. 
+000002c0: 2020 2020 2020 2052 6574 7572 6e73 2062         Returns b
+000002d0: 616c 616e 6365 206f 6620 616e 2061 6464  alance of an add
+000002e0: 7265 7373 0a0a 2020 2020 2020 2020 3a70  ress..        :p
+000002f0: 6172 616d 2061 6464 7265 7373 3a20 4361  aram address: Ca
+00000300: 7368 6164 6472 6573 7320 6f66 2074 6865  shaddress of the
+00000310: 206c 6f63 6b69 6e67 2073 6372 6970 740a   locking script.
+00000320: 2020 2020 2020 2020 3a74 7970 6520 6164          :type ad
+00000330: 6472 6573 733a 2060 6073 7472 6060 0a20  dress: ``str``. 
+00000340: 2020 2020 2020 203a 7265 7475 726e 733a         :returns:
+00000350: 2042 4348 2061 6d6f 756e 7420 696e 2073   BCH amount in s
+00000360: 6174 6f73 6869 730a 2020 2020 2020 2020  atoshis.        
+00000370: 3a72 7479 7065 3a20 6060 696e 7460 600a  :rtype: ``int``.
+00000380: 2020 2020 2020 2020 2222 220a 0a20 2020          """..   
+00000390: 2040 6162 7374 7261 6374 6d65 7468 6f64   @abstractmethod
+000003a0: 0a20 2020 2064 6566 2067 6574 5f74 7261  .    def get_tra
+000003b0: 6e73 6163 7469 6f6e 7328 7365 6c66 2c20  nsactions(self, 
+000003c0: 6164 6472 6573 732c 202a 6172 6773 2c20  address, *args, 
+000003d0: 2a2a 6b77 6172 6773 293a 0a20 2020 2020  **kwargs):.     
+000003e0: 2020 2022 2222 4765 7473 2074 6865 2049     """Gets the I
+000003f0: 4420 6f66 2061 6c6c 2074 7261 6e73 6163  D of all transac
+00000400: 7469 6f6e 7320 7265 6c61 7465 6420 746f  tions related to
+00000410: 2061 6e20 6164 6472 6573 732e 0a0a 2020   an address...  
+00000420: 2020 2020 2020 3a70 6172 616d 2061 6464        :param add
+00000430: 7265 7373 3a20 5468 6520 6164 6472 6573  ress: The addres
+00000440: 7320 696e 2071 7565 7374 696f 6e2e 0a20  s in question.. 
+00000450: 2020 2020 2020 203a 7479 7065 2061 6464         :type add
+00000460: 7265 7373 3a20 6060 7374 7260 600a 2020  ress: ``str``.  
+00000470: 2020 2020 2020 3a72 7479 7065 3a20 6060        :rtype: ``
+00000480: 6c69 7374 6060 206f 6620 6060 7374 7260  list`` of ``str`
+00000490: 600a 2020 2020 2020 2020 2222 220a 0a20  `.        """.. 
+000004a0: 2020 2040 6162 7374 7261 6374 6d65 7468     @abstractmeth
+000004b0: 6f64 0a20 2020 2064 6566 2067 6574 5f74  od.    def get_t
+000004c0: 785f 616d 6f75 6e74 2873 656c 662c 2074  x_amount(self, t
+000004d0: 7869 642c 2074 7869 6e64 6578 2c20 2a61  xid, txindex, *a
+000004e0: 7267 732c 202a 2a6b 7761 7267 7329 3a0a  rgs, **kwargs):.
+000004f0: 2020 2020 2020 2020 2222 2247 6574 7320          """Gets 
+00000500: 7468 6520 616d 6f75 6e74 206f 6620 6120  the amount of a 
+00000510: 6769 7665 6e20 7472 616e 7361 6374 696f  given transactio
+00000520: 6e20 6f75 7470 7574 2e0a 0a20 2020 2020  n output...     
+00000530: 2020 203a 7061 7261 6d20 7478 6964 3a20     :param txid: 
+00000540: 5468 6520 7472 616e 7361 6374 696f 6e20  The transaction 
+00000550: 6964 2069 6e20 7175 6573 7469 6f6e 2e0a  id in question..
+00000560: 2020 2020 2020 2020 3a74 7970 6520 7478          :type tx
+00000570: 6964 3a20 6060 7374 7260 600a 2020 2020  id: ``str``.    
+00000580: 2020 2020 3a70 6172 616d 2074 7869 6e64      :param txind
+00000590: 6578 3a20 5468 6520 7472 616e 7361 6374  ex: The transact
+000005a0: 696f 6e20 696e 6465 7820 696e 2071 7565  ion index in que
+000005b0: 7374 696f 6e2e 0a20 2020 2020 2020 203a  stion..        :
+000005c0: 7479 7065 2074 7869 6e64 6578 3a20 6060  type txindex: ``
+000005d0: 696e 7460 600a 2020 2020 2020 2020 3a72  int``.        :r
+000005e0: 7479 7065 3a20 6060 4465 6369 6d61 6c60  type: ``Decimal`
+000005f0: 600a 2020 2020 2020 2020 2222 220a 0a20  `.        """.. 
+00000600: 2020 2040 6162 7374 7261 6374 6d65 7468     @abstractmeth
+00000610: 6f64 0a20 2020 2064 6566 2067 6574 5f74  od.    def get_t
+00000620: 7261 6e73 6163 7469 6f6e 2873 656c 662c  ransaction(self,
+00000630: 2074 7869 642c 202a 6172 6773 2c20 2a2a   txid, *args, **
+00000640: 6b77 6172 6773 293a 0a20 2020 2020 2020  kwargs):.       
+00000650: 2022 2222 0a20 2020 2020 2020 2052 6574   """.        Ret
+00000660: 7572 6e73 2074 7261 6e73 6163 7469 6f6e  urns transaction
+00000670: 2064 6174 6120 6f66 2061 2074 7261 6e73   data of a trans
+00000680: 6163 7469 6f6e 0a0a 2020 2020 2020 2020  action..        
+00000690: 3a70 6172 616d 2074 7869 643a 2054 7261  :param txid: Tra
+000006a0: 6e73 6163 7469 6f6e 2069 6420 6865 780a  nsaction id hex.
+000006b0: 2020 2020 2020 2020 3a74 7970 6520 7478          :type tx
+000006c0: 6964 3a20 6060 7374 7260 600a 2020 2020  id: ``str``.    
+000006d0: 2020 2020 3a72 6574 7572 6e73 3a20 496e      :returns: In
+000006e0: 7374 616e 6365 206f 6620 636c 6173 7320  stance of class 
+000006f0: 5472 616e 7361 6374 696f 6e0a 2020 2020  Transaction.    
+00000700: 2020 2020 3a72 7479 7065 3a20 6060 5472      :rtype: ``Tr
+00000710: 616e 7361 6374 696f 6e60 600a 2020 2020  ansaction``.    
+00000720: 2020 2020 2222 220a 0a20 2020 2040 6162      """..    @ab
+00000730: 7374 7261 6374 6d65 7468 6f64 0a20 2020  stractmethod.   
+00000740: 2064 6566 2067 6574 5f75 6e73 7065 6e74   def get_unspent
+00000750: 2873 656c 662c 2061 6464 7265 7373 2c20  (self, address, 
+00000760: 2a61 7267 732c 202a 2a6b 7761 7267 7329  *args, **kwargs)
+00000770: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
+00000780: 2020 2020 2020 5265 7475 726e 7320 6c69        Returns li
+00000790: 7374 206f 6620 756e 7370 656e 7420 6f75  st of unspent ou
+000007a0: 7470 7574 7320 6173 736f 6369 6174 6564  tputs associated
+000007b0: 2077 6974 6820 616e 2061 6464 7265 7373   with an address
+000007c0: 0a0a 2020 2020 2020 2020 3a70 6172 616d  ..        :param
+000007d0: 2061 6464 7265 7373 3a20 4361 7368 6164   address: Cashad
+000007e0: 6472 6573 7320 6f66 2074 6865 206c 6f63  dress of the loc
+000007f0: 6b69 6e67 2073 6372 6970 740a 2020 2020  king script.    
+00000800: 2020 2020 3a74 7970 6520 6164 6472 6573      :type addres
+00000810: 733a 2060 6073 7472 6060 0a20 2020 2020  s: ``str``.     
+00000820: 2020 203a 7265 7475 726e 733a 204c 6973     :returns: Lis
+00000830: 7420 6f66 2075 6e73 7065 6e74 730a 2020  t of unspents.  
+00000840: 2020 2020 2020 3a72 7479 7065 3a20 6060        :rtype: ``
+00000850: 6c69 7374 6060 0a20 2020 2020 2020 2022  list``.        "
+00000860: 2222 0a0a 2020 2020 4061 6273 7472 6163  ""..    @abstrac
+00000870: 746d 6574 686f 640a 2020 2020 6465 6620  tmethod.    def 
+00000880: 6765 745f 7261 775f 7472 616e 7361 6374  get_raw_transact
+00000890: 696f 6e28 7365 6c66 2c20 7478 6964 2c20  ion(self, txid, 
+000008a0: 2a61 7267 732c 202a 2a6b 7761 7267 7329  *args, **kwargs)
+000008b0: 3a0a 2020 2020 2020 2020 2222 2247 6574  :.        """Get
+000008c0: 7320 7468 6520 7261 772c 2075 6e70 6172  s the raw, unpar
+000008d0: 7365 6420 7472 616e 7361 6374 696f 6e20  sed transaction 
+000008e0: 6465 7461 696c 732e 0a0a 2020 2020 2020  details...      
+000008f0: 2020 3a70 6172 616d 2074 7869 643a 2054    :param txid: T
+00000900: 6865 2074 7261 6e73 6163 7469 6f6e 2069  he transaction i
+00000910: 6420 696e 2071 7565 7374 696f 6e2e 0a20  d in question.. 
+00000920: 2020 2020 2020 203a 7479 7065 2074 7869         :type txi
+00000930: 643a 2060 6073 7472 6060 0a20 2020 2020  d: ``str``.     
+00000940: 2020 203a 7274 7970 653a 2060 6054 7261     :rtype: ``Tra
+00000950: 6e73 6163 7469 6f6e 6060 0a20 2020 2020  nsaction``.     
+00000960: 2020 2022 2222 0a0a 2020 2020 4061 6273     """..    @abs
+00000970: 7472 6163 746d 6574 686f 640a 2020 2020  tractmethod.    
+00000980: 6465 6620 6272 6f61 6463 6173 745f 7478  def broadcast_tx
+00000990: 2873 656c 662c 2074 785f 6865 782c 202a  (self, tx_hex, *
+000009a0: 6172 6773 2c20 2a2a 6b77 6172 6773 293a  args, **kwargs):
+000009b0: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+000009c0: 2020 2020 2042 726f 6164 6361 7374 2061       Broadcast a
+000009d0: 2072 6177 2074 7261 6e73 6163 7469 6f6e   raw transaction
+000009e0: 0a0a 2020 2020 2020 2020 3a70 6172 616d  ..        :param
+000009f0: 2074 785f 6865 783a 2054 6865 2068 6578   tx_hex: The hex
+00000a00: 2072 6570 7265 7365 6e74 6169 6f6e 206f   representaion o
+00000a10: 6620 7468 6520 7472 616e 7361 6374 696f  f the transactio
+00000a20: 6e20 746f 2062 650a 2020 2020 2020 2020  n to be.        
+00000a30: 2020 2020 2020 2020 2020 2020 2020 2062                 b
+00000a40: 726f 6164 6361 7374 6564 2e0a 2020 2020  roadcasted..    
+00000a50: 2020 2020 3a74 7970 6520 7478 5f68 6578      :type tx_hex
+00000a60: 3a20 6060 7374 7260 600a 2020 2020 2020  : ``str``.      
+00000a70: 2020 3a72 6574 7572 6e3a 2042 6f6f 6c65    :return: Boole
+00000a80: 616e 2069 6e64 6963 6174 696e 6720 6966  an indicating if
+00000a90: 2074 6865 2074 7820 6973 2062 726f 6164   the tx is broad
+00000aa0: 6361 7374 6564 0a20 2020 2020 2020 203a  casted.        :
+00000ab0: 7274 7970 653a 2060 6062 6f6f 6c60 600a  rtype: ``bool``.
+00000ac0: 2020 2020 2020 2020 2222 220a                    """.
```

## tests/samples.py

```diff
@@ -1,34 +1,45 @@
 BINARY_ADDRESS = b"\x00\x92F\x1b\xdeb\x83\xb4a\xec\xe7\xdd\xf4\xdb\xf1\xe0\xa4\x8b\xd1\x13\xd8&E\xb4\xbf"
 BITCOIN_ADDRESS = "1ELReFsTCUY2mfaDTy32qxYiT49z786eFg"
 BITCOIN_ADDRESS_COMPRESSED = "1ExJJsNLQDNVVM1s1sdyt1o5P3GC5r32UG"
-BITCOIN_ADDRESS_PAY2SH = "39SrGQEfFXcTYJhBvjZeQja66Cpz82EEUn"
+BITCOIN_ADDRESS_PAY2SH20 = "39SrGQEfFXcTYJhBvjZeQja66Cpz82EEUn"
 BITCOIN_ADDRESS_TEST = "mtrNwJxS1VyHYn3qBY1Qfsm3K3kh1mGRMS"
 BITCOIN_ADDRESS_TEST_COMPRESSED = "muUFbvTKDEokGTVUjScMhw1QF2rtv5hxCz"
-BITCOIN_ADDRESS_TEST_PAY2SH = "2NFKbBHzzh32q5DcZJNgZE9sF7gYmtPbawk"
+BITCOIN_ADDRESS_TEST_PAY2SH20 = "2NFKbBHzzh32q5DcZJNgZE9sF7gYmtPbawk"
 BITCOIN_ADDRESS_REGTEST = "mtrNwJxS1VyHYn3qBY1Qfsm3K3kh1mGRMS"
 BITCOIN_ADDRESS_REGTEST_COMPRESSED = "muUFbvTKDEokGTVUjScMhw1QF2rtv5hxCz"
-BITCOIN_ADDRESS_REGTEST_PAY2SH = "2NFKbBHzzh32q5DcZJNgZE9sF7gYmtPbawk"
+BITCOIN_ADDRESS_REGTEST_PAY2SH20 = "2NFKbBHzzh32q5DcZJNgZE9sF7gYmtPbawk"
 BITCOIN_CASHADDRESS = "bitcoincash:qzfyvx77v2pmgc0vulwlfkl3uzjgh5gnmqk5hhyaa6"
 BITCOIN_CASHADDRESS_COMPRESSED = (
     "bitcoincash:qzvsaasdvw6mt9j2rs3gyps673gj86flev4sthhcc0"
 )
-BITCOIN_CASHADDRESS_PAY2SH = "bitcoincash:pp23x8hm0g8d6nrkesamaqeml3v6daeudvpa7zhktf"
+BITCOIN_CASHADDRESS_CATKN = "bitcoincash:zzfyvx77v2pmgc0vulwlfkl3uzjgh5gnmq37yf2mzf"
+BITCOIN_CASHADDRESS_PAY2SH20 = "bitcoincash:pp23x8hm0g8d6nrkesamaqeml3v6daeudvpa7zhktf"
+BITCOIN_CASHADDRESS_PAY2SH32 = (
+    "bitcoincash:pvch8mmxy0rtfrlarg7ucrxxfzds5pamg73h7370aa87d80gyhqxqaw3dsfwg"
+)
 
 BITCOIN_CASHADDRESS_TEST = "bchtest:qzfyvx77v2pmgc0vulwlfkl3uzjgh5gnmqjxnsx26x"
 BITCOIN_CASHADDRESS_TEST_COMPRESSED = (
     "bchtest:qzvsaasdvw6mt9j2rs3gyps673gj86flev3z0s40ln"
 )
-BITCOIN_CASHADDRESS_TEST_PAY2SH = "bchtest:pp23x8hm0g8d6nrkesamaqeml3v6daeudv90694pv4"
+BITCOIN_CASHADDRESS_TEST_CATKN = "bchtest:zzfyvx77v2pmgc0vulwlfkl3uzjgh5gnmq4vqwgv94"
+BITCOIN_CASHADDRESS_TEST_PAY2SH20 = "bchtest:pp23x8hm0g8d6nrkesamaqeml3v6daeudv90694pv4"
+BITCOIN_CASHADDRESS_TEST_PAY2SH32 = (
+    "bchtest:pvch8mmxy0rtfrlarg7ucrxxfzds5pamg73h7370aa87d80gyhqxq7fqng6m6"
+)
 
 BITCOIN_CASHADDRESS_REGTEST = "bchreg:qzfyvx77v2pmgc0vulwlfkl3uzjgh5gnmqg6939eeq"
 BITCOIN_CASHADDRESS_REGTEST_COMPRESSED = (
     "bchreg:qzvsaasdvw6mt9j2rs3gyps673gj86flevt7e3kuu4"
 )
-BITCOIN_CASHADDRESS_REGTEST_PAY2SH = "bchreg:pp23x8hm0g8d6nrkesamaqeml3v6daeudvlnvykj0n"
+BITCOIN_CASHADDRESS_REGTEST_CATKN = "bchreg:zzfyvx77v2pmgc0vulwlfkl3uzjgh5gnmq0sk0tlxn"
+BITCOIN_CASHADDRESS_REGTEST_PAY2SH20 = (
+    "bchreg:pp23x8hm0g8d6nrkesamaqeml3v6daeudvlnvykj0n"
+)
 
 VALID_ENDPOINT_URLS = [
     "https://rest.bch.actorforth.org/v2/",
     "https://rest.bitcoin.com/v2/",
 ]
 
 INVALID_ENDPOINT_URLS = ["htp://fakesite.com/v2", "https://bitcom.org/", 42]
@@ -53,15 +64,16 @@
     b"w+32zqWGxPxKUiOlrXl+GsOhRANCAAQ9XCh1yb0RaHWnGl22TP/LEzlrFj0Dmx2T\n"
     b"J4JIkYBDNHakNSoq3QDrsNXJTFFbcusQ8f2PPwO0L0orJVv8mqnj\n"
     b"-----END PRIVATE KEY-----\n"
 )
 
 PUBKEY_HASH = b"\x92F\x1b\xdeb\x83\xb4a\xec\xe7\xdd\xf4\xdb\xf1\xe0\xa4\x8b\xd1\x13\xd8"
 PUBKEY_HASH_COMPRESSED = b'\x99\x0e\xf6\rc\xb5\xb5\x96J\x1c"\x82\x06\x1a\xf4Q#\xe9?\xcb'
-PUBKEY_HASH_P2SH = b"U\x13\x1e\xfbz\x0e\xddLv\xcc;\xbe\x83;\xfcY\xa6\xf7<k"
+PUBKEY_HASH_P2SH20 = b"U\x13\x1e\xfbz\x0e\xddLv\xcc;\xbe\x83;\xfcY\xa6\xf7<k"
+PUBKEY_HASH_P2SH32 = b"1s\xeff#\xc6\xb4\x8f\xfd\x1a=\xcc\x0c\xc6H\x9b\n\x07\xbbG\xa3\x7fG\xcf\xefO\xe6\x9d\xe8%\xc0`"
 PUBLIC_KEY_COMPRESSED = b"\x03=\\(u\xc9\xbd\x11hu\xa7\x1a]\xb6L\xff\xcb\x139k\x16=\x03\x9b\x1d\x93'\x82H\x91\x80C4"
 PUBLIC_KEY_UNCOMPRESSED = (
     b"\x04=\\(u\xc9\xbd\x11hu\xa7\x1a]\xb6L\xff\xcb\x139k\x16=\x03"
     b"\x9b\x1d\x93'\x82H\x91\x80C4v\xa45**\xdd\x00\xeb\xb0\xd5\xc9"
     b"LQ[r\xeb\x10\xf1\xfd\x8f?\x03\xb4/J+%[\xfc\x9a\xa9\xe3"
 )
 PUBLIC_KEY_X = (
@@ -156,7 +168,21 @@
     8,
     23,
     20,
     8,
     19,
     27,
 ]
+
+
+# CashToken prefixes
+CASHTOKEN_CATAGORY_ID = (
+    "00fb7b8704f843caf33c436e3386a469e1d004403c388a8b054282d02034f598"
+)
+CASHTOKEN_CAPABILITY = "none"
+CASHTOKEN_COMMITMENT = b"commitment"
+CASHTOKEN_AMOUNT = 50
+PREFIX_CAPABILITY = b"\xef\x98\xf54 \xd0\x82B\x05\x8b\x8a8<@\x04\xd0\xe1i\xa4\x863nC<\xf3\xcaC\xf8\x04\x87{\xfb\x00 "
+PREFIX_CAPABILITY_AMOUNT = b"\xef\x98\xf54 \xd0\x82B\x05\x8b\x8a8<@\x04\xd0\xe1i\xa4\x863nC<\xf3\xcaC\xf8\x04\x87{\xfb\x0002"
+PREFIX_CAPABILITY_COMMITMENT = b"\xef\x98\xf54 \xd0\x82B\x05\x8b\x8a8<@\x04\xd0\xe1i\xa4\x863nC<\xf3\xcaC\xf8\x04\x87{\xfb\x00`\ncommitment"
+PREFIX_CAPABILITY_COMMITMENT_AMOUNT = b"\xef\x98\xf54 \xd0\x82B\x05\x8b\x8a8<@\x04\xd0\xe1i\xa4\x863nC<\xf3\xcaC\xf8\x04\x87{\xfb\x00p\ncommitment2"
+PREFIX_AMOUNT = b"\xef\x98\xf54 \xd0\x82B\x05\x8b\x8a8<@\x04\xd0\xe1i\xa4\x863nC<\xf3\xcaC\xf8\x04\x87{\xfb\x00\x102"
```

## tests/test_cashaddress.py

```diff
@@ -22,14 +22,22 @@
     BITCOIN_CASHADDRESS_TEST,
     BITCOIN_CASHADDRESS_TEST_COMPRESSED,
     BITCOIN_CASHADDRESS_REGTEST,
     BITCOIN_CASHADDRESS_REGTEST_COMPRESSED,
     CONVERT_BITS_INVALID_DATA_PAYLOAD,
     CONVERT_BITS_NO_PAD_PAYLOAD,
     CONVERT_BITS_NO_PAD_RETURN,
+    BITCOIN_CASHADDRESS_PAY2SH20,
+    BITCOIN_CASHADDRESS_PAY2SH32,
+    BITCOIN_CASHADDRESS_CATKN,
+    PREFIX_AMOUNT,
+    PREFIX_CAPABILITY,
+    PREFIX_CAPABILITY_AMOUNT,
+    PREFIX_CAPABILITY_COMMITMENT,
+    PREFIX_CAPABILITY_COMMITMENT_AMOUNT,
 )
 
 
 class BadStr:
     # Class needed to raise exception on str()
     def __str__(self):
         raise Exception("Bad string")
@@ -220,14 +228,41 @@
     def test_eq(self):
         address = Address.from_string(BITCOIN_CASHADDRESS)
         assert address == BITCOIN_CASHADDRESS
         assert address == address
         with pytest.raises(ValueError):
             address == 1
 
+    def test_to_from_script(self):
+        address = Address.from_string(BITCOIN_CASHADDRESS)
+        assert address == Address.from_script(address.scriptcode)
+
+        address = Address.from_string(BITCOIN_CASHADDRESS_PAY2SH20)
+        assert address == Address.from_script(address.scriptcode)
+
+        address = Address.from_string(BITCOIN_CASHADDRESS_PAY2SH32)
+        assert address == Address.from_script(address.scriptcode)
+
+        # cashtoken
+        address = Address.from_string(BITCOIN_CASHADDRESS)
+        address_catkn = Address.from_string(BITCOIN_CASHADDRESS_CATKN)
+        # no cashtoken data
+        assert address == Address.from_script(address_catkn.scriptcode)
+        # with cashtoken data
+        for script in [
+            PREFIX_AMOUNT,
+            PREFIX_CAPABILITY,
+            PREFIX_CAPABILITY_AMOUNT,
+            PREFIX_CAPABILITY_COMMITMENT,
+            PREFIX_CAPABILITY_COMMITMENT_AMOUNT,
+        ]:
+            assert address_catkn == Address.from_script(
+                script + address_catkn.scriptcode
+            )
+
 
 def test_parse_cashaddress():
     # good address
     address, params = parse_cashaddress(
         BITCOIN_CASHADDRESS + "?amount=0.1337&label=Satoshi"
     )
     assert address.cash_address() == BITCOIN_CASHADDRESS
```

## tests/test_format.py

```diff
@@ -1,39 +1,45 @@
 import pytest
 from bitcash import crypto
 from _pytest.monkeypatch import MonkeyPatch
-from bitcash.exceptions import InvalidAddress
 
 from bitcash.format import (
-    Address,
     address_to_public_key_hash,
     bytes_to_wif,
     coords_to_public_key,
     point_to_public_key,
     public_key_to_coords,
     public_key_to_address,
     verify_sig,
     wif_checksum_check,
     wif_to_bytes,
+    hex_to_asm,
+    address_to_cashtokenaddress,
+    cashtokenaddress_to_address,
 )
 from .samples import (
     BITCOIN_ADDRESS,
     BITCOIN_ADDRESS_COMPRESSED,
-    BITCOIN_CASHADDRESS_PAY2SH,
+    BITCOIN_CASHADDRESS_CATKN,
+    BITCOIN_CASHADDRESS_PAY2SH20,
+    BITCOIN_CASHADDRESS_PAY2SH32,
     BITCOIN_ADDRESS_TEST,
+    BITCOIN_CASHADDRESS_TEST_CATKN,
     BITCOIN_ADDRESS_TEST_COMPRESSED,
     BITCOIN_ADDRESS_REGTEST,
     BITCOIN_ADDRESS_REGTEST_COMPRESSED,
-    BITCOIN_CASHADDRESS_TEST_PAY2SH,
+    BITCOIN_CASHADDRESS_TEST_PAY2SH20,
+    BITCOIN_CASHADDRESS_TEST_PAY2SH32,
     BITCOIN_CASHADDRESS_REGTEST,
     BITCOIN_CASHADDRESS_REGTEST_COMPRESSED,
-    BITCOIN_CASHADDRESS_REGTEST_PAY2SH,
+    BITCOIN_CASHADDRESS_REGTEST_PAY2SH20,
     PRIVATE_KEY_BYTES,
     PUBKEY_HASH,
-    PUBKEY_HASH_P2SH,
+    PUBKEY_HASH_P2SH20,
+    PUBKEY_HASH_P2SH32,
     BITCOIN_CASHADDRESS,
     BITCOIN_CASHADDRESS_TEST,
     BITCOIN_CASHADDRESS_TEST_COMPRESSED,
     PUBKEY_HASH_COMPRESSED,
     PUBLIC_KEY_COMPRESSED,
     PUBLIC_KEY_UNCOMPRESSED,
     PUBLIC_KEY_X,
@@ -307,15 +313,84 @@
         == PUBKEY_HASH_COMPRESSED
     )
     assert address_to_public_key_hash(BITCOIN_CASHADDRESS_REGTEST) == PUBKEY_HASH
     assert (
         address_to_public_key_hash(BITCOIN_CASHADDRESS_REGTEST_COMPRESSED)
         == PUBKEY_HASH_COMPRESSED
     )
-    assert address_to_public_key_hash(BITCOIN_CASHADDRESS_PAY2SH) == PUBKEY_HASH_P2SH
     assert (
-        address_to_public_key_hash(BITCOIN_CASHADDRESS_TEST_PAY2SH) == PUBKEY_HASH_P2SH
+        address_to_public_key_hash(BITCOIN_CASHADDRESS_PAY2SH20) == PUBKEY_HASH_P2SH20
     )
     assert (
-        address_to_public_key_hash(BITCOIN_CASHADDRESS_REGTEST_PAY2SH)
-        == PUBKEY_HASH_P2SH
+        address_to_public_key_hash(BITCOIN_CASHADDRESS_TEST_PAY2SH20)
+        == PUBKEY_HASH_P2SH20
     )
+    assert (
+        address_to_public_key_hash(BITCOIN_CASHADDRESS_PAY2SH32) == PUBKEY_HASH_P2SH32
+    )
+    assert (
+        address_to_public_key_hash(BITCOIN_CASHADDRESS_TEST_PAY2SH32)
+        == PUBKEY_HASH_P2SH32
+    )
+    assert (
+        address_to_public_key_hash(BITCOIN_CASHADDRESS_REGTEST_PAY2SH20)
+        == PUBKEY_HASH_P2SH20
+    )
+
+
+def test_to_and_from_cashtokenaddress():
+    cashtokenaddress = address_to_cashtokenaddress(BITCOIN_CASHADDRESS)
+    assert cashtokenaddress == BITCOIN_CASHADDRESS_CATKN
+    assert cashtokenaddress_to_address(cashtokenaddress) == BITCOIN_CASHADDRESS
+    cashtokenaddress = address_to_cashtokenaddress(BITCOIN_CASHADDRESS_TEST)
+    assert cashtokenaddress == BITCOIN_CASHADDRESS_TEST_CATKN
+    assert cashtokenaddress_to_address(cashtokenaddress) == BITCOIN_CASHADDRESS_TEST
+
+    # test vectors from https://github.com/bitjson/cashtokens
+    address = address_to_cashtokenaddress(
+        "bitcoincash:qr7fzmep8g7h7ymfxy74lgc0v950j3r2959lhtxxsl"
+    )
+    assert "bitcoincash:zr7fzmep8g7h7ymfxy74lgc0v950j3r295z4y4gq0v" == address
+    address = address_to_cashtokenaddress(
+        "bchtest:qr7fzmep8g7h7ymfxy74lgc0v950j3r295pdnvy3hr"
+    )
+    assert "bchtest:zr7fzmep8g7h7ymfxy74lgc0v950j3r295x8qj2hgs" == address
+    address = address_to_cashtokenaddress(
+        "bchreg:qr7fzmep8g7h7ymfxy74lgc0v950j3r295m39d8z59"
+    )
+    assert "bchreg:zr7fzmep8g7h7ymfxy74lgc0v950j3r295umknfytk" == address
+    address = address_to_cashtokenaddress(
+        "bitcoincash:ppawqn2h74a4t50phuza84kdp3794pq3ccvm92p8sh"
+    )
+    assert "bitcoincash:rpawqn2h74a4t50phuza84kdp3794pq3cct3k50p0y" == address
+    address = address_to_cashtokenaddress(
+        "bitcoincash:pvqqqqqqqqqqqqqqqqqqqqqqzg69v7ysqqqqqqqqqqqqqqqqqqqqqpkp7fqn0"
+    )
+    assert (
+        "bitcoincash:rvqqqqqqqqqqqqqqqqqqqqqqzg69v7ysqqqqqqqqqqqqqqqqqqqqqn9alsp2y"
+        == address
+    )
+
+
+def test_hex_to_asm():
+    asm = hex_to_asm("76a9147ff07a9532d16a3fe14112e8c856093b81c25a6a88ac")
+    assert asm == (
+        "OP_DUP OP_HASH160 7ff07a9532d16a3fe14112e8c856093b81c25a6a"
+        " OP_EQUALVERIFY OP_CHECKSIG"
+    )
+    asm = hex_to_asm(
+        "6a0442434d52206b2000be5ce5527cd653c49cdba486e2fd0ec4214"
+        "da2f71d7e56ad027b2139f448676973742e67697468756275736572"
+        "636f6e74656e742e636f6d2f6d722d7a776574732f3834623030353"
+        "7383038616632306466333932383135666232376434613636312f72"
+        "6177"
+    )
+    assert asm == (
+        "OP_RETURN 1380795202 6b2000be5ce5527cd653c49cdba486e2fd0"
+        "ec4214da2f71d7e56ad027b2139f4 676973742e6769746875627573"
+        "6572636f6e74656e742e636f6d2f6d722d7a776574732f3834623030"
+        "3537383038616632306466333932383135666232376434613636312f"
+        "726177"
+    )
+    # empty test
+    asm = hex_to_asm("6a4c00147ff07a9532d16a3fe14112e8c856093b81c25a6a")
+    assert asm == ("OP_RETURN  7ff07a9532d16a3fe14112e8c856093b81c25a6a")
```

## tests/test_transaction.py

```diff
@@ -7,21 +7,25 @@
     calc_txid,
     create_p2pkh_transaction,
     construct_input_block,
     construct_output_block,
     estimate_tx_fee,
     sanitize_tx_data,
 )
+from bitcash.op import OpCodes
+from bitcash.cashaddress import Address
 from bitcash.utils import hex_to_bytes
 from bitcash.wallet import PrivateKey
 from .samples import (
     WALLET_FORMAT_MAIN,
     BITCOIN_CASHADDRESS,
+    BITCOIN_CASHADDRESS_CATKN,
     BITCOIN_CASHADDRESS_COMPRESSED,
-    BITCOIN_CASHADDRESS_PAY2SH,
+    BITCOIN_CASHADDRESS_PAY2SH20,
+    BITCOIN_CASHADDRESS_PAY2SH32,
 )
 
 
 RETURN_ADDRESS = BITCOIN_CASHADDRESS
 
 FINAL_TX_1 = (
     "01000000018878399d83ec25c627cfbf753ff9ca3602373eac437ab2676154a"
@@ -69,16 +73,36 @@
         83727960,
         15,
         "76a91492461bde6283b461ece7ddf4dbf1e0a48bd113d888ac",
         "f3ad23dac2a3546167b27a43ac3e370236caf93f75bfcf27c625ec839d397888",
         1,
     )
 ]
-OUTPUTS = [(BITCOIN_CASHADDRESS, 50000), (BITCOIN_CASHADDRESS_COMPRESSED, 83658760)]
-MESSAGES = [(b"hello", 0), (b"there", 0)]
+OUTPUTS = [
+    (
+        Address.from_string(BITCOIN_CASHADDRESS).scriptcode,
+        50000,
+        None,
+        None,
+        None,
+        None,
+    ),
+    (
+        Address.from_string(BITCOIN_CASHADDRESS_COMPRESSED).scriptcode,
+        83658760,
+        None,
+        None,
+        None,
+        None,
+    ),
+]
+MESSAGES = [
+    (OpCodes.OP_RETURN.binary + b"\x05" + b"hello", 0, None, None, None, None),
+    (OpCodes.OP_RETURN.binary + b"\x05" + b"there", 0, None, None, None, None),
+]
 OUTPUT_BLOCK = (
     "50c30000000000001976a91492461bde6283b461ece7ddf4dbf1e0a48bd113d888ac"
     "0888fc04000000001976a914990ef60d63b5b5964a1c2282061af45123e93fcb88ac"
 )
 
 OUTPUT_BLOCK_TESTNET = (
     "50c30000000000001976a91492461bde6283b461ece7ddf4dbf1e0a48bd113d888ac"
@@ -102,38 +126,39 @@
     b"\x85\xc7\xf6\xc6\x80\x13\xc2g\xd3t\x8e\xb8\xb4\x1f\xcc"
     b"\x92x~\n\x1a\xac\xc0\xf0\xff\xf7\xda\xfe0\xb7!6t"
 )
 
 
 class TestTxIn:
     def test_init(self):
-        txin = TxIn(b"script", b"\x06", b"txid", b"\x04", 0)
+        txin = TxIn(b"script", b"\x06", b"txid", b"\x04", 0, b"a")
         assert txin.script == b"script"
         assert txin.script_len == b"\x06"
         assert txin.txid == b"txid"
         assert txin.txindex == b"\x04"
+        assert txin.token_prefix == b"a"
 
     def test_equality(self):
         txin1 = TxIn(b"script", b"\x06", b"txid", b"\x04", 0)
         txin2 = TxIn(b"script", b"\x06", b"txid", b"\x04", 0)
         txin3 = TxIn(b"script", b"\x06", b"txi", b"\x03", 0)
         assert txin1 == txin2
         assert txin1 != txin3
 
     def test_repr(self):
         txin = TxIn(b"script", b"\x06", b"txid", b"\x04", 0)
-        assert repr(txin) == "TxIn(b'script', {}, b'txid', {}, 0)" "".format(
-            repr(b"\x06"), repr(b"\x04")
+        assert repr(txin) == "TxIn(b'script', {}, b'txid', {}, 0, {})" "".format(
+            repr(b"\x06"), repr(b"\x04"), repr(b"")
         )
 
 
 class TestSanitizeTxData:
     def test_no_input(self):
         with pytest.raises(ValueError):
-            sanitize_tx_data([], [], 70, "")
+            sanitize_tx_data([], [], 70, BITCOIN_CASHADDRESS)
 
     def test_message(self):
         unspents_original = [Unspent(10000, 0, "", "", 0), Unspent(10000, 0, "", "", 0)]
         outputs_original = [(BITCOIN_CASHADDRESS_COMPRESSED, 1000, "satoshi")]
 
         unspents, outputs = sanitize_tx_data(
             unspents_original,
@@ -141,15 +166,15 @@
             fee=5,
             leftover=RETURN_ADDRESS,
             combine=True,
             message="hello",
         )
 
         assert len(outputs) == 3
-        assert outputs[2][0] == b"hello"
+        assert outputs[2][0] == OpCodes.OP_RETURN.binary + b"\x05" + b"hello"
         assert outputs[2][1] == 0
 
     def test_message_pushdata(self):
         unspents_original = [Unspent(10000, 0, "", "", 0), Unspent(10000, 0, "", "", 0)]
         outputs_original = [(BITCOIN_CASHADDRESS_COMPRESSED, 1000, "satoshi")]
 
         BYTES = len(b"hello").to_bytes(1, byteorder="little") + b"hello"
@@ -161,15 +186,15 @@
             leftover=RETURN_ADDRESS,
             combine=True,
             message=BYTES,
             custom_pushdata=True,
         )
 
         assert len(outputs) == 3
-        assert outputs[2][0] == b"\x05" + b"hello"
+        assert outputs[2][0] == OpCodes.OP_RETURN.binary + b"\x05" + b"hello"
         assert outputs[2][1] == 0
 
     def test_fee_applied(self):
         unspents_original = [Unspent(1000, 0, "", "", 0), Unspent(1000, 0, "", "", 0)]
         outputs_original = [(BITCOIN_CASHADDRESS_COMPRESSED, 2000, "satoshi")]
 
         with pytest.raises(InsufficientFunds):
@@ -192,33 +217,34 @@
             fee=0,
             leftover=RETURN_ADDRESS,
             combine=True,
             message=None,
         )
 
         assert unspents == unspents_original
-        assert outputs == [(BITCOIN_CASHADDRESS_COMPRESSED, 2000)]
+        _ = Address.from_string(BITCOIN_CASHADDRESS_COMPRESSED).scriptcode
+        assert outputs == [(_, 2000, None, None, None, None)]
 
     def test_combine_remaining(self):
         unspents_original = [Unspent(1000, 0, "", "", 0), Unspent(1000, 0, "", "", 0)]
-        outputs_original = [(BITCOIN_CASHADDRESS_COMPRESSED, 500, "satoshi")]
+        outputs_original = [(BITCOIN_CASHADDRESS_COMPRESSED, 600, "satoshi")]
 
         unspents, outputs = sanitize_tx_data(
             unspents_original,
             outputs_original,
             fee=0,
             leftover=RETURN_ADDRESS,
             combine=True,
             message=None,
         )
 
         assert unspents == unspents_original
         assert len(outputs) == 2
-        assert outputs[1][0] == RETURN_ADDRESS
-        assert outputs[1][1] == 1500
+        assert outputs[1][0] == Address.from_string(RETURN_ADDRESS).scriptcode
+        assert outputs[1][1] == 1400
 
     def test_combine_insufficient_funds(self):
         unspents_original = [Unspent(1000, 0, "", "", 0), Unspent(1000, 0, "", "", 0)]
         outputs_original = [(BITCOIN_CASHADDRESS_COMPRESSED, 2500, "satoshi")]
 
         with pytest.raises(InsufficientFunds):
             sanitize_tx_data(
@@ -241,15 +267,15 @@
             leftover=RETURN_ADDRESS,
             combine=False,
             message=None,
         )
 
         assert unspents == [Unspent(3000, 0, "", "", 0)]
         assert len(outputs) == 2
-        assert outputs[1][0] == RETURN_ADDRESS
+        assert outputs[1][0] == Address.from_string(RETURN_ADDRESS).scriptcode
         assert outputs[1][1] == 1000
 
     def test_no_combine_remaining_small_inputs(self):
         unspents_original = [
             Unspent(1500, 0, "", "", 0),
             Unspent(1600, 0, "", "", 0),
             Unspent(1700, 0, "", "", 0),
@@ -260,18 +286,17 @@
             unspents_original,
             outputs_original,
             fee=0,
             leftover=RETURN_ADDRESS,
             combine=False,
             message=None,
         )
-        print(unspents)
         assert unspents == [Unspent(1500, 0, "", "", 0), Unspent(1600, 0, "", "", 0)]
         assert len(outputs) == 2
-        assert outputs[1][0] == RETURN_ADDRESS
+        assert outputs[1][0] == Address.from_string(RETURN_ADDRESS).scriptcode
         assert outputs[1][1] == 1100
 
     def test_no_combine_with_fee(self):
         """
         Verify that unused unspents do not increase fee.
         """
         unspents_single = [Unspent(5000, 0, "", "", 0)]
@@ -296,16 +321,16 @@
             message=None,
         )
 
         assert unspents == [Unspent(5000, 0, "", "", 0)]
         assert unspents_single == [Unspent(5000, 0, "", "", 0)]
         assert len(outputs) == 2
         assert len(outputs_single) == 2
-        assert outputs[1][0] == RETURN_ADDRESS
-        assert outputs_single[1][0] == RETURN_ADDRESS
+        assert outputs[1][0] == Address.from_string(RETURN_ADDRESS).scriptcode
+        assert outputs_single[1][0] == Address.from_string(RETURN_ADDRESS).scriptcode
         assert outputs[1][1] == outputs_single[1][1]
 
     def test_no_combine_insufficient_funds(self):
         unspents_original = [Unspent(1000, 0, "", "", 0), Unspent(1000, 0, "", "", 0)]
         outputs_original = [(BITCOIN_CASHADDRESS_COMPRESSED, 2500, "satoshi")]
 
         with pytest.raises(InsufficientFunds):
@@ -314,72 +339,215 @@
                 outputs_original,
                 fee=50,
                 leftover=RETURN_ADDRESS,
                 combine=False,
                 message=None,
             )
 
-    def test_with_P2SH_outputs(self):
+    def test_with_P2SH20_outputs(self):
         # tx:af386b52b9804c4d37d0bcf9ca124b34264d2f0a306ea11ee74c90d939402cb7
         unspents_original = [
             Unspent(5691944, 0, "", "", 0),
             Unspent(17344, 0, "", "", 0),
         ]
         outputs_original = [
-            (BITCOIN_CASHADDRESS_PAY2SH, 11065, "satoshi"),
+            (BITCOIN_CASHADDRESS_PAY2SH20, 11065, "satoshi"),
         ]
 
         unspents, outputs = sanitize_tx_data(
             unspents_original,
             outputs_original,
             fee=1,
             leftover=RETURN_ADDRESS,
             combine=True,
             message=None,
         )
 
         assert outputs[1][1] == 5697851
 
-        # multi PAY2SH test
+        # multi PAY2SH20 test
         outputs_original = [
-            (BITCOIN_CASHADDRESS_PAY2SH, 11065, "satoshi"),
-            (BITCOIN_CASHADDRESS_PAY2SH, 11065, "satoshi"),
+            (BITCOIN_CASHADDRESS_PAY2SH20, 11065, "satoshi"),
+            (BITCOIN_CASHADDRESS_PAY2SH20, 11065, "satoshi"),
         ]
 
         unspents, outputs = sanitize_tx_data(
             unspents_original,
             outputs_original,
             fee=1,
             leftover=RETURN_ADDRESS,
             combine=True,
             message=None,
         )
 
         assert outputs[2][1] == 5686754
 
+    def test_with_P2SH32_outputs(self):
+        # based on
+        # tx:af386b52b9804c4d37d0bcf9ca124b34264d2f0a306ea11ee74c90d939402cb7
+        unspents_original = [
+            Unspent(5691944, 0, "", "", 0),
+            Unspent(17344, 0, "", "", 0),
+        ]
+        outputs_original = [
+            (BITCOIN_CASHADDRESS_PAY2SH32, 11065, "satoshi"),
+        ]
+
+        unspents, outputs = sanitize_tx_data(
+            unspents_original,
+            outputs_original,
+            fee=1,
+            leftover=RETURN_ADDRESS,
+            combine=True,
+            message=None,
+        )
+
+        assert outputs[1][1] == 5697839
+
+        # multi PAY2SH32 test
+        outputs_original = [
+            (BITCOIN_CASHADDRESS_PAY2SH32, 11065, "satoshi"),
+            (BITCOIN_CASHADDRESS_PAY2SH32, 11065, "satoshi"),
+        ]
+
+        unspents, outputs = sanitize_tx_data(
+            unspents_original,
+            outputs_original,
+            fee=1,
+            leftover=RETURN_ADDRESS,
+            combine=True,
+            message=None,
+        )
+
+        assert outputs[2][1] == 5686730
+
+
+class TestSanitizeTxDataCashToken:
+    def test_combine(self):
+        unspents_original = [
+            Unspent(1000, 0, "script", "txid", 0),
+            Unspent(1000, 0, "script", "txid", 1, "caff", "none"),
+            Unspent(1000, 0, "script", "txid", 1, "caff", "minting"),
+            Unspent(1000, 0, "script", "txid", 1, "caf2", "minting"),
+        ]
+        outputs_original = [
+            [BITCOIN_CASHADDRESS_CATKN, 1000, "satoshi", "caff", "none", None, None]
+        ]
+
+        unspents, outputs = sanitize_tx_data(
+            unspents_original,
+            outputs_original,
+            0,
+            BITCOIN_CASHADDRESS_CATKN,
+            combine=True,
+        )
+        assert unspents == unspents_original
+
+        assert len(outputs) == 3
+        assert outputs[0][1:] == (1000, "caff", "none", None, None)
+        assert outputs[1][1:] == (558, "caff", "minting", None, None)
+        assert outputs[2][1:] == (2442, "caf2", "minting", None, None)
+
+    def test_no_combine(self):
+        unspents_original = [
+            Unspent(1000, 0, "script", "txid", 0),
+            Unspent(1000, 0, "script", "txid", 1, "caff", "none"),
+            Unspent(1000, 0, "script", "txid", 1, "caff", "minting"),
+        ]
+        outputs_original = [
+            [BITCOIN_CASHADDRESS_CATKN, 1100, "satoshi", "caff", "none", None, None]
+        ]
+        script = Address.from_string(BITCOIN_CASHADDRESS_CATKN).scriptcode
+
+        unspents, outputs = sanitize_tx_data(
+            unspents_original,
+            outputs_original,
+            0,
+            BITCOIN_CASHADDRESS_CATKN,
+            combine=False,
+        )
+
+        assert len(unspents) == 2
+        assert len(outputs) == 2
+        assert outputs[0][1:] == (1100, "caff", "none", None, None)
+        assert outputs[1] == (script, 900, None, None, None, None)
+
+    def test_genesis(self):
+        unspents_original = [
+            Unspent(1000, 0, "script", "cafe", 0),
+            Unspent(1000, 0, "script", "caca", 1, "caff", "none"),
+            Unspent(1000, 0, "script", "txid", 1, "caff", "minting"),
+        ]
+        outputs_original = [
+            [BITCOIN_CASHADDRESS_CATKN, 800, "satoshi", "cafe", "none", None, None]
+        ]
+
+        unspents, outputs = sanitize_tx_data(
+            unspents_original,
+            outputs_original,
+            0,
+            BITCOIN_CASHADDRESS_CATKN,
+            combine=False,
+        )
+
+        assert len(unspents) == 2
+        assert unspents[0] == unspents_original[0]
+        assert len(outputs) == 2
+        assert outputs[0][1:] == (800, "cafe", "none", None, None)
+        assert outputs[1][1:] == (1200, "caff", "none", None, None)
+
+        # fail genesis
+        outputs_original = [
+            [BITCOIN_CASHADDRESS_CATKN, 800, "satoshi", "caca", "none", None, None]
+        ]
+
+        # caca is not genesis, since txindex = 1. Thus it is treated as
+        # normal cashtoken output. But unspents don't have caca cashtoken
+        with pytest.raises(InsufficientFunds):
+            unspents, outputs = sanitize_tx_data(
+                unspents_original,
+                outputs_original,
+                0,
+                BITCOIN_CASHADDRESS_CATKN,
+                combine=False,
+            )
+
 
 class TestCreateSignedTransaction:
     def test_matching(self):
         private_key = PrivateKey(WALLET_FORMAT_MAIN)
         tx = create_p2pkh_transaction(private_key, UNSPENTS, OUTPUTS)
         print(tx)
         assert tx[-288:] == FINAL_TX_1[-288:]
 
 
 class TestEstimateTxFee:
     def test_accurate_compressed(self):
-        assert estimate_tx_fee(1, 2, 0, 70, True) == 15820
-        assert estimate_tx_fee(1, 2, 2, 70, True) == 20300
-        assert estimate_tx_fee(1, 0, 2, 70, True) == 15540
+        # 2 p2pkh
+        output_script_list = [b"\x00" * 25] * 2
+        assert estimate_tx_fee(1, output_script_list, 70, True) == 15820
+        # 2 p2pkh 2 p2sh20
+        output_script_list = [b"\x00" * 25] * 2 + [b"\x00" * 23] * 2
+        assert estimate_tx_fee(1, output_script_list, 70, True) == 20300
+        # 2 p2sh20
+        output_script_list = [b"\x00" * 23] * 2
+        assert estimate_tx_fee(1, output_script_list, 70, True) == 15540
+        # 2 p2sh32
+        output_script_list = [b"\x00" * 35] * 2
+        assert estimate_tx_fee(1, output_script_list, 70, True) == 17220
 
     def test_accurate_uncompressed(self):
-        assert estimate_tx_fee(1, 2, 0, 70, False) == 18060
+        # 2 p2pkh
+        output_script_list = [b"\x00" * 25] * 2
+        assert estimate_tx_fee(1, output_script_list, 70, False) == 18060
 
     def test_none(self):
-        assert estimate_tx_fee(5, 5, 0, 0, True) == 0
+        # 5 p2pkh
+        output_script_list = [b"\x00" * 34] * 5
+        assert estimate_tx_fee(5, output_script_list, 0, True) == 0
 
 
 class TestConstructOutputBlock:
     def test_no_message(self):
         assert construct_output_block(OUTPUTS) == hex_to_bytes(OUTPUT_BLOCK)
 
     def test_message(self):
@@ -387,36 +555,47 @@
             OUTPUT_BLOCK_MESSAGES
         )
 
     def test_long_message(self):
         amount = b"\x00\x00\x00\x00\x00\x00\x00\x00"
         _, outputs = sanitize_tx_data(
             UNSPENTS,
-            [(out[0], out[1], "satoshi") for out in OUTPUTS],
+            [
+                (Address.from_script(out[0]).cash_address(), out[1], "satoshi")
+                for out in OUTPUTS
+            ],
             0,
             RETURN_ADDRESS,
             message="hello" * 50,
         )
+        print(outputs)
         assert construct_output_block(outputs).count(amount) == 2
 
     def test_pushdata_message(self):
-        BYTES = len(b"hello").to_bytes(1, byteorder="little") + b"hello"
+        BYTES = (
+            OpCodes.OP_RETURN.binary
+            + len(b"hello").to_bytes(1, byteorder="little")
+            + b"hello"
+        )
         assert construct_output_block(
-            OUTPUTS + [(BYTES, 0)], custom_pushdata=True
+            OUTPUTS + [(BYTES, 0, None, None, None, None)]
         ) == hex_to_bytes(OUTPUT_BLOCK_MESSAGE_PUSHDATA)
 
     def test_long_pushdata(self):
         BYTES = (
             len(b"hello").to_bytes(1, byteorder="little") + b"hello"
         )  # 6 bytes each * 40 = 240 bytes
 
         with pytest.raises(ValueError):
             sanitize_tx_data(
                 UNSPENTS,
-                [(out[0], out[1], "satoshi") for out in OUTPUTS],
+                [
+                    (Address.from_script(out[0]).cash_address(), out[1], "satoshi")
+                    for out in OUTPUTS
+                ],
                 0,
                 RETURN_ADDRESS,
                 message=BYTES * 40,
                 custom_pushdata=True,
             )
 
     def test_string_pushdata(self):
```

## tests/test_utils.py

```diff
@@ -1,17 +1,19 @@
+import io
 from bitcash.utils import (
     Decimal,
     bytes_to_hex,
     chunk_data,
     flip_hex_byte_order,
     hex_to_bytes,
     hex_to_int,
     int_to_hex,
     int_to_unknown_bytes,
     int_to_varint,
+    varint_to_int,
 )
 
 BIG_INT = 123456789**5
 BYTES_BIG = b"TH8\xe2\xaaN\xd7^aX7\x93\xe7\xc6\xa3\x02\x85"
 BYTES_LITTLE = b"\x85\x02\xa3\xc6\xe7\x937Xa^\xd7N\xaa\xe28HT"
 HEX = "544838e2aa4ed75e61583793e7c6a30285"
 ODD_HEX = "4fadd1977328c11efc1c1d8a781aa6b9677984d3e0bd0bfc52b9f3b03885a00"
@@ -65,14 +67,32 @@
     def test_val_less_than_4294967295(self):
         assert int_to_varint(4294967294) == b"\xfe\xfe\xff\xff\xff"
 
     def test_val_more_than_4294967295(self):
         assert int_to_varint(10000000000) == b"\xff\x00\xe4\x0bT\x02\x00\x00\x00"
 
 
+class TestVarIntToInt:
+    def test_val_less_than_253(self):
+        stream = io.BytesIO(b"\x14T")
+        assert varint_to_int(stream) == 20
+
+    def test_val_less_than_65535(self):
+        stream = io.BytesIO(b"\xfd\xff\xffT")
+        assert varint_to_int(stream) == 65535
+
+    def test_val_less_than_4294967295(self):
+        stream = io.BytesIO(b"\xfe\xfe\xff\xff\xffT")
+        assert varint_to_int(stream) == 4294967294
+
+    def test_val_more_than_4294967295(self):
+        stream = io.BytesIO(b"\xff\x00\xe4\x0bT\x02\x00\x00\x00T")
+        assert varint_to_int(stream) == 10000000000
+
+
 def test_hex_to_bytes():
     assert hex_to_bytes(HEX) == BYTES_BIG
     assert hex_to_bytes(ODD_HEX) == ODD_HEX_BYTES
 
 
 def test_hex_to_int():
     assert hex_to_int(HEX) == BIG_INT
```

## tests/test_wallet.py

```diff
@@ -31,17 +31,20 @@
     WALLET_FORMAT_COMPRESSED_TEST,
     WALLET_FORMAT_COMPRESSED_REGTEST,
     WALLET_FORMAT_MAIN,
     WALLET_FORMAT_TEST,
     WALLET_FORMAT_REGTEST,
     BITCOIN_CASHADDRESS,
     BITCOIN_CASHADDRESS_TEST,
+    BITCOIN_CASHADDRESS_TEST_CATKN,
     BITCOIN_CASHADDRESS_REGTEST,
-    BITCOIN_ADDRESS_TEST_PAY2SH,
-    BITCOIN_ADDRESS_REGTEST_PAY2SH,
+    BITCOIN_CASHADDRESS_REGTEST_CATKN,
+    BITCOIN_ADDRESS_TEST_PAY2SH20,
+    BITCOIN_ADDRESS_REGTEST_PAY2SH20,
+    BITCOIN_CASHADDRESS_CATKN,
 )
 
 
 class TestWIFToKey:
     def test_compressed_main(self):
         key = wif_to_key(WALLET_FORMAT_COMPRESSED_MAIN)
         assert isinstance(key, PrivateKey)
@@ -161,14 +164,15 @@
         assert private_key.balance == 0
         assert private_key.unspents == []
         assert private_key.transactions == []
 
     def test_address(self):
         private_key = PrivateKey(WALLET_FORMAT_MAIN)
         assert private_key.address == BITCOIN_CASHADDRESS
+        assert private_key.cashtoken_address == BITCOIN_CASHADDRESS_CATKN
 
     def test_to_wif(self):
         private_key = PrivateKey(WALLET_FORMAT_MAIN)
         assert private_key.to_wif() == WALLET_FORMAT_MAIN
 
         private_key = PrivateKey(WALLET_FORMAT_COMPRESSED_MAIN)
         assert private_key.to_wif() == WALLET_FORMAT_COMPRESSED_MAIN
@@ -210,15 +214,15 @@
         key = PrivateKey.from_int(PRIVATE_KEY_NUM)
         assert isinstance(key, PrivateKey)
         assert key.to_int() == PRIVATE_KEY_NUM
 
     def test_repr(self):
         assert (
             repr(PrivateKey(WALLET_FORMAT_MAIN))
-            == "<PrivateKey: bitcoincash:qzfyvx77v2pmgc0vulwlfkl3uzjgh5gnmqk5hhyaa6>"
+            == f"<PrivateKey: {BITCOIN_CASHADDRESS}>"
         )
 
     def test_pay2sh(self):
         # tx:af386b52b9804c4d37d0bcf9ca124b34264d2f0a306ea11ee74c90d939402cb7
         unspents_original = [
             Unspent(5691944, 1, "aa", "aa", 0),
             Unspent(17344, 0, "ab", "ab", 0),
@@ -234,15 +238,15 @@
         key = wif_to_key("cU6s7jckL3bZUUkb3Q2CD9vNu8F1o58K5R5a3JFtidoccMbhEGKZ")
         tx = key.create_transaction(
             outputs_original,
             unspents=unspents_original,
             fee=1,
             leftover="bitcoincash:qpqpu8xr56gmccalfssssjm2pcpv6d2fhur48wjdzf",
         )
-        out = tx[476:]
+        out = tx[478:]
 
         # test outputs
         assert out[:2] == "02"
         # P2SH output value
         assert int.from_bytes(bytes.fromhex(out[2:18]), "little") == 11065
         # P2SH locking script
         assert out[18:66] == "17a914e19bbfb5ee652c65d7c6b54748170850e1895f7587"
@@ -261,14 +265,15 @@
         assert private_key.balance == 0
         assert private_key.unspents == []
         assert private_key.transactions == []
 
     def test_address(self):
         private_key = PrivateKeyTestnet(WALLET_FORMAT_TEST)
         assert private_key.address == BITCOIN_CASHADDRESS_TEST
+        assert private_key.cashtoken_address == BITCOIN_CASHADDRESS_TEST_CATKN
 
     def test_to_wif(self):
         private_key = PrivateKeyTestnet(WALLET_FORMAT_TEST)
         assert private_key.to_wif() == WALLET_FORMAT_TEST
 
         private_key = PrivateKeyTestnet(WALLET_FORMAT_COMPRESSED_TEST)
         assert private_key.to_wif() == WALLET_FORMAT_COMPRESSED_TEST
@@ -347,15 +352,15 @@
         key = PrivateKeyTestnet.from_int(PRIVATE_KEY_NUM)
         assert isinstance(key, PrivateKeyTestnet)
         assert key.to_int() == PRIVATE_KEY_NUM
 
     def test_repr(self):
         assert (
             repr(PrivateKeyTestnet(WALLET_FORMAT_MAIN))
-            == "<PrivateKeyTestnet: bchtest:qzfyvx77v2pmgc0vulwlfkl3uzjgh5gnmqjxnsx26x>"
+            == f"<PrivateKeyTestnet: {BITCOIN_CASHADDRESS_TEST}>"
         )
 
 
 class TestPrivateKeyRegtest:
     def test_init_default(self):
         private_key = PrivateKeyRegtest()
 
@@ -363,14 +368,15 @@
         assert private_key.balance == 0
         assert private_key.unspents == []
         assert private_key.transactions == []
 
     def test_address(self):
         private_key = PrivateKeyRegtest(WALLET_FORMAT_REGTEST)
         assert private_key.address == BITCOIN_CASHADDRESS_REGTEST
+        assert private_key.cashtoken_address == BITCOIN_CASHADDRESS_REGTEST_CATKN
 
     def test_to_wif(self):
         private_key = PrivateKeyRegtest(WALLET_FORMAT_REGTEST)
         assert private_key.to_wif() == WALLET_FORMAT_REGTEST
 
         private_key = PrivateKeyRegtest(WALLET_FORMAT_COMPRESSED_REGTEST)
         assert private_key.to_wif() == WALLET_FORMAT_COMPRESSED_REGTEST
@@ -452,9 +458,9 @@
         key = PrivateKeyRegtest.from_int(PRIVATE_KEY_NUM)
         assert isinstance(key, PrivateKeyRegtest)
         assert key.to_int() == PRIVATE_KEY_NUM
 
     def test_repr(self):
         assert (
             repr(PrivateKeyRegtest(WALLET_FORMAT_REGTEST))
-            == "<PrivateKeyRegtest: bchreg:qzfyvx77v2pmgc0vulwlfkl3uzjgh5gnmqg6939eeq>"
+            == f"<PrivateKeyRegtest: {BITCOIN_CASHADDRESS_REGTEST}>"
         )
```

## tests/network/test_meta.py

```diff
@@ -1,18 +1,28 @@
 from bitcash.network.meta import Unspent
 
 
 class TestUnspent:
     def test_init(self):
-        unspent = Unspent(10000, 7, "script", "txid", 0)
+        unspent = Unspent(
+            10000, 7, "script", "txid", 0, "category_id", "none", "nft_commitment", 50
+        )
         assert unspent.amount == 10000
         assert unspent.confirmations == 7
         assert unspent.script == "script"
         assert unspent.txid == "txid"
         assert unspent.txindex == 0
+        assert unspent.category_id == "category_id"
+        assert unspent.nft_commitment == "nft_commitment"
+        assert unspent.nft_capability == "none"
+        assert unspent.token_amount == 50
+        # CashToken properties
+        assert unspent.has_amount is True
+        assert unspent.has_nft is True
+        assert unspent.has_cashtoken is True
 
     def test_dict_conversion(self):
         unspent = Unspent(10000, 7, "script", "txid", 0)
 
         assert unspent == Unspent.from_dict(unspent.to_dict())
 
     def test_equality(self):
@@ -25,7 +35,35 @@
     def test_repr(self):
         unspent = Unspent(10000, 7, "script", "txid", 0)
 
         assert repr(unspent) == (
             "Unspent(amount=10000, confirmations=7, "
             "script='script', txid='txid', txindex=0)"
         )
+
+    def test_gt(self):
+        unspent = Unspent(10000, 7, "script", "txid", 0)
+        unspent1 = Unspent(20000, 7, "script", "txid", 0)
+        unspent2 = Unspent(10000, 7, "script", "txid", 0, "category_id", "none")
+        unspent3 = Unspent(30000, 7, "script", "txid", 0, "category_id", "none")
+        unspent4 = Unspent(10000, 7, "script", "txid", 0, "category_id", "mutable")
+        unspent5 = Unspent(
+            20000, 7, "script", "txid", 0, "category_id", token_amount=50
+        )
+        unspent6 = Unspent(
+            20000, 7, "script", "txid", 0, "category_id", token_amount=20
+        )
+        unspent7 = Unspent(
+            30000, 7, "script", "txid", 0, "category_id", token_amount=20
+        )
+
+        assert unspent1 > unspent
+        assert unspent2 > unspent
+        assert unspent4 > unspent2
+        assert not unspent2 > unspent4
+        assert not unspent > unspent2
+        assert unspent3 > unspent2
+        assert unspent5 > unspent
+        assert not unspent > unspent5
+        assert unspent5 > unspent7
+        assert not unspent6 > unspent5
+        assert unspent7 > unspent6
```

## tests/network/test_services.py

```diff
@@ -2,14 +2,15 @@
 import os
 import pytest
 import time
 from bitcash.exceptions import InvalidEndpointURLProvided
 from bitcash.network.meta import Unspent
 from bitcash.network.services import (
     BitcoinDotComAPI,
+    ChaingraphAPI,
     NetworkAPI,
     get_endpoints_for,
     set_service_timeout,
 )
 from bitcash.network.transaction import Transaction
 from tests.samples import VALID_ENDPOINT_URLS, INVALID_ENDPOINT_URLS
 from tests.utils import (
@@ -120,15 +121,16 @@
         with pytest.raises(ConnectionError):
             MockBackend.get_unspent(MAIN_ADDRESS_USED1, network="mainnet")
 
     def test_get_raw_transaction_mainnet(self):
         time.sleep(1)
         results = NetworkAPI.get_raw_transaction(MAIN_TX, network="mainnet")
         assert isinstance(results, dict)
-        assert len(results) == 16
+        # assert len(results) == 16  # BitcoinDotCOM
+        assert len(results) == 7  # Chaingraph
 
     # Testnet
     @pytest.mark.skip
     def test_get_balance_testnet(self):
         # Marking as skip because BitcoinCom Testnet is currently unreliable
         # TODO: Remove once a new Testnet endpoint is added
         time.sleep(1)
@@ -173,27 +175,55 @@
         for url in INVALID_ENDPOINT_URLS:
             with pytest.raises(InvalidEndpointURLProvided):
                 BitcoinDotComAPI(url)
 
     def test_get_single_endpoint_for_env_variable(self):
         os.environ["BITCOINCOM_API_MAINNET"] = VALID_ENDPOINT_URLS[0]
         endpoints = get_endpoints_for("mainnet")
-        assert len(endpoints) == 1
-        assert isinstance(endpoints[0], BitcoinDotComAPI)
+        assert len(endpoints) == 3
+        assert isinstance(endpoints[0], ChaingraphAPI)  # default
+        assert isinstance(endpoints[1], ChaingraphAPI)  # default
+        assert isinstance(endpoints[2], BitcoinDotComAPI)  # env
         os.environ.pop("BITCOINCOM_API_MAINNET")
+        os.environ["CHAINGRAPH_API"] = VALID_ENDPOINT_URLS[0]
+        os.environ["CHAINGRAPH_API_MAINNET"] = "%mainnet"
+        endpoints = get_endpoints_for("mainnet")
+        assert len(endpoints) == 3
+        assert isinstance(endpoints[0], ChaingraphAPI)  # env
+        assert isinstance(endpoints[1], BitcoinDotComAPI)  # default
+        assert isinstance(endpoints[2], BitcoinDotComAPI)  # default
+        assert endpoints[0].node_like == "%mainnet"
+        os.environ.pop("CHAINGRAPH_API")
+        os.environ.pop("CHAINGRAPH_API_MAINNET")
 
     def test_get_multiple_endpoint_for_env_variable(self):
         os.environ["BITCOINCOM_API_MAINNET_1"] = VALID_ENDPOINT_URLS[0]
         os.environ["BITCOINCOM_API_MAINNET_2"] = VALID_ENDPOINT_URLS[1]
         endpoints = get_endpoints_for("mainnet")
-        assert len(endpoints) == 2
-        assert isinstance(endpoints[0], BitcoinDotComAPI)
-        assert isinstance(endpoints[1], BitcoinDotComAPI)
+        assert len(endpoints) == 4
+        assert isinstance(endpoints[0], ChaingraphAPI)  # default
+        assert isinstance(endpoints[1], ChaingraphAPI)  # default
+        assert isinstance(endpoints[2], BitcoinDotComAPI)  # env
+        assert isinstance(endpoints[3], BitcoinDotComAPI)  # env
         os.environ.pop("BITCOINCOM_API_MAINNET_1")
         os.environ.pop("BITCOINCOM_API_MAINNET_2")
+        os.environ["CHAINGRAPH_API_1"] = VALID_ENDPOINT_URLS[0]
+        os.environ["CHAINGRAPH_API_2"] = VALID_ENDPOINT_URLS[1]
+        os.environ["CHAINGRAPH_API_MAINNET_2"] = "%mainnet"
+        endpoints = get_endpoints_for("mainnet")
+        assert len(endpoints) == 4
+        assert isinstance(endpoints[0], ChaingraphAPI)  # default
+        assert isinstance(endpoints[1], ChaingraphAPI)  # default
+        assert isinstance(endpoints[2], BitcoinDotComAPI)  # env
+        assert isinstance(endpoints[3], BitcoinDotComAPI)  # env
+        assert endpoints[0].node_like == "%"
+        assert endpoints[1].node_like == "%mainnet"
+        os.environ.pop("CHAINGRAPH_API_1")
+        os.environ.pop("CHAINGRAPH_API_2")
+        os.environ.pop("CHAINGRAPH_API_MAINNET_2")
 
     def test_get_balance_mainnet_return_type(self):
         time.sleep(1)
         endpoints = BitcoinDotComAPI.get_default_endpoints("mainnet")
         for endpoint in endpoints:
             this_endpoint = BitcoinDotComAPI(endpoint)
             assert isinstance(this_endpoint.get_balance(MAIN_ADDRESS_USED1), int)
```

## Comparing `BitCash-0.6.8.dist-info/LICENSE.txt` & `BitCash-1.0.0.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `BitCash-0.6.8.dist-info/METADATA` & `BitCash-1.0.0.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 Metadata-Version: 2.1
 Name: BitCash
-Version: 0.6.8
+Version: 1.0.0
 Summary: Bitcoin Cash made easier.
 Home-page: https://github.com/pybitcash/bitcash
 Author: Teran McKinney
 Author-email: sega01@go-beyond.org
 Maintainer: Corentin Mercier
 Maintainer-email: corentin@mercier.link
 License: MIT
-Download-URL: https://github.com/pybitcash/bitcash/tarball/0.6.8
+Download-URL: https://github.com/pybitcash/bitcash/tarball/1.0.0
 Keywords: bitcoincash,cryptocurrency,payments,tools,wallet
 Platform: UNKNOWN
 Classifier: Development Status :: 4 - Beta
 Classifier: Intended Audience :: Developers
 Classifier: Intended Audience :: End Users/Desktop
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Natural Language :: English
@@ -94,15 +94,15 @@
 - Standard P2PKH transactions
 
 If you are intrigued, continue reading. If not, continue all the same!
 
 ## Installation
 
 BitCash is distributed on `PyPI` as a universal wheel and is available on Linux/macOS
-and Windows and supports Python 3.7+.
+and Windows and supports Python 3.8+.
 
 
 ```shell
 pip install bitcash  # pip3 if pip is Python 2 on your system.
 ```
 
 ## Documentation
```

### html2text {}

```diff
@@ -1,12 +1,12 @@
-Metadata-Version: 2.1 Name: BitCash Version: 0.6.8 Summary: Bitcoin Cash made
+Metadata-Version: 2.1 Name: BitCash Version: 1.0.0 Summary: Bitcoin Cash made
 easier. Home-page: https://github.com/pybitcash/bitcash Author: Teran McKinney
 Author-email: sega01@go-beyond.org Maintainer: Corentin Mercier Maintainer-
 email: corentin@mercier.link License: MIT Download-URL: https://github.com/
-pybitcash/bitcash/tarball/0.6.8 Keywords:
+pybitcash/bitcash/tarball/1.0.0 Keywords:
 bitcoincash,cryptocurrency,payments,tools,wallet Platform: UNKNOWN Classifier:
 Development Status :: 4 - Beta Classifier: Intended Audience :: Developers
 Classifier: Intended Audience :: End Users/Desktop Classifier: License :: OSI
 Approved :: MIT License Classifier: Natural Language :: English Classifier:
 Operating System :: OS Independent Classifier: Programming Language :: Python
 :: 3.7 Classifier: Programming Language :: Python :: 3.8 Classifier:
 Programming Language :: Python :: 3.9 Classifier: Programming Language ::
@@ -36,13 +36,13 @@
 storage - Fully supports 29 different currencies - First class support for
 storing data in the blockchain - Deterministic signatures via RFC 6979 - Access
 to the blockchain (and testnet chain) through multiple APIs for redundancy -
 Exchange rate API, with optional caching - Compressed public keys by default -
 Multiple representations of private keys; WIF, PEM, DER, etc. - Standard P2PKH
 transactions If you are intrigued, continue reading. If not, continue all the
 same! ## Installation BitCash is distributed on `PyPI` as a universal wheel and
-is available on Linux/macOS and Windows and supports Python 3.7+. ```shell pip
+is available on Linux/macOS and Windows and supports Python 3.8+. ```shell pip
 install bitcash # pip3 if pip is Python 2 on your system. ``` ## Documentation
 Docs are hosted by Github Pages and are automatically built and published after
 every successful commit to BitCash's ``master`` branch. [Read the
 documentation](https://bitcash.dev) ## Credits - [ofek](https://github.com/
 ofek/bit) for the original bit codebase. - [Additional](AUTHORS.md)
```

## Comparing `BitCash-0.6.8.dist-info/RECORD` & `BitCash-1.0.0.dist-info/RECORD`

 * *Files 18% similar despite different names*

```diff
@@ -1,42 +1,46 @@
-bitcash/__init__.py,sha256=mA-hDy10xxjpiLyy3APC-wlyn8qDC4Q4S_MW2lf9iqo,312
+bitcash/__init__.py,sha256=ERcur0VtfqOKdQIrb15WC1j4hN9JtI3EAdsirlBqEyo,312
 bitcash/_ripemd160.py,sha256=924YTi37mkRBDGqjmj58CLRVfBjiSWYpoz-z4zE1sIw,5199
 bitcash/base58.py,sha256=a2M0HWqmo19FdE6vXupFZGlFFqg7WthoTiB-tBnC20Y,1819
-bitcash/cashaddress.py,sha256=IqcpYsadsnb03arT1pRtGvIkEkcVvEdYn9KcexlRarE,7517
+bitcash/cashaddress.py,sha256=kTK0aNnSbXGsQTIKKx5Pv2yeH4M2JaxiYEny6up6ysE,12890
+bitcash/cashtoken.py,sha256=4naDb1Xj-Xdc7AQ8-Gr9tBIa4WLbZW5yF8l6jYyVu80,22719
 bitcash/cli.py,sha256=tEtnnWh2WLsaTe3DFFwh6eHH7bkFM8-XBy5X0K4Ro6k,309
 bitcash/crypto.py,sha256=fGduLfHYqhyOrDdO5E6fUqDe99oARFJakZHWpcBq2bI,576
 bitcash/curve.py,sha256=m9lRzgUlONUnGWcOqMegHJ5ohwdCCNuYhDGsN_-_YbA,483
-bitcash/exceptions.py,sha256=sxiR15_1DnR7ffLO0q3sqsQorlHgkQWWWf5kJcXDc2I,189
-bitcash/format.py,sha256=z81MKg5G0OKp0qVso3QCGm0XkZBSua-ypcRXMCzohkY,4859
+bitcash/exceptions.py,sha256=7rOhC9cL-l_tuL_oPl1VdU33R6k_zw3HQb_9X42MC4g,236
+bitcash/format.py,sha256=GBhHlJepqFthQetY4lxeoea27tZgeoqeubTEwtNgVBg,7674
 bitcash/keygen.py,sha256=A04c1zZJq6rpSC1wiVAyAEAlQstMUeO-NbZDnskasdY,2386
-bitcash/transaction.py,sha256=K6G8tOJDanTJecyucxNLlEoRGrpoLnofP9I5BtfQE4Y,12522
-bitcash/utils.py,sha256=7alyuR0XBorjXOgGhs65XJVmRoblhh4cU1PXEeVsifA,1218
-bitcash/wallet.py,sha256=0ZwkBN1Vm-hnZXwO1qbkYj6gaJhCJLcXnT_ER3qYcOg,21610
+bitcash/op.py,sha256=80ExwPqEcx4Bg5jTi-VQ0Ig24pzComTrm7ta0wQdnPM,5737
+bitcash/transaction.py,sha256=7iHMrYGu92J28DiP54zfKop7lqa-k7sKSFizGmCwSK8,11113
+bitcash/utils.py,sha256=trT2_0BqLt1cHm2oAbYBu1dl9xitSRup9CryfusV0NU,1742
+bitcash/wallet.py,sha256=1qQBm3yX69OzOpJuhmFeQL8Z0GGrnBsmt0wgDvUBy-I,25034
 bitcash/network/__init__.py,sha256=4303d1zyJjxMmZz08H7S_o1P5JNVqHHQJtcPslL3t9Y,170
-bitcash/network/meta.py,sha256=sfEuplO8cumkjUgW9tT0bbCd-gNrva1tZA4wjB4b3Ko,1166
+bitcash/network/meta.py,sha256=Qyv9CiJb5blteKT127mDgPLoyFKh_426_JwOlLHdblw,3910
 bitcash/network/rates.py,sha256=J6tT3YJNF3hw-Y2arAcXhZkHWgj7psM0R9Hwqp0KknI,20839
-bitcash/network/services.py,sha256=hFmueELa45SEj4gAm0D77JqJmt11xi73D6Y6iYDRb-g,7301
-bitcash/network/transaction.py,sha256=fzKxipeQzR-exnns2elTWuIkOD58uXE8SYBAgKQk4Rw,2032
-bitcash/network/APIs/BitcoinDotComAPI.py,sha256=U0VIsUnGBF6tzWS5HYQBSaXa8ig0xSpSO9MfeumH4nk,4939
-bitcash/network/APIs/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+bitcash/network/services.py,sha256=KiE0SNk-3zucdqXwDAJcVjsP1s7I_BkDy46ZzhvtI5A,9636
+bitcash/network/transaction.py,sha256=NgCP8w8wTZAEc3Ho-PX5qho18qlMzrHxKVP-QOMPg78,3305
+bitcash/network/APIs/BitcoinDotComAPI.py,sha256=8-mqQIKjvnyBXiiqIFXdiMltgwJmV3KzDV3LvwTEytE,8860
+bitcash/network/APIs/ChaingraphAPI.py,sha256=ACu7Jn9MWXHbEuoCzy5lW-Xu1b_37A6UvXbpi_sevPo,14017
+bitcash/network/APIs/__init__.py,sha256=eK7LmTP9Xw8EILKh6nxQORE1FyzXkFBBGgWyNq5kfV0,2764
 bitcash/network/http/__init__.py,sha256=CsayB2zMuNYEAXv-zl35p3irhAyhk0DQyqpDGeccp_U,241
 tests/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-tests/samples.py,sha256=jmIntNEc0dUTLerj6VAbiTsAnO2jgJzrNZ1cDPs6JG0,4713
+tests/samples.py,sha256=itHTr7wIFddro3usA4_PWkuyAG4d52cqhQN14W13gcI,6206
 tests/test_base58.py,sha256=GP6sbY3E93C3e-xzN9Cd0aw5rngeVDrW2Z-j5YZmKRc,1036
-tests/test_cashaddress.py,sha256=vBFLwAiHNaho6Gpm0plKLN1nS8lOGoJwAah4GuUz3rE,9509
+tests/test_cashaddress.py,sha256=j1Y76b6jwPiJTUDxY2gVzQlMNM7FeXnzGRHhuvOARMU,10810
+tests/test_cashtoken.py,sha256=3yZFvCb-fW8b8dsbDYGEdjIgLD33DibBIkeBZLVJVyQ,21615
 tests/test_curve.py,sha256=-sBw9gJKOlgvi-rG-gQ68GZ0Lpsy9CoGtSwVdcGYYdc,900
-tests/test_format.py,sha256=brvHToAcpNsHMFbVIBOT4tGgX-OJyH_JrH4oEQAz4wA,10596
-tests/test_transaction.py,sha256=GWSfAZaTo6pmP8IR5guUUVTWlcR-UZTCwnwkA7mj9pg,14436
-tests/test_utils.py,sha256=EHtKlqiVQRZy1QwylkGoYN-mXAvCyOMWiaaWvrHT5QY,2690
-tests/test_wallet.py,sha256=o4U0HHhDpozlaLIO-Uiv-hsPwFSJPW6Kqz58KbnU_M4,15886
+tests/test_format.py,sha256=w3v_DPChizb4VW6Rjv8IbSmwYootIkeVfv24hXDS96I,13615
+tests/test_transaction.py,sha256=9ge6h-IBBu8pWeZVLg-ewcqoxdmsxOlkgBIO2Mps-Eg,20473
+tests/test_utils.py,sha256=eWXdV-SAJpAxHsbqPHnBYCv9IuOMG8keVFQyrbGTptY,3312
+tests/test_wallet.py,sha256=6VMaF7MelD6-uz-mFRjpwDJZapN4QOM3O15uyKppRg4,16157
 tests/utils.py,sha256=vQXhkt1v8VWFHpqFCw0mmdHenhRl9swr2VztZIkeMm4,672
 tests/network/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-tests/network/test_meta.py,sha256=BvTS27SnVPjWr2B8W5VWEstJwgsKxwLM45Qlcz40h8Q,1012
+tests/network/test_meta.py,sha256=EFVmzpFhkWajnFoRQ268j5SH87k5xhk9ImR1T-69usc,2554
 tests/network/test_rates.py,sha256=VB5TRxvo3KqOYeuzpbj5EVbMJgacatiRTjKgmJCzO-4,2614
-tests/network/test_services.py,sha256=zsDSvGcAlgN5FBssHYx1SzaOjIhptXzAdtzPafIuwTA,15408
-BitCash-0.6.8.dist-info/AUTHORS.md,sha256=h2-RtP3w62mtQNXtQ_sppCD5fQwV-oyDxy5ShMjVZBQ,428
-BitCash-0.6.8.dist-info/LICENSE.txt,sha256=b2KK82Uty2-WjWR0lVj-f6m37fA3GMe-Mzi3oQq2iL8,1052
-BitCash-0.6.8.dist-info/METADATA,sha256=F-5HxM5GVrV2LtZteOCqk9hKMJ2DWs1QhXWmFvOQSQM,4294
-BitCash-0.6.8.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-BitCash-0.6.8.dist-info/entry_points.txt,sha256=V74SyZtAkGzTTvFy6v8OlNusDxQopsVy_Wdd5PKmyps,49
-BitCash-0.6.8.dist-info/top_level.txt,sha256=7A3uL54GMzX3TgkDgJqVc6Ya1maw4xOElrTI582mBT4,14
-BitCash-0.6.8.dist-info/RECORD,,
+tests/network/test_services.py,sha256=PghD0iNV431xL3w67PJHPdDZ_HTTkwWEWHiQr3K1vEs,17092
+BitCash-1.0.0.dist-info/AUTHORS.md,sha256=h2-RtP3w62mtQNXtQ_sppCD5fQwV-oyDxy5ShMjVZBQ,428
+BitCash-1.0.0.dist-info/LICENSE.txt,sha256=b2KK82Uty2-WjWR0lVj-f6m37fA3GMe-Mzi3oQq2iL8,1052
+BitCash-1.0.0.dist-info/METADATA,sha256=PEe0sHSNM-jJiTOiTnqg3r2wZWQAiQrKVDfbo1v6UM0,4294
+BitCash-1.0.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+BitCash-1.0.0.dist-info/entry_points.txt,sha256=V74SyZtAkGzTTvFy6v8OlNusDxQopsVy_Wdd5PKmyps,49
+BitCash-1.0.0.dist-info/top_level.txt,sha256=7A3uL54GMzX3TgkDgJqVc6Ya1maw4xOElrTI582mBT4,14
+BitCash-1.0.0.dist-info/RECORD,,
```

