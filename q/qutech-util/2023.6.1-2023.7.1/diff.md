# Comparing `tmp/qutech_util-2023.6.1-py3-none-any.whl.zip` & `tmp/qutech_util-2023.7.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,18 +1,19 @@
-Zip file size: 93651 bytes, number of entries: 49
+Zip file size: 98762 bytes, number of entries: 50
 -rw-r--r--  2.0 unx      389 b- defN 20-Feb-02 00:00 qutech_util/__init__.py
 -rw-r--r--  2.0 unx      220 b- defN 20-Feb-02 00:00 qutil/__init__.py
 -rw-r--r--  2.0 unx     1956 b- defN 20-Feb-02 00:00 qutil/__init__.pyi
 -rw-r--r--  2.0 unx     5366 b- defN 20-Feb-02 00:00 qutil/caching.py
 -rw-r--r--  2.0 unx     5222 b- defN 20-Feb-02 00:00 qutil/const.py
+-rw-r--r--  2.0 unx    14223 b- defN 20-Feb-02 00:00 qutil/domains.py
 -rw-r--r--  2.0 unx     3642 b- defN 20-Feb-02 00:00 qutil/functools.py
 -rw-r--r--  2.0 unx     2548 b- defN 20-Feb-02 00:00 qutil/image.py
 -rw-r--r--  2.0 unx     9229 b- defN 20-Feb-02 00:00 qutil/io.py
--rw-r--r--  2.0 unx     8604 b- defN 20-Feb-02 00:00 qutil/itertools.py
--rw-r--r--  2.0 unx    15438 b- defN 20-Feb-02 00:00 qutil/linalg.py
+-rw-r--r--  2.0 unx     8103 b- defN 20-Feb-02 00:00 qutil/itertools.py
+-rw-r--r--  2.0 unx    16907 b- defN 20-Feb-02 00:00 qutil/linalg.py
 -rw-r--r--  2.0 unx    40901 b- defN 20-Feb-02 00:00 qutil/matlab.py
 -rw-r--r--  2.0 unx     2627 b- defN 20-Feb-02 00:00 qutil/misc.py
 -rw-r--r--  2.0 unx     2890 b- defN 20-Feb-02 00:00 qutil/pandas_tools.py
 -rw-r--r--  2.0 unx     1304 b- defN 20-Feb-02 00:00 qutil/parallel.py
 -rw-r--r--  2.0 unx     4428 b- defN 20-Feb-02 00:00 qutil/qcodes.py
 -rw-r--r--  2.0 unx    15259 b- defN 20-Feb-02 00:00 qutil/qi.py
 -rw-r--r--  2.0 unx      464 b- defN 20-Feb-02 00:00 qutil/random.py
@@ -31,21 +32,21 @@
 -rw-r--r--  2.0 unx     3199 b- defN 20-Feb-02 00:00 qutil/plotting/presentation_notex.mplstyle
 -rw-r--r--  2.0 unx     4048 b- defN 20-Feb-02 00:00 qutil/plotting/presentation_tex.mplstyle
 -rw-r--r--  2.0 unx     2977 b- defN 20-Feb-02 00:00 qutil/plotting/publication_aps_notex.mplstyle
 -rw-r--r--  2.0 unx     4930 b- defN 20-Feb-02 00:00 qutil/plotting/publication_aps_tex.mplstyle
 -rw-r--r--  2.0 unx     4004 b- defN 20-Feb-02 00:00 qutil/plotting/tex.mplstyle
 -rw-r--r--  2.0 unx     4379 b- defN 20-Feb-02 00:00 qutil/plotting/thesis_tex.mplstyle
 -rw-r--r--  2.0 unx       99 b- defN 20-Feb-02 00:00 qutil/signal_processing/__init__.py
--rw-r--r--  2.0 unx     5688 b- defN 20-Feb-02 00:00 qutil/signal_processing/fourier_space.py
--rw-r--r--  2.0 unx    13047 b- defN 20-Feb-02 00:00 qutil/signal_processing/real_space.py
+-rw-r--r--  2.0 unx     8810 b- defN 20-Feb-02 00:00 qutil/signal_processing/fourier_space.py
+-rw-r--r--  2.0 unx    15767 b- defN 20-Feb-02 00:00 qutil/signal_processing/real_space.py
 -rw-r--r--  2.0 unx      107 b- defN 20-Feb-02 00:00 qutil/ui/__init__.py
 -rw-r--r--  2.0 unx      185 b- defN 20-Feb-02 00:00 qutil/ui/__init__.pyi
 -rw-r--r--  2.0 unx     2636 b- defN 20-Feb-02 00:00 qutil/ui/core.py
 -rw-r--r--  2.0 unx      107 b- defN 20-Feb-02 00:00 qutil/ui/gate_layout/__init__.py
 -rw-r--r--  2.0 unx      112 b- defN 20-Feb-02 00:00 qutil/ui/gate_layout/__init__.pyi
 -rw-r--r--  2.0 unx     7768 b- defN 20-Feb-02 00:00 qutil/ui/gate_layout/core.py
 -rw-r--r--  2.0 unx     1388 b- defN 20-Feb-02 00:00 qutil/ui/gate_layout/qcodes.py
-?rw-r--r--  2.0 unx    11346 b- defN 20-Feb-02 00:00 qutech_util-2023.6.1.dist-info/METADATA
-?rw-r--r--  2.0 unx       87 b- defN 20-Feb-02 00:00 qutech_util-2023.6.1.dist-info/WHEEL
-?rw-r--r--  2.0 unx    35137 b- defN 20-Feb-02 00:00 qutech_util-2023.6.1.dist-info/licenses/LICENSE
-?rw-r--r--  2.0 unx     4022 b- defN 20-Feb-02 00:00 qutech_util-2023.6.1.dist-info/RECORD
-49 files, 260812 bytes uncompressed, 87309 bytes compressed:  66.5%
+?rw-r--r--  2.0 unx    11346 b- defN 20-Feb-02 00:00 qutech_util-2023.7.1.dist-info/METADATA
+?rw-r--r--  2.0 unx       87 b- defN 20-Feb-02 00:00 qutech_util-2023.7.1.dist-info/WHEEL
+?rw-r--r--  2.0 unx    35137 b- defN 20-Feb-02 00:00 qutech_util-2023.7.1.dist-info/licenses/LICENSE
+?rw-r--r--  2.0 unx     4096 b- defN 20-Feb-02 00:00 qutech_util-2023.7.1.dist-info/RECORD
+50 files, 281919 bytes uncompressed, 92312 bytes compressed:  67.3%
```

## zipnote {}

```diff
@@ -9,14 +9,17 @@
 
 Filename: qutil/caching.py
 Comment: 
 
 Filename: qutil/const.py
 Comment: 
 
+Filename: qutil/domains.py
+Comment: 
+
 Filename: qutil/functools.py
 Comment: 
 
 Filename: qutil/image.py
 Comment: 
 
 Filename: qutil/io.py
@@ -129,20 +132,20 @@
 
 Filename: qutil/ui/gate_layout/core.py
 Comment: 
 
 Filename: qutil/ui/gate_layout/qcodes.py
 Comment: 
 
-Filename: qutech_util-2023.6.1.dist-info/METADATA
+Filename: qutech_util-2023.7.1.dist-info/METADATA
 Comment: 
 
-Filename: qutech_util-2023.6.1.dist-info/WHEEL
+Filename: qutech_util-2023.7.1.dist-info/WHEEL
 Comment: 
 
-Filename: qutech_util-2023.6.1.dist-info/licenses/LICENSE
+Filename: qutech_util-2023.7.1.dist-info/licenses/LICENSE
 Comment: 
 
-Filename: qutech_util-2023.6.1.dist-info/RECORD
+Filename: qutech_util-2023.7.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## qutil/__init__.py

```diff
@@ -1,8 +1,8 @@
 import lazy_loader
 
-__version__ = '2023.6.1'
+__version__ = '2023.7.1'
 
 """Lazy imports as described in https://scientific-python.org/specs/spec-0001"""
 __getattr__, __dir__, __all__ = lazy_loader.attach_stub(__name__, __file__)
 
 del lazy_loader
```

## qutil/itertools.py

```diff
@@ -21,14 +21,22 @@
 
 
     SupportsAddSubT = TypeVar('SupportsAddSubT', bound=SupportsAddSub)
     SupportsAddSubComparisonT = TypeVar('SupportsAddSubComparisonT',
                                         bound=SupportsAddSubComparison)
 
 
+def _round(x: float, decimals: int | None = None) -> float | int:
+    """Overrides builtin round behavior so that decimals==None does not
+    round at all."""
+    if decimals is None:
+        return x
+    return round(x, decimals)
+
+
 def separate_iterator(it: Iterable, sep: Any) -> Iterator:
     """separate_iterator('abcde', ',') --> a , b , c , d , e
 
     The same as :func:`~more_itertools.intersperse(sep, it, n=1)`. Only here for backwards compability.
     """
     warnings.warn(f"{__name__}.separate_iterator is just a wrapper around intersperse.",
                   DeprecationWarning,
@@ -115,184 +123,151 @@
         if elem > current:
             current = elem
             max_idx = idx
     return max_idx
 
 
 def next_largest(it: Iterable[SupportsAddSubComparisonT],
-                 value: SupportsAddSubT) -> SupportsAddSubT:
+                 value: SupportsAddSubT,
+                 precision: int | None = None) -> SupportsAddSubT:
     """Return the next-largest element to value from it.
 
     Parameters
     ----------
     it: Iterable
         The iterable to search.
     value: number-like
         The number to find the next-largest element to.
+    precision: int, optional
+        The number of decimal places up to which elements are compared.
 
     Returns
     -------
     The next-largest element to value in it, or the value itself if it
     is empty.
 
     Examples
     --------
-    >>> next_largest([3, 4, 1, -5], 2.7)
-    3.0
-    >>> next_largest([3, 4, 1, -5], 1.01)
-    3.0
-    >>> next_largest([3, 4, 1, -5], -10)
-    -5
-    >>> next_largest([3, 4, 1, -5], 7.123)
+    >>> next_largest([3, 4, 1, -5.0], 2.7)
+    3
+    >>> next_largest([3, 4, 1, -5.0], 1.01)
+    3
+    >>> next_largest([3, 4, 1, -5.0], -10)
+    -5.0
+    >>> next_largest([3, 4, 1, -5.0], 7.123)
     4
     >>> next_largest([1, 2, 10321], inf)
     10321
     >>> next_largest([], 42)
     42
-
-    Notes
-    -----
-    If you don't mind loading the elements into memory, the following
-    will almost certainly be faster (not accounting for corner cases)::
-
-        import bisect
-        def next_largest(it, value):
-            sorted_it = sorted(it)
-            idx = bisect.bisect_right(sorted_it, value)
-            return sorted_it[idx]
+    >>> next_largest([10, 11.0], 10 + 1e-14)
+    11.0
+    >>> next_largest([10, 11.0], 10 + 1e-14, precision=13)
+    10
 
     """
-    if value == inf:
-        return max(it, default=inf)
-    if value == -inf:
-        return min(it, default=-inf)
-
-    smallest_distance = inf
-    largest = -inf
-    for x in it:
-        if 0 <= (distance := x - value) < smallest_distance:
-            smallest_distance = distance
-        # Need to keep track of smallest value in case val is outside the interval of it
-        if largest < x <= value:
-            largest = x
-
-    if largest == -inf:
-        # empty iterable or +inf
-        largest = value
-    if smallest_distance == inf:
-        # no item in it larger than value
-        return largest
-    return smallest_distance + value
+    empty_sentinel = object()
+    pred_false, pred_true = partition(lambda x: _round(x - value, precision) >= 0, it)
+    result = min(pred_true, default=empty_sentinel)
+    if result is empty_sentinel:
+        return max(pred_false, default=value)
+    return result
 
 
 def next_smallest(it: Iterable[SupportsAddSubComparisonT],
-                  value: SupportsAddSubT) -> SupportsAddSubT:
+                  value: SupportsAddSubT,
+                  precision: int | None = None) -> SupportsAddSubT:
     """Return the next-smallest element to value from it.
 
     Parameters
     ----------
     it: Iterable
         The iterable to search.
     value: number-like
         The number to find the next-largest element to.
+    precision: int, optional
+        The number of decimal places up to which elements are compared.
 
     Returns
     -------
     The next-largest element to value in it, or the value itself if it
     is empty.
 
     Examples
     --------
-    >>> next_smallest([3, 4, 1, -5], 2.7)
-    1.0
-    >>> next_smallest([3, 4, 1, -5], 1.01)
-    1.0
-    >>> next_smallest([3, 4, 1, -5], -10)
-    -5
-    >>> next_smallest([3, 4, 1, -5], 7.123)
-    4.0
+    >>> next_smallest([3, 4, 1, -5.0], 2.7)
+    1
+    >>> next_smallest([3, 4, 1, -5.0], 1.01)
+    1
+    >>> next_smallest([3, 4, 1, -5.0], -10)
+    -5.0
+    >>> next_smallest([3, 4, 1, -5.0], 7.123)
+    4
     >>> next_smallest([1, 2, 10321], inf)
     10321
     >>> next_smallest([], 42)
     42
-
-    Notes
-    -----
-    If you don't mind loading the elements into memory, the following
-    will almost certainly be faster (not accounting for corner cases)::
-
-        import bisect
-        def next_smallest(it, value):
-            sorted_it = sorted(it)
-            idx = bisect.bisect_left(sorted_it, value)
-            return sorted_it[idx]
+    >>> next_smallest([10, 11.0], 11 - 1e-14)
+    10
+    >>> next_smallest([10, 11.0], 11 - 1e-14, precision=13)
+    11.0
 
     """
-    if value == inf:
-        return max(it, default=inf)
-    if value == -inf:
-        return min(it, default=-inf)
-
-    # This could be a lot simpler if corner cases need not be respected, such as if value is
-    # outside the interval of it.
-    largest_distance = -inf
-    smallest = inf
-    for x in it:
-        if 0 >= (dist := x - value) > largest_distance:
-            largest_distance = dist
-        # Need to keep track of smallest value in case value is outside the interval of it
-        if smallest > x >= value:
-            smallest = x
-
-    if smallest == inf:
-        # empty iterable or -inf
-        smallest = value
-    if largest_distance == -inf:
-        # no item in it larger than value
-        return smallest
-    return largest_distance + value
+    empty_sentinel = object()
+    pred_false, pred_true = partition(lambda x: _round(x - value, precision) <= 0, it)
+    result = max(pred_true, default=empty_sentinel)
+    if result is empty_sentinel:
+        return min(pred_false, default=value)
+    return result
 
 
 def next_closest(it: Iterable[SupportsAddSubComparisonT],
-                 value: SupportsAddSubT) -> SupportsAddSubT:
+                 value: SupportsAddSubT,
+                 precision: int | None = None) -> SupportsAddSubT:
     """Return the next-closest element to value from it.
 
     Parameters
     ----------
     it: Iterable
         The iterable to search.
     value: number-like
         The number to find the next-largest element to.
+    precision: int, optional
+        The number of decimal places up to which elements are compared.
 
     Returns
     -------
     The next-closest element to value in it, or the value itself if it
     is empty.
 
     Examples
     --------
-    >>> next_closest([3, 4, 1, -5], 2.7)
+    >>> next_closest([3, 4, 1, -5.0], 2.7)
     3
-    >>> next_closest([3, 4, 1, -5], 1.01)
+    >>> next_closest([3, 4, 1, -5.0], 1.01)
     1
-    >>> next_closest([3, 4, 1, -5], -10)
-    -5
-    >>> next_closest([3, 4, 1, -5], 7.123)
+    >>> next_closest([3, 4, 1, -5.0], -10)
+    -5.0
+    >>> next_closest([3, 4, 1, -5.0], 7.123)
     4
     >>> next_closest([1, 2, 10321], inf)
     10321
     >>> next_closest([], 42)
     42
+    >>> next_closest([10, 11], 10.5 + 1e-14)
+    11
+    >>> next_closest([10, 11], 10.5 + 1e-14, precision=13)
+    10
 
     """
     if value == -inf:
         return min(it, default=value)
     elif value == inf:
         return max(it, default=value)
-    return min(it, key=lambda x: abs(x - value), default=value)
+    return min(it, key=lambda x: _round(abs(x - value), precision), default=value)
 
 
 def ignore_exceptions(it: Iterable, exceptions: Any) -> Iterator:
     """Ignore all specified exceptions during iteration.
 
     >>> list(ignore_exceptions(map(lambda d: 5 / d, [2, 1, 0, 5]), ZeroDivisionError))
     [2.5, 5.0, 1.0]
```

## qutil/linalg.py

```diff
@@ -18,66 +18,101 @@
     numba = False
 
 __all__ = ['abs2', 'cexp', 'check_phase_eq', 'density', 'dot_HS',
            'max_abs_diff', 'max_rel_diff', 'mdot', 'pauli_expm', 'ptrace',
            'remove_float_errors', 'sparsity', 'tensor']
 
 
-def abs2(arr):
+def abs2(x,  /, out=None, *, where=True, casting='same_kind', order='C', dtype=None) -> ndarray:
     r"""
-    Fast function to calculate the absolute value squared,
+    Fast absolute value squared,
 
     .. math::
 
         |\cdot|^2 = \Re(\cdot)^2 + \Im(\cdot)^2.
 
     Equivalent to::
 
-        np.abs(x)**2.
+        abs(x)**2.
 
-    Parameters
-    ----------
-    arr : array_like
-        Array-like object to take the absolute value square of. Needs to
-        provide a ``real`` and ``imag`` attribute.
+    See :class:`numpy:numpy.ufunc` and the `NumPy reference`_ for
+    documentation of the arguments.
+
+    .. _NumPy reference: https://numpy.org/doc/stable/reference/ufuncs.html
+
+    Examples
+    --------
+    >>> abs2([(1 + 1j) / np.sqrt(2)])
+    array([1.])
+    >>> np.abs([(1 + 1j) / np.sqrt(2)])**2
+    array([1.])
 
     """
-    return arr.real**2 + arr.imag**2
+    x = np.asanyarray(x)
+    out = np.empty(x.shape, order=order, dtype=dtype or np.float64) if out is None else out
+    out = np.square(x.real, out=out, dtype=dtype, where=where, casting=casting)
+    if np.iscomplexobj(x):
+        tmp = np.square(x.imag, order=order, dtype=dtype, where=where, casting=casting)
+        out = np.add(out, tmp, out=out, dtype=dtype, where=where, casting=casting)
+    return out
 
 
-# Vectorize if numba is available
-if numba:
-    abs2 = nb.vectorize(
-        [nb.float64(nb.complex128), nb.float32(nb.complex64)]
-    )(abs2)
-
-
-def cexp(x: ndarray) -> ndarray:
-    r"""Fast complex exponential.
-
-    Parameters
-    ----------
-    x : ndarray
-        Argument of the complex exponential :math:`\exp(i x)`.
-
-    Returns
-    -------
-    y : ndarray
-        Complex exponential :math:`y = \exp(i x)`.
-
-    References
-    ----------
-    https://software.intel.com/en-us/forums/intel-distribution-for-python/topic/758148  # noqa
+def cexp(x, /, out=None, *, where=True, casting='same_kind', order='C', dtype=None) -> ndarray:
+    r"""
+    Fast complex exponential,
+
+    .. math::
+
+        \exp(i x).
+
+    See :class:`numpy:numpy.ufunc` and the `NumPy reference`_ for
+    documentation of the arguments.
+
+    .. _NumPy reference: https://numpy.org/doc/stable/reference/ufuncs.html
+
+    Examples
+    --------
+    >>> cexp([np.pi])
+    array([-1.+1.2246468e-16j])
+    >>> np.exp([1j * np.pi])
+    array([-1.+1.2246468e-16j])
+
     """
-    df_exp = np.empty(x.shape, dtype=np.complex128)
-    trig_buf = np.cos(x)
-    df_exp.real[:] = trig_buf
-    np.sin(x, out=trig_buf)
-    df_exp.imag[:] = trig_buf
-    return df_exp
+    x = np.asanyarray(x)
+    out = np.empty(x.shape, order=order, dtype=dtype or np.complex128) if out is None else out
+    out.real = np.cos(x, out=out.real, where=where, casting=casting)
+    out.imag = np.sin(x, out=out.imag, where=where, casting=casting)
+    return out
+
+
+if numba:
+    # nb.vectorize generates ufuncs with all the kwargs, so only one argument required.
+    def _abs2(x):
+        result = x.real * x.real
+        if np.iscomplexobj(x):
+            return result + x.imag * x.imag
+        return result
+
+
+    def _cexp(x):
+        return np.cos(x) + 1j * np.sin(x)
+
+
+    _abs2.__doc__ = abs2.__doc__
+    _cexp.__doc__ = cexp.__doc__
+    abs2 = nb.vectorize([nb.float32(nb.float32),
+                         nb.float32(nb.complex64),
+                         nb.float64(nb.float64),
+                         nb.float64(nb.complex128)],
+                        target='parallel',
+                        cache=True)(_abs2)
+    cexp = nb.vectorize([nb.complex64(nb.float32),
+                         nb.complex128(nb.float64)],
+                        target='parallel',
+                        cache=True)(_cexp)
 
 
 def closest_unitary(Q: ndarray, subspace: Sequence[int] = None) -> ndarray:
     """Compute the closest unitary to ``Q[np.ix_(*subspace)]`` on a given
     subspace using left polar decomposition."""
     if subspace is None:
         subspace = (range(Q.shape[-2]), range(Q.shape[-1]))
```

## qutil/signal_processing/fourier_space.py

```diff
@@ -4,26 +4,57 @@
 is sampled as their second argument, while always returning a tuple of
 (possibly processed) frequencies and processed data, i.e.::
 
     def fun(data, f, *args, **kwargs) -> processed_data, processed_f:
         ...
 
 """
-from typing import Literal, Tuple, TypeVar
+import inspect
+from typing import Literal, Tuple, TypeVar, Optional
 
 import numpy as np
 from scipy import integrate
 
+from qutil import linalg
+from qutil.functools import wraps
 from qutil.linalg import abs2
 from qutil.typecheck import check_literals
 
+try:
+    import numba as nb
+    numba = True
+except ImportError:
+    numba = False
+
 _S = TypeVar('_S')
 _T = TypeVar('_T')
 
 
+def _standardize(function):
+    """Adds variadic kwargs and f arg and return param."""
+    try:
+        parameters = inspect.signature(function).parameters
+        assert 'f' not in parameters, \
+            'Only use this decorator for functions without parameter named f'
+        assert not any(p.kind is inspect.Parameter.VAR_KEYWORD for _, p in parameters.items()), \
+            'Only use this decorator for functions without variadic keyword arguments.'
+    except ValueError:
+        # ufunc, https://numpy.org/doc/stable/reference/ufuncs.html#ufuncs-kwargs
+        parameters = {'out', 'where', 'axes', 'axis', 'keepdims', 'casting', 'order', 'dtype',
+                      'subok', 'signature', 'extobj'}
+
+    @wraps(function)
+    def wrapper(x, f, *args, **kwargs):
+        # Filter kwargs that function actually accepts
+        kwargs = {k: v for k, v in kwargs.items() if k in parameters}
+        return function(x, *args, **kwargs), f
+
+    return wrapper
+
+
 def Id(x: _S, f: _T, *_, **__) -> Tuple[_S, _T]:
     """The identity mapping."""
     return x, f
 
 
 def derivative(x, f, deriv_order: int = 0, **_) -> Tuple[np.ndarray, np.ndarray]:
     """Perform (anti-)derivatives.
@@ -46,14 +77,72 @@
     with np.errstate(invalid='ignore', divide='ignore'):
         xp = np.asanyarray(x)*(2*np.pi*f)**deriv_order
     if deriv_order < 0:
         xp[..., (f == 0).nonzero()] = 0
     return xp, f
 
 
+def rms(x, f, /, out=None, *, axis: Optional[int] = None, where=True, dtype=None, keepdims=False,
+        **_) -> Tuple[np.ndarray, np.ndarray]:
+    """Compute the RMS (root-mean-square).
+
+    See :class:`numpy.ufunc` and the `NumPy reference`_ for
+    documentation of the arguments.
+
+    .. _NumPy reference: https://numpy.org/doc/stable/reference/ufuncs.html
+
+    Examples
+    --------
+    >>> t = np.linspace(0, 1, 1001)
+    >>> x = 2*np.sqrt(2)*np.sin(2*np.pi*10*t)
+    >>> xf = np.fft.fft(x)  # nb rfft would need to be scaled by factor âˆš2
+    >>> r, _ = rms(xf, ...)  # f not actually needed
+    >>> r  # doctest: +ELLIPSIS
+    1.9990007493755...
+    >>> np.allclose(r, np.sqrt(x.mean()**2 + x.var()))
+    True
+    """
+    x = np.asanyarray(x)
+    N = np.take(x.shape, axis or range(x.ndim)).prod()
+
+    result = linalg.abs2(x, where=where, dtype=dtype)
+    result = np.sum(result, axis=axis, dtype=dtype, out=out, keepdims=keepdims, where=where)
+    result = np.sqrt(result, out=out, dtype=dtype)
+    result /= N
+    return result, f
+
+
+if numba:
+    # nb.guvectorize generates gufuncs with all the kwargs, so only work and result array required.
+    def _rms(x, res):
+        res[0] = 0
+        if np.iscomplexobj(x):
+            for i in range(x.shape[0]):
+                xx = x[i]
+                real = xx.real
+                imag = xx.imag
+                res += real * real + imag * imag
+        else:
+            for i in range(x.shape[0]):
+                real = x[i].real
+                res += real * real
+        res[0] = np.sqrt(res[0]) / x.shape[0]
+
+    _rms.__doc__ = rms.__doc__
+    rms = _standardize(
+        nb.guvectorize([(nb.float32[:], nb.float32[:]),
+                        (nb.float64[:], nb.float64[:]),
+                        (nb.complex64[:], nb.float32[:]),
+                        (nb.complex128[:], nb.float64[:])],
+                       '(n)->()',
+                       target='parallel',
+                       cache=True)(_rms)
+    )
+
+
 def brickwall_filter(x, f, f_min: float = 0, f_max: float = np.inf, **_) -> Tuple[np.ndarray,
                                                                                   np.ndarray]:
     """Apply a brick wall filter to the data.
 
     Parameters
     ----------
     x : array_like
```

## qutil/signal_processing/real_space.py

```diff
@@ -3,39 +3,121 @@
 data to be processed as their first argument while the processed data
 should be the sole return argument, i.e.::
 
     def fun(data, *args, **kwargs) -> processed_data:
         ...
 
 """
+import inspect
 import warnings
 from typing import Optional, Sequence, Callable, Union, Tuple, Literal, TypeVar
 
 import numpy as np
 from scipy import signal, fft
 
 from qutil import linalg
-from qutil.functools import chain, partial
+from qutil.functools import chain, partial, wraps
 from qutil.signal_processing import fourier_space
 from qutil.typecheck import check_literals
 
 # TODO: replace unsupported imports
 try:
     from scipy.signal.spectral import _median_bias, _triage_segments
 except ImportError:
     from scipy.signal._spectral_py import _median_bias, _triage_segments
 
+try:
+    import numba as nb
+    numba = True
+except ImportError:
+    numba = False
+
 _T = TypeVar('_T')
 
 
+def _standardize(function):
+    """Adds variadic kwargs."""
+    try:
+        parameters = inspect.signature(function).parameters
+    except ValueError:
+        # ufunc, https://numpy.org/doc/stable/reference/ufuncs.html#ufuncs-kwargs
+        parameters = {'out', 'where', 'axes', 'axis', 'keepdims', 'casting', 'order', 'dtype',
+                      'subok', 'signature', 'extobj'}
+
+    @wraps(function)
+    def wrapper(x, *args, **kwargs):
+        # Filter kwargs that function actually accepts
+        kwargs = {k: v for k, v in kwargs.items() if k in parameters}
+        return function(x, *args, **kwargs)
+
+    return wrapper
+
+
 def Id(x: _T, *_, **__) -> _T:
     """The identity mapping."""
     return x
 
 
+def rms(x, /, out=None, *, axis: Optional[int] = None, where=True, dtype=None, keepdims=False,
+        **_) -> np.ndarray:
+    """Compute the RMS (root-mean-square).
+
+    See :class:`numpy.ufunc` and the `NumPy reference`_ for
+    documentation of the arguments.
+
+    .. _NumPy reference: https://numpy.org/doc/stable/reference/ufuncs.html
+
+    Examples
+    --------
+    >>> t = np.linspace(0, 2*np.pi, 1001)
+    >>> x = 2*np.sqrt(2)*np.sin(t)
+    >>> r = rms(x)
+    >>> r  # doctest: +ELLIPSIS
+    1.9990007493755...
+    >>> np.allclose(r, np.sqrt(x.mean()**2 + x.var()))
+    True
+    """
+    x = np.asanyarray(x)
+    N = np.take(x.shape, axis or range(x.ndim)).prod()
+
+    result = linalg.abs2(x, where=where, dtype=dtype)
+    result = np.sum(result, axis=axis, dtype=dtype, out=out, keepdims=keepdims, where=where)
+    result = np.sqrt(result, out=out, dtype=dtype)
+    result /= np.sqrt(N)
+    return result
+
+
+if numba:
+    # nb.guvectorize generates gufuncs with all the kwargs, so only work and result array required.
+    def _rms(x, res):
+        res[0] = 0
+        if np.iscomplexobj(x):
+            for i in range(x.shape[0]):
+                xx = x[i]
+                real = xx.real
+                imag = xx.imag
+                res += real * real + imag * imag
+        else:
+            for i in range(x.shape[0]):
+                real = x[i].real
+                res += real * real
+        res[0] = np.sqrt(res[0] / x.shape[0])
+
+    _rms.__doc__ = rms.__doc__
+    rms = _standardize(
+        nb.guvectorize([(nb.float32[:], nb.float32[:]),
+                        (nb.float64[:], nb.float64[:]),
+                        (nb.complex64[:], nb.float32[:]),
+                        (nb.complex128[:], nb.float64[:])],
+                       '(n)->()',
+                       target='parallel',
+                       cache=True)(_rms)
+    )
+
+
 @check_literals
 def butter_filter(x, fs: float, order: int = 5,
                   btype: Literal['lowpass', 'highpass', 'bandpass'] = 'bandpass', f_min: float = 0,
                   f_max: float = np.inf, **_) -> np.ndarray:
     """Apply a digital Butter filter to the data.
 
     This function provides a simplified interface to SciPy's `signal`
@@ -73,15 +155,16 @@
 
 
 def welch(x, fourier_procfn: Optional[Union[Callable, Sequence[Callable]]] = None, fs: float = 1.0,
           window: Union[str, Tuple[np.ndarray, ...]] = 'hann', nperseg: Optional[int] = None,
           noverlap: Optional[int] = None, nfft: Optional[int] = None,
           detrend: Union[str, Callable] = 'constant', normalize: Union[bool, Callable] = False,
           return_onesided: Optional[bool] = None, scaling: str = 'density', axis: int = -1,
-          average: str = 'mean', **settings) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
+          average: str = 'mean', workers: Optional[int] = None,
+          **settings) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
     """Use Welch's method to estimate the power spectral density.
 
     Adapted from :mod:`scipy.signal.spectral`, so see that module for
     parameter explanations.
 
     Unlike the SciPy version, this function allows to perform an
     additional processing step on the Fourier transform of the time data
@@ -104,20 +187,21 @@
     ----------
     The following parameters are not present in the scipy function:
 
     fourier_procfn : callable or sequence thereof
         A processing function that acts on the Fourier-transformed
         data (see above).
     normalize : callable or bool, default: False
-        Similar to `detrend_func`, this can be used to normalize each
-        Welch segment with some function. If True, the data is
-        normalized by its standard deviation (corresponding to the RMS
-        by default as the normalization is performed after detrending).
-        This can be useful if one wants to compare spectra
-        qualitatively.
+        Similar to `detrend`, this can be used to normalize each Welch
+        segment with some function. If True, the data is normalized by
+        its standard deviation (corresponding to the RMS by default as
+        the normalization is performed after detrending). This can be
+        useful if one wants to compare spectra qualitatively.
+    workers : int, optional
+        The workers parameter of :func:`scipy:scipy.fft.fft`.
 
     Returns
     -------
     PSD : ndarray
         The power spectral density.
     f : ndarray
         The discrete FFT frequencies.
@@ -208,17 +292,16 @@
         detrend_func = detrend
 
     if not normalize:
         def normalize_func(d):
             return d
     elif not callable(normalize):
         def normalize_func(d):
-            # RMS normalization. Assumes detrend has already removed a constant trend, which means
-            # we divide by the standard deviation.
-            return d / d.std(axis=-1)[..., None]
+            # RMS normalization. Assumes detrend has already removed a constant trend.
+            return d / rms(d, axis=-1, keepdims=True)
     elif axis != -1:
         def normalize_func(d):
             d = np.moveaxis(d, -1, axis)
             d = normalize(d)
             return np.moveaxis(d, axis, -1)
     else:
         normalize_func = normalize
@@ -254,15 +337,15 @@
         ifft_func = fft.irfft
 
     freqs = freqs_func(nfft)
 
     # Perform the windowed FFTs. Need to pass kwargs so that FunctionChain can pass on only those
     # that are allowed for each function
     result = fft_func(x, win=win, detrend_func=detrend_func, normalize_func=normalize_func,
-                      nperseg=nperseg, noverlap=noverlap, nfft=nfft, sides=sides)
+                      nperseg=nperseg, noverlap=noverlap, nfft=nfft, sides=sides, workers=workers)
 
     # Do custom stuff with the Fourier transformed data
     result, freqs = fourier_procfn(result, freqs, **settings)
 
     # Absolute value square and scaling to get the PSD
     result = scale * linalg.abs2(result)
 
@@ -275,20 +358,20 @@
 
     # Inverse fft for processed time series data (not averaged over Welch segments)
     if not all(fp is fourier_space.Id for fp in fourier_procfn.functions):
         y, _ = fourier_procfn(
             # Basically just fft.fft or fft.rfft
             fft_func(
                 x, win=1, detrend_func=Id, normalize_func=Id, nperseg=x.shape[-1], noverlap=0,
-                nfft=x.shape[-1], sides=sides
+                nfft=x.shape[-1], sides=sides, workers=workers
             )[..., 0, :],
             freqs_func(x.shape[-1]),
             **settings
         )
-        ifft = np.moveaxis(ifft_func(y), -1, axis)
+        ifft = np.moveaxis(ifft_func(y, workers=workers), -1, axis)
     else:
         ifft = np.moveaxis(x, -1, axis)
 
     result = result.astype(outdtype)
 
     # Output is going to have new last axis for time/window index, so a
     # negative axis index shifts down one
@@ -317,15 +400,15 @@
                                  % (average,))
         else:
             result = np.reshape(result, result.shape[:-1])
 
     return result, freqs, ifft
 
 
-def _fft_helper(x, win, detrend_func, normalize_func, nperseg, noverlap, nfft, sides):
+def _fft_helper(x, win, detrend_func, normalize_func, nperseg, noverlap, nfft, sides, workers):
     """
     Calculate windowed FFT, for internal use by
     `scipy.signal._spectral_helper`.
 
     This is a helper function that does the main FFT calculation for
     `_spectral helper`. All input validation is performed there, and the
     data axis is assumed to be the last axis of x. It is not designed to
@@ -351,21 +434,21 @@
         # https://stackoverflow.com/a/5568169
         step = nperseg - noverlap
         shape = x.shape[:-1]+((x.shape[-1]-noverlap)//step, nperseg)
         strides = x.strides[:-1]+(step*x.strides[-1], x.strides[-1])
         result = np.lib.stride_tricks.as_strided(x, shape=shape,
                                                  strides=strides)
 
-    # Detrend each data segment individually
-    result = detrend_func(result)
+    # Detrend and normalize each data segment individually
+    result = normalize_func(detrend_func(result))
 
-    # Apply window by multiplication and normalize
-    result = normalize_func(win * result)
+    # Apply window by multiplication
+    result *= win
 
     # Perform the fft. Acts on last axis by default. Zero-pads automatically
     if sides == 'twosided':
         func = fft.fft
     else:
         result = result.real
         func = fft.rfft
 
-    return func(result, n=nfft)
+    return func(result, n=nfft, workers=workers)
```

## Comparing `qutech_util-2023.6.1.dist-info/METADATA` & `qutech_util-2023.7.1.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: qutech-util
-Version: 2023.6.1
+Version: 2023.7.1
 Summary: Utility package of the Quantum Technology group of RWTH Aachen
 Project-URL: Homepage, https://git.rwth-aachen.de/qutech/qutil
 Author: Quantum Technology Group, RWTH Aachen University
 License-Expression: GPL-3.0
 License-File: LICENSE
 Classifier: Intended Audience :: Science/Research
 Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)
```

## Comparing `qutech_util-2023.6.1.dist-info/licenses/LICENSE` & `qutech_util-2023.7.1.dist-info/licenses/LICENSE`

 * *Files identical despite different names*

## Comparing `qutech_util-2023.6.1.dist-info/RECORD` & `qutech_util-2023.7.1.dist-info/RECORD`

 * *Files 9% similar despite different names*

```diff
@@ -1,17 +1,18 @@
 qutech_util/__init__.py,sha256=sbsndCBhwMhADfCPaKfFc8tz2UFMXaf5QOO34qT82_U,389
-qutil/__init__.py,sha256=VBVzncZRkwRW-8bE1jWrtF6yndtosczDIFsao9De7ng,220
+qutil/__init__.py,sha256=Zyi3SUcFY0XlUzQglgB34ERkI6NOiBHii3DiPwBuFaM,220
 qutil/__init__.pyi,sha256=QJZKSW64E3uVd7iSeszi3Vj-eaDid8wG6MtuiFKY474,1956
 qutil/caching.py,sha256=80eM2I445x7OpNbSLj1IKxtRaPuMXHqqJBmPzW01zEw,5366
 qutil/const.py,sha256=kgDq1-yRiU7i18sRee1yHBV38dmlx6tCUgLqvjuZx7k,5222
+qutil/domains.py,sha256=8z-lHJOBaGx81830ttLEM7iyX6yw5Lcv5dR1j4G_7C0,14223
 qutil/functools.py,sha256=EevytiQyTPWNQNXtv8ii7RDFR2RbK1X4hmkBYnoTIXE,3642
 qutil/image.py,sha256=VcmQC8KmsxpwVuEcoipRvxyP5o9HEq5NAvvovmrL16E,2548
 qutil/io.py,sha256=RxwpiCH-BU0e2n-k_UoWsjYo5gQJgzq3duZ2QH88iL4,9229
-qutil/itertools.py,sha256=HVb4obpqDXD98dPnVNQS4KQWsczgfXJeuCSjXReqRVE,8604
-qutil/linalg.py,sha256=3HCJu0OCNrd1hCAsc8uSSjt5cRWECTf7EpFejgKz6Yc,15438
+qutil/itertools.py,sha256=XfO8GEJh5lylyjfW6hcOFp5BV3dMuLa__7vH3r9-LW8,8103
+qutil/linalg.py,sha256=bTuxFjwpf10TdB8a6m604BG2KF71td1Ng5eq5nTGDCY,16907
 qutil/matlab.py,sha256=8gAX2cIhhdvKpLHpBnV2rtmVN2xWv8b94c0fwMr7fjE,40901
 qutil/misc.py,sha256=tYUQAG-t9IpF39g8OYKjy0ElMRWggJyIoJil5NwpZmI,2627
 qutil/pandas_tools.py,sha256=xwObk2Kb4tbvspkO029Z7-WTzAnYkjefihZ_nTQ6msE,2890
 qutil/parallel.py,sha256=CUqJ1poyrm493zZWipPAsa96UhIVSWN-2CUHI5g5f_M,1304
 qutil/qcodes.py,sha256=1BoZ2-pHwm0qMcET7X27EKSJrwUaP6mRrYlq8Fm9hfY,4428
 qutil/qi.py,sha256=22rKgqNvE8cA4tEZIadOYKdW_aDHZvEL39HthSyobZM,15259
 qutil/random.py,sha256=y7UbWbJVhoOf7Xrr1OEBHrLngkzLEcreZ16XJ3MkvgU,464
@@ -30,20 +31,20 @@
 qutil/plotting/presentation_notex.mplstyle,sha256=vqkoseI9vpAonLIGLsPgYNEbQb8ohWB7k1H8b_3rZ9k,3199
 qutil/plotting/presentation_tex.mplstyle,sha256=nF5a7-5NUInFn7shWaNHRsloGW1B75YL-h7qYIPqmK4,4048
 qutil/plotting/publication_aps_notex.mplstyle,sha256=s-WAet9Dj4KS4ocVEe3l6cdV_rQs3nK7GCGmWzlfZOo,2977
 qutil/plotting/publication_aps_tex.mplstyle,sha256=4S4832ksXTSdxLlM83oynfTXVvabkozahqRSUTBIhcE,4930
 qutil/plotting/tex.mplstyle,sha256=wX2pkNXObWFQgpZh6Yk28VhUf1w-lWS7_tDF0PXwCgQ,4004
 qutil/plotting/thesis_tex.mplstyle,sha256=egVYZu1z6m6EXoQYG8EF9HlekA6G6rHyU5oO-iVuO9g,4379
 qutil/signal_processing/__init__.py,sha256=-ai-YuZbMUtEsYRzkiPWwtYKzaaJpGlk8pufx6-w-rs,99
-qutil/signal_processing/fourier_space.py,sha256=ZlOZwnEY3dB_R4l9hM8QksFMTiQR2TywMBoqh3rNcLA,5688
-qutil/signal_processing/real_space.py,sha256=zLp03_MJpdKGi2eJNbkL7zISvayp3eltmcdg-UU7Wcw,13047
+qutil/signal_processing/fourier_space.py,sha256=XdTyMWPezG0ED465j5Sk2BFB94Oyaitf4x5NKqWyQoI,8810
+qutil/signal_processing/real_space.py,sha256=Jk5rAd2jzoSsfgjp9B3lN8H2OHA7OU1yuhmOOPU0GeA,15767
 qutil/ui/__init__.py,sha256=KitURDTQ7axduqbi1wrruF4E51bsaA4EAPApXWRj7JI,107
 qutil/ui/__init__.pyi,sha256=l1KBJPOi-eyCM4fMai61-DTKEtyEWx-ziUQ0uwH9rH4,185
 qutil/ui/core.py,sha256=rltvgj3GpiHQzclbPGz5uoP24MyheuB0mHFcWoKE-Lw,2636
 qutil/ui/gate_layout/__init__.py,sha256=KitURDTQ7axduqbi1wrruF4E51bsaA4EAPApXWRj7JI,107
 qutil/ui/gate_layout/__init__.pyi,sha256=zFxSOnO5l7ISXlG3_TFyFcQ6VuYKCCku6c8Eg7chNEI,112
 qutil/ui/gate_layout/core.py,sha256=fMB5uclR3-5z2U9PsV8TugD03eCwaBzMJRlRNZtAAaE,7768
 qutil/ui/gate_layout/qcodes.py,sha256=6jAD8jIsR5U3J5iZcGRfBQrcofxHHBiy2PQYUYEYE8Q,1388
-qutech_util-2023.6.1.dist-info/METADATA,sha256=CVPS3ynbb12bwu393IgMnVKghUCcgi5qhuxgEb8V33o,11346
-qutech_util-2023.6.1.dist-info/WHEEL,sha256=9QBuHhg6FNW7lppboF2vKVbCGTVzsFykgRQjjlajrhA,87
-qutech_util-2023.6.1.dist-info/licenses/LICENSE,sha256=yWb-m4W9Rcm2N_Msgr5bz9cblBeGx04UJDv17416NA4,35137
-qutech_util-2023.6.1.dist-info/RECORD,,
+qutech_util-2023.7.1.dist-info/METADATA,sha256=il1GqeXLlgZebbh4wjSUc7rXQUjYBTN91K0SeEmv-Xc,11346
+qutech_util-2023.7.1.dist-info/WHEEL,sha256=9QBuHhg6FNW7lppboF2vKVbCGTVzsFykgRQjjlajrhA,87
+qutech_util-2023.7.1.dist-info/licenses/LICENSE,sha256=yWb-m4W9Rcm2N_Msgr5bz9cblBeGx04UJDv17416NA4,35137
+qutech_util-2023.7.1.dist-info/RECORD,,
```

