# Comparing `tmp/lightstreamer_adapter-1.2.3.zip` & `tmp/lightstreamer_adapter-1.3.0.zip`

## zipinfo {}

```diff
@@ -1,44 +1,44 @@
-Zip file size: 139722 bytes, number of entries: 42
-drwxrwxrwx  2.0 fat        0 b- stor 23-Mar-21 14:08 lightstreamer_adapter-1.2.3/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Mar-21 14:08 lightstreamer_adapter-1.2.3/doc/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Mar-21 14:08 lightstreamer_adapter-1.2.3/lightstreamer_adapter/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Mar-21 14:08 lightstreamer_adapter-1.2.3/lightstreamer_adapter.egg-info/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Mar-21 14:08 lightstreamer_adapter-1.2.3/tests/
--rw-rw-rw-  2.0 fat    50090 b- defN 23-Mar-21 14:07 lightstreamer_adapter-1.2.3/architecture.png
--rw-rw-rw-  2.0 fat     8929 b- defN 23-Mar-21 14:07 lightstreamer_adapter-1.2.3/HISTORY.rst
--rw-rw-rw-  2.0 fat      557 b- defN 23-Mar-21 14:07 lightstreamer_adapter-1.2.3/LICENSE
--rw-rw-rw-  2.0 fat       84 b- defN 23-Mar-21 14:07 lightstreamer_adapter-1.2.3/MANIFEST.in
--rw-rw-rw-  2.0 fat    18589 b- defN 23-Mar-21 14:08 lightstreamer_adapter-1.2.3/PKG-INFO
--rw-rw-rw-  2.0 fat     8260 b- defN 23-Mar-21 14:07 lightstreamer_adapter-1.2.3/README.rst
--rw-rw-rw-  2.0 fat       42 b- defN 23-Mar-21 14:08 lightstreamer_adapter-1.2.3/setup.cfg
--rw-rw-rw-  2.0 fat     1637 b- defN 23-Mar-21 14:07 lightstreamer_adapter-1.2.3/setup.py
-drwxrwxrwx  2.0 fat        0 b- stor 23-Mar-21 14:08 lightstreamer_adapter-1.2.3/doc/_static/
--rw-rw-rw-  2.0 fat    11636 b- defN 23-Mar-21 14:07 lightstreamer_adapter-1.2.3/doc/conf.py
--rw-rw-rw-  2.0 fat      493 b- defN 23-Mar-21 14:07 lightstreamer_adapter-1.2.3/doc/index.rst
--rw-rw-rw-  2.0 fat     1034 b- defN 23-Mar-21 14:07 lightstreamer_adapter-1.2.3/doc/lightstreamer_adapter.interfaces.rst
--rw-rw-rw-  2.0 fat      637 b- defN 23-Mar-21 14:07 lightstreamer_adapter-1.2.3/doc/lightstreamer_adapter.rst
--rwx---     2.0 fat     7016 b- defN 23-Mar-21 14:07 lightstreamer_adapter-1.2.3/doc/make.bat
--rw-rw-rw-  2.0 fat     7716 b- defN 23-Mar-21 14:07 lightstreamer_adapter-1.2.3/doc/Makefile
--rw-rw-rw-  2.0 fat      106 b- defN 23-Mar-21 14:07 lightstreamer_adapter-1.2.3/doc/requirements.txt
--rw-rw-rw-  2.0 fat     4146 b- defN 23-Mar-21 14:07 lightstreamer_adapter-1.2.3/doc/_static/classic.css
-drwxrwxrwx  2.0 fat        0 b- stor 23-Mar-21 14:08 lightstreamer_adapter-1.2.3/lightstreamer_adapter/interfaces/
--rw-rw-rw-  2.0 fat     3886 b- defN 23-Mar-21 14:07 lightstreamer_adapter-1.2.3/lightstreamer_adapter/data_protocol.py
--rw-rw-rw-  2.0 fat    12788 b- defN 23-Mar-21 14:07 lightstreamer_adapter-1.2.3/lightstreamer_adapter/metadata_protocol.py
--rw-rw-rw-  2.0 fat    10713 b- defN 23-Mar-21 14:07 lightstreamer_adapter-1.2.3/lightstreamer_adapter/protocol.py
--rw-rw-rw-  2.0 fat    63491 b- defN 23-Mar-21 14:07 lightstreamer_adapter-1.2.3/lightstreamer_adapter/server.py
--rw-rw-rw-  2.0 fat     9920 b- defN 23-Mar-21 14:07 lightstreamer_adapter-1.2.3/lightstreamer_adapter/subscription.py
--rw-rw-rw-  2.0 fat      328 b- defN 23-Mar-21 14:07 lightstreamer_adapter-1.2.3/lightstreamer_adapter/__init__.py
--rw-rw-rw-  2.0 fat    17377 b- defN 23-Mar-21 14:07 lightstreamer_adapter-1.2.3/lightstreamer_adapter/interfaces/data.py
--rw-rw-rw-  2.0 fat    53936 b- defN 23-Mar-21 14:07 lightstreamer_adapter-1.2.3/lightstreamer_adapter/interfaces/metadata.py
--rw-rw-rw-  2.0 fat        0 b- defN 23-Mar-21 14:07 lightstreamer_adapter-1.2.3/lightstreamer_adapter/interfaces/__init__.py
--rw-rw-rw-  2.0 fat        1 b- defN 23-Mar-21 14:08 lightstreamer_adapter-1.2.3/lightstreamer_adapter.egg-info/dependency_links.txt
--rw-rw-rw-  2.0 fat    18589 b- defN 23-Mar-21 14:08 lightstreamer_adapter-1.2.3/lightstreamer_adapter.egg-info/PKG-INFO
--rw-rw-rw-  2.0 fat      903 b- defN 23-Mar-21 14:08 lightstreamer_adapter-1.2.3/lightstreamer_adapter.egg-info/SOURCES.txt
--rw-rw-rw-  2.0 fat       22 b- defN 23-Mar-21 14:08 lightstreamer_adapter-1.2.3/lightstreamer_adapter.egg-info/top_level.txt
--rw-rw-rw-  2.0 fat     8605 b- defN 23-Mar-21 14:07 lightstreamer_adapter-1.2.3/tests/common.py
--rw-rw-rw-  2.0 fat    34677 b- defN 23-Mar-21 14:07 lightstreamer_adapter-1.2.3/tests/test_data.py
--rw-rw-rw-  2.0 fat     7948 b- defN 23-Mar-21 14:07 lightstreamer_adapter-1.2.3/tests/test_data_protocol.py
--rw-rw-rw-  2.0 fat    94051 b- defN 23-Mar-21 14:07 lightstreamer_adapter-1.2.3/tests/test_metadata.py
--rw-rw-rw-  2.0 fat    21478 b- defN 23-Mar-21 14:07 lightstreamer_adapter-1.2.3/tests/test_metadata_protocol.py
--rw-rw-rw-  2.0 fat        0 b- defN 23-Mar-21 14:07 lightstreamer_adapter-1.2.3/tests/__init__.py
-42 files, 479685 bytes uncompressed, 132164 bytes compressed:  72.4%
+Zip file size: 142160 bytes, number of entries: 42
+drwxrwxrwx  2.0 fat        0 b- stor 23-Jul-17 09:41 lightstreamer_adapter-1.3.0/
+drwxrwxrwx  2.0 fat        0 b- stor 23-Jul-17 09:41 lightstreamer_adapter-1.3.0/doc/
+drwxrwxrwx  2.0 fat        0 b- stor 23-Jul-17 09:41 lightstreamer_adapter-1.3.0/lightstreamer_adapter/
+drwxrwxrwx  2.0 fat        0 b- stor 23-Jul-17 09:41 lightstreamer_adapter-1.3.0/lightstreamer_adapter.egg-info/
+drwxrwxrwx  2.0 fat        0 b- stor 23-Jul-17 09:41 lightstreamer_adapter-1.3.0/tests/
+-rw-rw-rw-  2.0 fat    50090 b- defN 23-Jul-17 09:38 lightstreamer_adapter-1.3.0/architecture.png
+-rw-rw-rw-  2.0 fat    10725 b- defN 23-Jul-17 09:38 lightstreamer_adapter-1.3.0/HISTORY.rst
+-rw-rw-rw-  2.0 fat      557 b- defN 23-Jul-17 09:38 lightstreamer_adapter-1.3.0/LICENSE
+-rw-rw-rw-  2.0 fat       84 b- defN 23-Jul-17 09:38 lightstreamer_adapter-1.3.0/MANIFEST.in
+-rw-rw-rw-  2.0 fat    20554 b- defN 23-Jul-17 09:41 lightstreamer_adapter-1.3.0/PKG-INFO
+-rw-rw-rw-  2.0 fat     8387 b- defN 23-Jul-17 09:38 lightstreamer_adapter-1.3.0/README.rst
+-rw-rw-rw-  2.0 fat       42 b- defN 23-Jul-17 09:41 lightstreamer_adapter-1.3.0/setup.cfg
+-rw-rw-rw-  2.0 fat     1637 b- defN 23-Jul-17 09:38 lightstreamer_adapter-1.3.0/setup.py
+drwxrwxrwx  2.0 fat        0 b- stor 23-Jul-17 09:41 lightstreamer_adapter-1.3.0/doc/_static/
+-rw-rw-rw-  2.0 fat    11636 b- defN 23-Jul-17 09:38 lightstreamer_adapter-1.3.0/doc/conf.py
+-rw-rw-rw-  2.0 fat      493 b- defN 23-Jul-17 09:38 lightstreamer_adapter-1.3.0/doc/index.rst
+-rw-rw-rw-  2.0 fat     1034 b- defN 23-Jul-17 09:38 lightstreamer_adapter-1.3.0/doc/lightstreamer_adapter.interfaces.rst
+-rw-rw-rw-  2.0 fat      637 b- defN 23-Jul-17 09:38 lightstreamer_adapter-1.3.0/doc/lightstreamer_adapter.rst
+-rwx---     2.0 fat     7016 b- defN 23-Jul-17 09:38 lightstreamer_adapter-1.3.0/doc/make.bat
+-rw-rw-rw-  2.0 fat     7716 b- defN 23-Jul-17 09:38 lightstreamer_adapter-1.3.0/doc/Makefile
+-rw-rw-rw-  2.0 fat      106 b- defN 23-Jul-17 09:38 lightstreamer_adapter-1.3.0/doc/requirements.txt
+-rw-rw-rw-  2.0 fat     4146 b- defN 23-Jul-17 09:38 lightstreamer_adapter-1.3.0/doc/_static/classic.css
+drwxrwxrwx  2.0 fat        0 b- stor 23-Jul-17 09:41 lightstreamer_adapter-1.3.0/lightstreamer_adapter/interfaces/
+-rw-rw-rw-  2.0 fat     3886 b- defN 23-Jul-17 09:38 lightstreamer_adapter-1.3.0/lightstreamer_adapter/data_protocol.py
+-rw-rw-rw-  2.0 fat    12788 b- defN 23-Jul-17 09:38 lightstreamer_adapter-1.3.0/lightstreamer_adapter/metadata_protocol.py
+-rw-rw-rw-  2.0 fat    10802 b- defN 23-Jul-17 09:38 lightstreamer_adapter-1.3.0/lightstreamer_adapter/protocol.py
+-rw-rw-rw-  2.0 fat    65879 b- defN 23-Jul-17 09:38 lightstreamer_adapter-1.3.0/lightstreamer_adapter/server.py
+-rw-rw-rw-  2.0 fat     9920 b- defN 23-Jul-17 09:38 lightstreamer_adapter-1.3.0/lightstreamer_adapter/subscription.py
+-rw-rw-rw-  2.0 fat      328 b- defN 23-Jul-17 09:38 lightstreamer_adapter-1.3.0/lightstreamer_adapter/__init__.py
+-rw-rw-rw-  2.0 fat    17377 b- defN 23-Jul-17 09:38 lightstreamer_adapter-1.3.0/lightstreamer_adapter/interfaces/data.py
+-rw-rw-rw-  2.0 fat    54120 b- defN 23-Jul-17 09:38 lightstreamer_adapter-1.3.0/lightstreamer_adapter/interfaces/metadata.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jul-17 09:38 lightstreamer_adapter-1.3.0/lightstreamer_adapter/interfaces/__init__.py
+-rw-rw-rw-  2.0 fat        1 b- defN 23-Jul-17 09:41 lightstreamer_adapter-1.3.0/lightstreamer_adapter.egg-info/dependency_links.txt
+-rw-rw-rw-  2.0 fat    20554 b- defN 23-Jul-17 09:41 lightstreamer_adapter-1.3.0/lightstreamer_adapter.egg-info/PKG-INFO
+-rw-rw-rw-  2.0 fat      903 b- defN 23-Jul-17 09:41 lightstreamer_adapter-1.3.0/lightstreamer_adapter.egg-info/SOURCES.txt
+-rw-rw-rw-  2.0 fat       22 b- defN 23-Jul-17 09:41 lightstreamer_adapter-1.3.0/lightstreamer_adapter.egg-info/top_level.txt
+-rw-rw-rw-  2.0 fat     7556 b- defN 23-Jul-17 09:38 lightstreamer_adapter-1.3.0/tests/common.py
+-rw-rw-rw-  2.0 fat    36663 b- defN 23-Jul-17 09:38 lightstreamer_adapter-1.3.0/tests/test_data.py
+-rw-rw-rw-  2.0 fat     8224 b- defN 23-Jul-17 09:38 lightstreamer_adapter-1.3.0/tests/test_data_protocol.py
+-rw-rw-rw-  2.0 fat    99083 b- defN 23-Jul-17 09:38 lightstreamer_adapter-1.3.0/tests/test_metadata.py
+-rw-rw-rw-  2.0 fat    21478 b- defN 23-Jul-17 09:38 lightstreamer_adapter-1.3.0/tests/test_metadata_protocol.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jul-17 09:38 lightstreamer_adapter-1.3.0/tests/__init__.py
+42 files, 494444 bytes uncompressed, 134602 bytes compressed:  72.8%
```

## zipnote {}

```diff
@@ -1,127 +1,127 @@
-Filename: lightstreamer_adapter-1.2.3/
+Filename: lightstreamer_adapter-1.3.0/
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/doc/
+Filename: lightstreamer_adapter-1.3.0/doc/
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/lightstreamer_adapter/
+Filename: lightstreamer_adapter-1.3.0/lightstreamer_adapter/
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/lightstreamer_adapter.egg-info/
+Filename: lightstreamer_adapter-1.3.0/lightstreamer_adapter.egg-info/
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/tests/
+Filename: lightstreamer_adapter-1.3.0/tests/
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/architecture.png
+Filename: lightstreamer_adapter-1.3.0/architecture.png
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/HISTORY.rst
+Filename: lightstreamer_adapter-1.3.0/HISTORY.rst
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/LICENSE
+Filename: lightstreamer_adapter-1.3.0/LICENSE
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/MANIFEST.in
+Filename: lightstreamer_adapter-1.3.0/MANIFEST.in
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/PKG-INFO
+Filename: lightstreamer_adapter-1.3.0/PKG-INFO
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/README.rst
+Filename: lightstreamer_adapter-1.3.0/README.rst
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/setup.cfg
+Filename: lightstreamer_adapter-1.3.0/setup.cfg
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/setup.py
+Filename: lightstreamer_adapter-1.3.0/setup.py
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/doc/_static/
+Filename: lightstreamer_adapter-1.3.0/doc/_static/
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/doc/conf.py
+Filename: lightstreamer_adapter-1.3.0/doc/conf.py
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/doc/index.rst
+Filename: lightstreamer_adapter-1.3.0/doc/index.rst
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/doc/lightstreamer_adapter.interfaces.rst
+Filename: lightstreamer_adapter-1.3.0/doc/lightstreamer_adapter.interfaces.rst
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/doc/lightstreamer_adapter.rst
+Filename: lightstreamer_adapter-1.3.0/doc/lightstreamer_adapter.rst
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/doc/make.bat
+Filename: lightstreamer_adapter-1.3.0/doc/make.bat
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/doc/Makefile
+Filename: lightstreamer_adapter-1.3.0/doc/Makefile
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/doc/requirements.txt
+Filename: lightstreamer_adapter-1.3.0/doc/requirements.txt
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/doc/_static/classic.css
+Filename: lightstreamer_adapter-1.3.0/doc/_static/classic.css
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/lightstreamer_adapter/interfaces/
+Filename: lightstreamer_adapter-1.3.0/lightstreamer_adapter/interfaces/
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/lightstreamer_adapter/data_protocol.py
+Filename: lightstreamer_adapter-1.3.0/lightstreamer_adapter/data_protocol.py
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/lightstreamer_adapter/metadata_protocol.py
+Filename: lightstreamer_adapter-1.3.0/lightstreamer_adapter/metadata_protocol.py
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/lightstreamer_adapter/protocol.py
+Filename: lightstreamer_adapter-1.3.0/lightstreamer_adapter/protocol.py
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/lightstreamer_adapter/server.py
+Filename: lightstreamer_adapter-1.3.0/lightstreamer_adapter/server.py
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/lightstreamer_adapter/subscription.py
+Filename: lightstreamer_adapter-1.3.0/lightstreamer_adapter/subscription.py
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/lightstreamer_adapter/__init__.py
+Filename: lightstreamer_adapter-1.3.0/lightstreamer_adapter/__init__.py
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/lightstreamer_adapter/interfaces/data.py
+Filename: lightstreamer_adapter-1.3.0/lightstreamer_adapter/interfaces/data.py
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/lightstreamer_adapter/interfaces/metadata.py
+Filename: lightstreamer_adapter-1.3.0/lightstreamer_adapter/interfaces/metadata.py
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/lightstreamer_adapter/interfaces/__init__.py
+Filename: lightstreamer_adapter-1.3.0/lightstreamer_adapter/interfaces/__init__.py
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/lightstreamer_adapter.egg-info/dependency_links.txt
+Filename: lightstreamer_adapter-1.3.0/lightstreamer_adapter.egg-info/dependency_links.txt
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/lightstreamer_adapter.egg-info/PKG-INFO
+Filename: lightstreamer_adapter-1.3.0/lightstreamer_adapter.egg-info/PKG-INFO
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/lightstreamer_adapter.egg-info/SOURCES.txt
+Filename: lightstreamer_adapter-1.3.0/lightstreamer_adapter.egg-info/SOURCES.txt
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/lightstreamer_adapter.egg-info/top_level.txt
+Filename: lightstreamer_adapter-1.3.0/lightstreamer_adapter.egg-info/top_level.txt
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/tests/common.py
+Filename: lightstreamer_adapter-1.3.0/tests/common.py
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/tests/test_data.py
+Filename: lightstreamer_adapter-1.3.0/tests/test_data.py
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/tests/test_data_protocol.py
+Filename: lightstreamer_adapter-1.3.0/tests/test_data_protocol.py
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/tests/test_metadata.py
+Filename: lightstreamer_adapter-1.3.0/tests/test_metadata.py
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/tests/test_metadata_protocol.py
+Filename: lightstreamer_adapter-1.3.0/tests/test_metadata_protocol.py
 Comment: 
 
-Filename: lightstreamer_adapter-1.2.3/tests/__init__.py
+Filename: lightstreamer_adapter-1.3.0/tests/__init__.py
 Comment: 
 
 Zip file comment:
```

## Comparing `lightstreamer_adapter-1.2.3/architecture.png` & `lightstreamer_adapter-1.3.0/architecture.png`

 * *Files identical despite different names*

## Comparing `lightstreamer_adapter-1.2.3/HISTORY.rst` & `lightstreamer_adapter-1.3.0/HISTORY.rst`

 * *Files 21% similar despite different names*

```diff
@@ -1,14 +1,56 @@
 .. :changelog:
 
 Release History
 ---------------
 
 
+1.3.0 (2023-07-17)
+++++++++++++++++++
+
+**New Features**
+
+- Introduced the support for a single connection instead of two for the
+  communication of the Remote Data Adapters.
+  In fact, since Server version 7.4, the Proxy Data Adapter can (and should)
+  be configured to use a single connection for the communication.
+  Hence, the "address" argument of __init__ for the DataProviderServer class,
+  which is a tuple, can now have only 2 values (including one port); a tuple
+  with 3-values will now be refused.
+  As a consequence, if an existing Remote Server based on the previous
+  version of this SDK launches a Remote Data Adapter, it cannot be upgraded
+  to this new SDK version seamlessly.
+  The upgrade will require a change in the code to supply a single
+  port for the connection to the Proxy Data Adapter. This, in turn, will
+  require the configuration of a single port on the Proxy Data Adapter,
+  which is only possible with Lightstreamer Server 7.4 or later.
+  However, if a Remote Server only launches Remote Metadata Adapters,
+  the compatibility with Server version 7.3 is kept.
+
+- Thoroughly modified the supplied unit tests to implement the single-connection
+  behavior and the new compatibility rules.
+
+**Improvements**
+
+- Revised the supplied unit tests to clarifiy dequeueing from the sockets
+  and expected messages.
+
+- Clarified the meaning of a None or missing value for a "userMsg" argument
+  supplied in a CreditsError: an empty string should be sent to the client.
+  Note that, previously, the Server used to send the "null" string as a
+  placeholder. Hence, Adapters relying on this behavior should now supply
+  "null" explicitly.*
+
+**Lightstreamer Compatibility Notes**
+
+- Compatible with Adapter Remoting Infrastructure since Server version 7.4.
+
+
 1.2.3 (2023-03-21)
+++++++++++++++++++
 
 **Improvements**
 
 - Added handling of runtime exceptions in the internal threads, by submitting
   them to the exception handlers and extended the default handling of runtime
   exceptions by always showing the stack trace.
```

## Comparing `lightstreamer_adapter-1.2.3/LICENSE` & `lightstreamer_adapter-1.3.0/LICENSE`

 * *Files identical despite different names*

## Comparing `lightstreamer_adapter-1.2.3/PKG-INFO` & `lightstreamer_adapter-1.3.0/PKG-INFO`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: lightstreamer_adapter
-Version: 1.2.3
+Version: 1.3.0
 Summary: Lightstreamer SDK for Python Adapters
 Home-page: https://github.com/Lightstreamer/Lightstreamer-lib-python-adapter
 Author: Lightstreamer Srl
 Author-email: support@lightstreamer.com
 License: Apache License 2.0
 Keywords: lightstreamer push realtime real-time
 Classifier: Development Status :: 5 - Production/Stable
@@ -55,19 +55,18 @@
             <param name="request_reply_port">8003</param>
             <param name="timeout">36000000</param>
          </metadata_provider>
          <data_provider>
             <adapter_class>ROBUST_PROXY_FOR_REMOTE_ADAPTER</adapter_class>
             <classloader>log-enabled</classloader>
             <param name="request_reply_port">8001</param>
-            <param name="notify_port">8002</param>
             <param name="timeout">36000000</param>
          </data_provider>
       </adapters_conf>
-    
+
 4) Take note of the ports configured in the adapters.xml file as those are needed to write the remote part of the adapters.
 
 Write the Adapters
 ------------------
 
 Create a new python module, let's call it ``adapters.py``, where we will put  the minimal logic required to write a basic Adapter Set.
 
@@ -144,15 +143,15 @@
           
           # Starts the server instance.
           metadata_provider_server.start()
           
           # Creates a new DataProviderServer instance, passing a new MyDataAdpater
           # object and the remote address
           data_provider_sever = DataProviderServer(MyDataAdapter(),
-                                                   (LS_SERVER_HOST, 8001, 8002))
+                                                   (LS_SERVER_HOST, 8001))
           # Starts the server instance.
           data_provider_sever.start()
 
 5) Ensure that the main thread stays alive. This is needed, since Python 3.9, to allow the SDK library to take advantage of the system's ThreadPoolExecutor class. Here we show a simple way to do so:
 
    .. code-block:: python
    
@@ -184,15 +183,15 @@
     // ...
     
 where ``LS_SERVER_HOST`` is the host of the Lightstreamer Server, and ``"PROXY_PYTHON"`` is the Adapter Set ID as specified in the ``adapters.xml`` file.
     
 API Reference
 -------------
 
-API Reference is available at `<http://lightstreamer-lib-python-adapter.readthedocs.io/en/version-1.2.3>`_.
+API Reference is available at `<http://lightstreamer-lib-python-adapter.readthedocs.io/en/version-1.3.0>`_.
 
 You can generate it by executing the following command from the ``doc`` folder:
 
 .. code-block:: bash
 
    $ make html
    
@@ -208,28 +207,71 @@
 .. _Adapter Remoting Infrastructure Network Protocol Specification: https://lightstreamer.com/api/ls-generic-adapter/latest/ARI%20Protocol.pdf
 .. _Lightstreamer Chat Demo adapter for Python: https://github.com/Lightstreamer/Lightstreamer-example-Chat-adapter-python
 
 
 Lightstreamer Compatibility Notes
 =================================
 
-Compatible with Adapter Remoting Infrastructure since Server version 7.0 (corresponding to Adapter Remoting Infrastructure 1.8).
+Compatible with Adapter Remoting Infrastructure since Server version 7.4.
+- For a version of this library compatible with Adapter Remoting Infrastructure for Server version 7,3, please refer to `this tag`_.
+- For a version of this library compatible with Adapter Remoting Infrastructure for Server version 6.0 (corresponding to Adapter Remoting Infrastructure 1.7), please refer to `this older tag`_.
 
-- For a version of this library compatible with Adapter Remoting Infrastructure for Server version 6.0 (corresponding to Adapter Remoting Infrastructure 1.7), please refer to `this tag`_.
-
-.. _this tag: https://github.com/Lightstreamer/Lightstreamer-lib-python-adapter/tree/version-1.0.0post1-27
+.. _this tag: https://github.com/Lightstreamer/Lightstreamer-lib-python-adapter/tree/version-1.2.2
+.. _this older tag: https://github.com/Lightstreamer/Lightstreamer-lib-python-adapter/tree/version-1.0.0post1-27
 
 
 .. :changelog:
 
 Release History
 ---------------
 
 
+1.3.0 (2023-07-17)
+++++++++++++++++++
+
+**New Features**
+
+- Introduced the support for a single connection instead of two for the
+  communication of the Remote Data Adapters.
+  In fact, since Server version 7.4, the Proxy Data Adapter can (and should)
+  be configured to use a single connection for the communication.
+  Hence, the "address" argument of __init__ for the DataProviderServer class,
+  which is a tuple, can now have only 2 values (including one port); a tuple
+  with 3-values will now be refused.
+  As a consequence, if an existing Remote Server based on the previous
+  version of this SDK launches a Remote Data Adapter, it cannot be upgraded
+  to this new SDK version seamlessly.
+  The upgrade will require a change in the code to supply a single
+  port for the connection to the Proxy Data Adapter. This, in turn, will
+  require the configuration of a single port on the Proxy Data Adapter,
+  which is only possible with Lightstreamer Server 7.4 or later.
+  However, if a Remote Server only launches Remote Metadata Adapters,
+  the compatibility with Server version 7.3 is kept.
+
+- Thoroughly modified the supplied unit tests to implement the single-connection
+  behavior and the new compatibility rules.
+
+**Improvements**
+
+- Revised the supplied unit tests to clarifiy dequeueing from the sockets
+  and expected messages.
+
+- Clarified the meaning of a None or missing value for a "userMsg" argument
+  supplied in a CreditsError: an empty string should be sent to the client.
+  Note that, previously, the Server used to send the "null" string as a
+  placeholder. Hence, Adapters relying on this behavior should now supply
+  "null" explicitly.*
+
+**Lightstreamer Compatibility Notes**
+
+- Compatible with Adapter Remoting Infrastructure since Server version 7.4.
+
+
 1.2.3 (2023-03-21)
+++++++++++++++++++
 
 **Improvements**
 
 - Added handling of runtime exceptions in the internal threads, by submitting
   them to the exception handlers and extended the default handling of runtime
   exceptions by always showing the stack trace.
```

## Comparing `lightstreamer_adapter-1.2.3/README.rst` & `lightstreamer_adapter-1.3.0/README.rst`

 * *Files 3% similar despite different names*

```diff
@@ -34,19 +34,18 @@
             <param name="request_reply_port">8003</param>
             <param name="timeout">36000000</param>
          </metadata_provider>
          <data_provider>
             <adapter_class>ROBUST_PROXY_FOR_REMOTE_ADAPTER</adapter_class>
             <classloader>log-enabled</classloader>
             <param name="request_reply_port">8001</param>
-            <param name="notify_port">8002</param>
             <param name="timeout">36000000</param>
          </data_provider>
       </adapters_conf>
-    
+
 4) Take note of the ports configured in the adapters.xml file as those are needed to write the remote part of the adapters.
 
 Write the Adapters
 ------------------
 
 Create a new python module, let's call it ``adapters.py``, where we will put  the minimal logic required to write a basic Adapter Set.
 
@@ -123,15 +122,15 @@
           
           # Starts the server instance.
           metadata_provider_server.start()
           
           # Creates a new DataProviderServer instance, passing a new MyDataAdpater
           # object and the remote address
           data_provider_sever = DataProviderServer(MyDataAdapter(),
-                                                   (LS_SERVER_HOST, 8001, 8002))
+                                                   (LS_SERVER_HOST, 8001))
           # Starts the server instance.
           data_provider_sever.start()
 
 5) Ensure that the main thread stays alive. This is needed, since Python 3.9, to allow the SDK library to take advantage of the system's ThreadPoolExecutor class. Here we show a simple way to do so:
 
    .. code-block:: python
    
@@ -163,15 +162,15 @@
     // ...
     
 where ``LS_SERVER_HOST`` is the host of the Lightstreamer Server, and ``"PROXY_PYTHON"`` is the Adapter Set ID as specified in the ``adapters.xml`` file.
     
 API Reference
 -------------
 
-API Reference is available at `<http://lightstreamer-lib-python-adapter.readthedocs.io/en/version-1.2.3>`_.
+API Reference is available at `<http://lightstreamer-lib-python-adapter.readthedocs.io/en/version-1.3.0>`_.
 
 You can generate it by executing the following command from the ``doc`` folder:
 
 .. code-block:: bash
 
    $ make html
    
@@ -187,12 +186,13 @@
 .. _Adapter Remoting Infrastructure Network Protocol Specification: https://lightstreamer.com/api/ls-generic-adapter/latest/ARI%20Protocol.pdf
 .. _Lightstreamer Chat Demo adapter for Python: https://github.com/Lightstreamer/Lightstreamer-example-Chat-adapter-python
 
 
 Lightstreamer Compatibility Notes
 =================================
 
-Compatible with Adapter Remoting Infrastructure since Server version 7.0 (corresponding to Adapter Remoting Infrastructure 1.8).
-
-- For a version of this library compatible with Adapter Remoting Infrastructure for Server version 6.0 (corresponding to Adapter Remoting Infrastructure 1.7), please refer to `this tag`_.
+Compatible with Adapter Remoting Infrastructure since Server version 7.4.
+- For a version of this library compatible with Adapter Remoting Infrastructure for Server version 7,3, please refer to `this tag`_.
+- For a version of this library compatible with Adapter Remoting Infrastructure for Server version 6.0 (corresponding to Adapter Remoting Infrastructure 1.7), please refer to `this older tag`_.
 
-.. _this tag: https://github.com/Lightstreamer/Lightstreamer-lib-python-adapter/tree/version-1.0.0post1-27
+.. _this tag: https://github.com/Lightstreamer/Lightstreamer-lib-python-adapter/tree/version-1.2.2
+.. _this older tag: https://github.com/Lightstreamer/Lightstreamer-lib-python-adapter/tree/version-1.0.0post1-27
```

## Comparing `lightstreamer_adapter-1.2.3/setup.py` & `lightstreamer_adapter-1.3.0/setup.py`

 * *Files 4% similar despite different names*

```diff
@@ -17,15 +17,15 @@
     history = f.read()
 
 packages = ['lightstreamer_adapter',
             'lightstreamer_adapter.interfaces']
 
 setup(
     name='lightstreamer_adapter',
-    version='1.2.3',
+    version='1.3.0',
     description='Lightstreamer SDK for Python Adapters',
     long_description=readme + '\n\n' + history,
     url='https://github.com/Lightstreamer/Lightstreamer-lib-python-adapter',
     author='Lightstreamer Srl',
     author_email='support@lightstreamer.com',
     license='Apache License 2.0',
     packages=packages,
```

## Comparing `lightstreamer_adapter-1.2.3/doc/conf.py` & `lightstreamer_adapter-1.3.0/doc/conf.py`

 * *Files 0% similar despite different names*

```diff
@@ -55,17 +55,17 @@
 author = 'Author'
 
 # The version info for the project you're documenting, acts as replacement for
 # |version| and |release|, also used in various other places throughout the
 # built documents.
 #
 # The short X.Y version.
-version = '1.2.3'
+version = '1.3.0'
 # The full version, including alpha/beta/rc tags.
-release = '1.2.3'
+release = '1.3.0'
 
 # The language for content autogenerated by Sphinx. Refer to documentation
 # for a list of supported languages.
 #
 # This is also used if you do content translation via gettext catalogs.
 # Usually you set "language" from the command line for these cases.
 language = 'en'
```

## Comparing `lightstreamer_adapter-1.2.3/doc/lightstreamer_adapter.interfaces.rst` & `lightstreamer_adapter-1.3.0/doc/lightstreamer_adapter.interfaces.rst`

 * *Files identical despite different names*

## Comparing `lightstreamer_adapter-1.2.3/doc/lightstreamer_adapter.rst` & `lightstreamer_adapter-1.3.0/doc/lightstreamer_adapter.rst`

 * *Files identical despite different names*

## Comparing `lightstreamer_adapter-1.2.3/doc/make.bat` & `lightstreamer_adapter-1.3.0/doc/make.bat`

 * *Files identical despite different names*

## Comparing `lightstreamer_adapter-1.2.3/doc/Makefile` & `lightstreamer_adapter-1.3.0/doc/Makefile`

 * *Files identical despite different names*

## Comparing `lightstreamer_adapter-1.2.3/doc/_static/classic.css` & `lightstreamer_adapter-1.3.0/doc/_static/classic.css`

 * *Files identical despite different names*

## Comparing `lightstreamer_adapter-1.2.3/lightstreamer_adapter/data_protocol.py` & `lightstreamer_adapter-1.3.0/lightstreamer_adapter/data_protocol.py`

 * *Files identical despite different names*

## Comparing `lightstreamer_adapter-1.2.3/lightstreamer_adapter/metadata_protocol.py` & `lightstreamer_adapter-1.3.0/lightstreamer_adapter/metadata_protocol.py`

 * *Files identical despite different names*

## Comparing `lightstreamer_adapter-1.2.3/lightstreamer_adapter/protocol.py` & `lightstreamer_adapter-1.3.0/lightstreamer_adapter/protocol.py`

 * *Files 4% similar despite different names*

```diff
@@ -327,8 +327,11 @@
     if password is not None:
         parameters.append('password')
         parameters.append(encode_string(password))
 
     parameters.append('enableClosePacket')
     parameters.append(encode_string("true"))
 
+    parameters.append('SDK')
+    parameters.append(encode_string("Python Adapter SDK"))
+
     return join(str(method), 'S|') + '|S|'.join(parameters)
```

## Comparing `lightstreamer_adapter-1.2.3/lightstreamer_adapter/server.py` & `lightstreamer_adapter-1.3.0/lightstreamer_adapter/server.py`

 * *Files 4% similar despite different names*

```diff
@@ -64,31 +64,32 @@
         client_socket = sock
     client_socket.connect(address)
     return client_socket
 
 
 class _Sender():
     """Helper class which manages the communications from the Remote Adapter to
-    the ProxyAdapter, sending data over the "request/replies" or
-    "notifications" channels.
+    the ProxyAdapter, sending data over the "requests/replies" channels and/or
+    the "notifications" subchannel.
     """
 
     _STOP_WAITING_PILL = "STOP_WAITING_PILL"
 
     _KEEPALIVE_PILL = "KEEPALIVE_PILL"
 
     def __init__(self, name, sock, server, keepalive, log):
         self._sock = sock
         self._server = server
         self._name = name
         self._log = log
         self._keepalive = keepalive
-        self._keep_alive_log = logging.getLogger(log.name + ".keep_alives")
+        self._keep_alive_log = log
         self._send_queue = None
         self._send_thread = None
+        self._notification_log = log
 
     def start(self):
         """Starts the management of communications from the Remote Adapter to
         the Proxy Adapter.
         """
         # Creates a queue to append incoming replies/notifications to be sent
         # to the ProxyAdapter.
@@ -96,18 +97,22 @@
 
         # Starts new thread for dequeuing replies/notifications and then
         # sending to the ProxyAdapter.
         self._send_thread = Thread(target=self._do_run, name="Sender-Thread-{}"
                                    .format(self._name))
         self._send_thread.start()
 
-    def send(self, notification):
+    def send(self, message, is_notif):
         """Enqueues a reply or notification to be sent to the Proxy Adapter."""
-        self._log.debug("%s Enqueing line: %s", self._name, notification)
-        self._send_queue.put(notification)
+        if is_notif:
+            self._notification_log.debug("%s Enqueing line: %s",
+                                         self._name, message)
+        else:
+            self._log.debug("%s Enqueing line: %s", self._name, message)
+        self._send_queue.put(message)
 
     def _do_run(self):
         """Target method for the Sender-Thread-XXX, started in the start'
         method."""
         self._log.info("%s starting", self._name)
         while True:
             try:
@@ -157,30 +162,32 @@
         """Terminates the communications with the Proxy Adapter."""
         # Enqueues a None item to notify the Sender-Thread-XXX of stopping
         # dequeuing of incoming replies/notifications.
         self._send_queue.put(_Sender._STOP_WAITING_PILL)
         self._send_thread.join()
 
 
-class _RequestReceiver():
+class _RequestManager():
     """Helper class which manages the bi-directional communications with the
-    Proxy Adpater counterpart over the "request/replies" channel.
+    Proxy Adpater counterpart over the "requests/replies" channels.
     """
 
     def __init__(self, sock, keepalive, server):
         self._log = logging.getLogger("lightstreamer-adapter.requestreply"
                                       ".requests")
         self._sock = sock
         self._server = server
         reply_sender_log = logging.getLogger("lightstreamer-adapter."
-                                             "requestreply.replies."
-                                             "ReplySender")
+                                             "requestreply.replies")
+        keep_alive_log = logging.getLogger("lightstreamer-adapter."
+                                           "requestreply.keep_alives")
         self._reply_sender = _Sender(sock=sock, name=self._server.name,
                                      server=self._server,
                                      keepalive=keepalive, log=reply_sender_log)
+        self._reply_sender._keep_alive_log = keep_alive_log
         self._stop_request = Event()
 
         # Starts the reply sender.
         self._reply_sender.start()
 
     def startReceiving(self):
         """Starts the management of bidirectional communications with the Proxy
@@ -240,15 +247,20 @@
 
         self._log.info("Request receiver '%s' stopped", self._server.name)
 
     def send_reply(self, request_id, response):
         """Sends a reply to the Proxy Adapter.
         """
         reply = '|'.join((request_id, response))
-        self._reply_sender.send(reply)
+        self._reply_sender.send(reply, False)
+
+    def send_notify(self, ntfy):
+        """Sends a notification to the Proxy Adapter.
+        """
+        self._reply_sender.send(ntfy, True)
 
     def change_keep_alive(self, keepalive):
         self._reply_sender.change_keep_alive(keepalive)
 
     def quit(self):
         """Terminates the communications with the Proxy Adapter.
         """
@@ -318,15 +330,15 @@
             except NotImplementedError:
                 self._config['thread_pool_size'] = Server._DEFAULT_POOL_SIZE
         else:
             self._config['thread_pool_size'] = pool
 
         self._executor = ThreadPoolExecutor(self._config['thread_pool_size'])
         self._server_sock = None
-        self._request_receiver = None
+        self._request_manager = None
         self._ssl_context = ssl_context
 
     @property
     def name(self):
         """The name, used for logging purposes, associated to the Server
         instance.
 
@@ -393,61 +405,54 @@
 
         max_version = '1.8.3'
         parsed_data = subprotocol.read_init(data)
         parsed_data.setdefault(protocol.ARI_VERSION, None)
         parsed_data.setdefault(protocol.KEEPALIVE_HINTS, None)
         proxy_version = parsed_data[protocol.ARI_VERSION]
         keep_alive_hint = parsed_data[protocol.KEEPALIVE_HINTS]
+        advertised_version = None
         del parsed_data[protocol.ARI_VERSION]
         del parsed_data[protocol.KEEPALIVE_HINTS]
         try:
             if proxy_version is None:
                 proxy_version = '1.8.0'
                 self._log.info("Received no Proxy Adapter protocol version "
-                               "information; assuming 1.8.0: accepted.")
+                               "information; assuming 1.8.0.")
             elif proxy_version == '1.8.0':
-                raise Exception("Unsupported protocol version number: {}"
+                raise Exception("Unexpected protocol version number: {}"
                                 .format(proxy_version))
             elif proxy_version == '1.8.1':
                 raise Exception("Unsupported reserved protocol version "
                                 "number: {}".format(proxy_version))
-            elif proxy_version == '1.8.2':
-                self._log.info("Received Proxy Adapter protocol version as %s "
-                               "for %s: accepted downgrade.", proxy_version,
-                               self.name)
-            elif proxy_version == max_version:
-                self._log.info("Received Proxy Adapter protocol version as %s "
-                               "for %s: versions match", proxy_version,
-                               self.name)
-            else:
-                proxy_version = max_version
-                self._log.info("Received Proxy Adapter protocol version as %s "
-                               "for %s: requesting %s", proxy_version,
-                               self.name, max_version)
+            advertised_version = self.getSupportedVersion(proxy_version, max_version)
 
             if params is not None:
                 init_params = params.copy()
                 parsed_data.update(init_params)
 
             adapter.initialize(parsed_data, config_file)
             if invoke_listener is True:
                 adapter.set_listener(self)
         except Exception as err:
             res = subprotocol.write_init(exception=err)
         else:
             proxy_parameters = None
-            if proxy_version in ('1.8.0', '1.8.2'):
+            if advertised_version in ('1.8.0', '1.8.2'):
                 self._close_expected = False
-            if proxy_version != '1.8.0':
+            if advertised_version != '1.8.0':
                 proxy_parameters = {}
-                proxy_parameters[protocol.ARI_VERSION] = proxy_version
+                proxy_parameters[protocol.ARI_VERSION] = advertised_version
             res = subprotocol.write_init(proxy_parameters)
         self._use_keep_alive_hint(keep_alive_hint)
         return res
 
+    @abstractmethod
+    def getSupportedVersion(self, proxy_version, max_version):
+        return None
+
     def _use_keep_alive_hint(self, keepalive_hint=None):
         if keepalive_hint is None:
             # No information provided, we stick to a stricter default
             if self._configured_keep_alive is None:
                 self._log.info("Keepalive time for %s finally set to %d "
                                "milliseconds to support old Proxy Adapter",
                                self.name, self._STRICT_KEEPALIVE)
@@ -514,15 +519,15 @@
                                       "suggestion of %d milliseconds",
                                       self.name, Server._MIN_KEEPALIVE,
                                       keepalive_time)
 
     def _change_keep_alive(self, keep_alive_milliseconds):
         keep_alive_seconds = keep_alive_milliseconds / 1000
         self._config['keep_alive'] = keep_alive_seconds
-        self._request_receiver.change_keep_alive(keep_alive_seconds)
+        self._request_manager.change_keep_alive(keep_alive_seconds)
 
     @abstractmethod
     def start(self):
         """Starts the Remote Adapter. A connection to the Proxy Adapter is
         performed (as soon as one is available). Then, requests issued by
         the Proxy Adapter are received and forwarded to the Remote Adapter.
         """
@@ -531,41 +536,41 @@
                            self.name, self.keep_alive)
         else:
             self._log.info("Keepalive for %s disabled", self.name)
 
         self._server_sock = create_socket_and_connect(self._config['address'],
                                                       self._ssl_context)
 
-        # Creates and starts the Request Receiver.
-        self._request_receiver = _RequestReceiver(sock=self._server_sock,
-                                                  keepalive=self.keep_alive,
-                                                  server=self)
+        # Creates and starts the Request Manager.
+        self._request_manager = _RequestManager(sock=self._server_sock,
+                                                keepalive=self.keep_alive,
+                                                server=self)
         self._send_remote_credentials()
-        self._request_receiver.startReceiving()
+        self._request_manager.startReceiving()
 
-        # Invokes hook to notify subclass that the Request Receiver has been
+        # Invokes hook to notify subclass that the Request Manager has been
         # started.
-        self._on_request_receiver_started()
+        self._on_request_manager_started()
 
     def close(self):
         """Stops the management of the Remote Adapter and destroys the threads
         used by this Server. This instance can no longer be used.
 
         Note that this does not stop the supplied Remote Adapter, as no close
         method is available in the Remote Adapter interface. If the process is
         not terminating, then the Remote Adapter cleanup should be performed by
         accessing the supplied Adapter instance directly and calling custom
         methods.
         """
-        self._request_receiver.quit()
+        self._request_manager.quit()
         self._executor.shutdown()
         self._server_sock.close()
 
     def on_received_request(self, request):
-        """Invoked when the RequestReceiver gets a new request coming from the
+        """Invoked when the RequestManager gets a new request coming from the
         Proxy Adapter.
 
         This method takes the responsibility to proceed with a first
         coarse-grained parsing, to identify the three main components of the
         packet structure, as follows:
 
         <ID>|<method>|<data>
@@ -606,15 +611,15 @@
                                         "reason: %s", closed_reason)
             self.close()
             return
         self._handle_request(request_id, data, method_name)
 
     def _send_reply(self, request_id, response):
         self._log.debug("Sending reply for request: %s", request_id)
-        self._request_receiver.send_reply(request_id, response)
+        self._request_manager.send_reply(request_id, response)
 
     def on_ioexception(self, ioexception):
         """Called by the Remote Server upon a read or write operation failure.
 
         See documentation from the ExceptionHandler.handle_io exception method
         for further details.
         """
@@ -649,43 +654,46 @@
         os._exit(1)
         return False
 
     def _handle_exception(self, exception):
         return False
 
     @abstractmethod
-    def _on_request_receiver_started(self):
-        """Hook method to notify the subclass that the Request Receiver has
+    def _on_request_manager_started(self):
+        """Hook method to notify the subclass that the Request Manager has
         been started.
 
         This method is intended to be overridden by subclasses.
         """
 
     @abstractmethod
     def _handle_request(self, request_id, data, method_name):
         """Intended to be overridden by subclasses, invoked for handling the
         received request, already splitted into the supplied parameters.
         """
 
     def _send_remote_credentials(self):
-        """Invoked for sending the remote credentials to the Proxy Adapter
-        on the reply channel.
+        """Invoked for sending the remote credentials to the Proxy Adapter.
         """
 
         unsolicited_message = protocol.write_credentials(self.remote_user,
                                                          self.remote_password)
         self._send_reply("1", unsolicited_message)
 
 
 class MetadataProviderServer(Server):
     """A Remote Server object which can run a Remote Metadata Adapter and
     connect it to the Proxy Adapter running on Lightstreamer Server.
+    Note that since Server version 7.4 the Proxy Adapter also supports
+    connection inversion, that is, it can be configured to listen for
+    a connection issued by the Remote Server. This option is currently
+    not supported by this library.
 
     The object should be provided with a MetadataProvider instance and with
-    suitable initialization parameters and established connections,
+    suitable initialization parameters,
     then activated through :meth:`MetadataProviderServer.start` and finally
     disposed through :meth:`Server.close`.
     Further reuse of the same instance is not supported.
 
     By default, the invocations to the Metadata Adapter methods will be done in
     a limited thread pool with a size determined by the number of detected cpu
     cores. The size can be specified through the provided ``thread_pool_size``
@@ -710,15 +718,15 @@
 
         :param lightstreamer_adapter.interfaces.metadata.MetadataProvider \
         adapter: the Remote Metadata Adapter instance to be run.
         :param tuple address: the address of the Proxy Adapter supplied as a
          2-tuple ``(host, request_reply_port)`` where:
 
          * host: a string representing the hostname or the IP address
-         * request_reply_port: an int representing the request/reply port
+         * request_reply_port: an int representing the "request/reply" port
         :param str name: the name associated to the Server instance.
         :param float keep_alive: the keepalive interval expressed in seconds
          (or fractions)
         :param int thread_pool_size: the thread pool size
         :param SSLContext ssl_context: the SSL context to be used in the case
          of encrypted communications with the Proxy Adapter
         :raises TypeError: if the supplied Remote Adapter is not an instance of
@@ -733,16 +741,36 @@
                             "lightstreamer_adapter.interfaces."
                             "MetadataProvider")
         self._config_file = None
         self._params = None
         self._adapter = adapter
         self.init_expected = True
 
-    def _on_request_receiver_started(self):
-        """Invoked to notify this subclass that the Request Receiver has been
+    def getSupportedVersion(self, proxy_version, max_version):
+        # protocol versions up to 1.9.0 identify an old Server version
+        # which doesn't support single connection for Data Adapters;
+        # since this does not affect Metadata Adapters, we can accept
+        if proxy_version in ('1.8.0', '1.8.2'):
+            self._log.info("Received Proxy Adapter protocol version as %s "
+                           "for %s: accepted downgrade.", proxy_version,
+                           self.name)
+            return proxy_version
+        elif proxy_version == max_version:
+            self._log.info("Received Proxy Adapter protocol version as %s "
+                           "for %s: versions match", proxy_version,
+                           self.name)
+            return proxy_version
+        else:
+            self._log.info("Received Proxy Adapter protocol version as %s "
+                           "for %s: requesting %s", proxy_version,
+                           self.name, max_version)
+            return max_version
+
+    def _on_request_manager_started(self):
+        """Invoked to notify this subclass that the Request Manager has been
         started.
 
         This class has a void implementation.
         """
 
     def _handle_request(self, request_id, data, method_name):
         init_request = method_name == str(meta_protocol.Method.MPI)
@@ -1135,27 +1163,31 @@
             raise MetadataProviderError("Caught an error during the "
                                         "initialization phase") from err
 
 
 class DataProviderServer(Server):
     """A Remote Server object which can run a Remote Data Adapter and connect
     it to the Proxy Adapter running on Lightstreamer Server.
+    Note that since Server version 7.4 the Proxy Adapter also supports
+    connection inversion, that is, it can be configured to listen for
+    a connection issued by the Remote Server. This option is currently
+    not supported by this library.
 
     The object should be provided with a DataProvider instance and with
-    suitable initialization parameters and established connections, then
-    activated through :meth:`DataProviderServer.start()` and finally disposed
-    through :meth:`Server.close()`.
+    suitable initialization parameters,
+    then activated through :meth:`DataProviderServer.start()`
+    and finally disposed through :meth:`Server.close()`.
     Further reuse of the same instance is not supported.
 
     By default, the invocations to the Data Adapter methods will be done in
     a limited thread pool with a size determined by the number of detected cpu
     cores. The size can be specified through the provided
     ``thread_pool_size`` parameter. A size of 1 enforces strictly sequential
     invocations and can be used if parallelization of the calls is not
-    supported by the Metadata Adapter. A value of 0, negative or ``None`` also
+    supported by the Data Adapter. A value of 0, negative or ``None`` also
     implies the default behaviour as stated above.
 
     Note that :meth:`.subscribe` and :meth:`.unsubscribe` invocations for the
     same item are always guaranteed to be sequentialized in the right way,
     although they may not occur in the same thread.
     """
 
@@ -1163,20 +1195,19 @@
                  thread_pool_size=0, ssl_context=None):
         """Creates a server with the supplied configuration parameters. The
         initialize method of the Remote Adapter will be invoked only upon a
         Proxy Adapter request.
 
         :param lightstreamer_adapter.interfaces.data.DataProvider adapter: The
          Remote Adapter instance to be run.
-        :param tuple address: the address of the Proxy Adapter supplied as a
-         3-tuple ``(host, request_reply_port, notify_port)`` where:
+        :param tuple address: the address of the Proxy Data Adapter supplied
+         as a 2-tuple ``(host, request_reply_port)`` where:
 
          * host: a string representing the hostname or the IP address
-         * request_reply_port: an int representing the request/reply port
-         * notify_port: an int representing the notify port
+         * request_reply_port: an int representing the "request/reply" port
         :param str name: the name associated to the Server instance.
         :param float keep_alive: the keepalive interval expressed in seconds
          (or fractions)
         :param int thread_pool_size: the thread pool size
         :param SSLContext ssl_context: the SSL context to be used in the
          case of encrypted communications with the Proxy Adapter
         :raises TypeError: if the supplied Remote Adapter is not an instance of
@@ -1193,26 +1224,48 @@
             raise TypeError("The provided adapter is not a subclass of "
                             "lightstreamer_adapter.interfaces.DataProvider")
         self._config_file = None
         self._params = None
         self._adapter = adapter
         self._subscription_mgr = SubscriptionManager(self._executor)
         self.init_expected = True
-        self._notify_sender = None
-        self._notify_address = (address[0], address[2])
-        self._ntfy_sock = None
-
-    def _send_remote_credentials_on_notify(self):
-        """Invoked for sending the remote credentials to the Proxy Data
-        Adapter also on the notify channel.
-        """
-
-        unsolicited_message = protocol.write_credentials(self.remote_user,
-                                                         self.remote_password)
-        self._send_notify(unsolicited_message)
+        if len(address) > 2:
+            raise TypeError("Address tuple length longer than the expected 2;"
+                            " library upgrade without source code alignment?")
+
+    def getSupportedVersion(self, proxy_version, max_version):
+        # protocol versions up to 1.9.0 identify an old Server version
+        # which doesn't support single connection for Data Adapters;
+        # hence we prefer not to accept them, because, otherwise,
+        # the connection would fail anyway
+        if proxy_version == max_version:
+            self._log.info("Received Proxy Adapter protocol version as %s "
+                           "for %s: versions match but refused "
+                           "for Proxy Adapter incompatibility.",
+                           proxy_version, self.name)
+            raise Exception("Incompatible Proxy Adapter for protocol "
+                            "version: {}".format(proxy_version))
+        elif proxy_version.startswith('1.8.'):
+            self._log.info("Received Proxy Adapter protocol version as %s "
+                           "for %s: compatible but refused for Proxy Adapter "
+                           "incompatibility.", proxy_version, self.name)
+            raise Exception("Incompatible Proxy Adapter for protocol "
+                            "version: {}".format(proxy_version))
+        elif proxy_version == '1.9.0':
+            self._log.info("Received Proxy Adapter protocol version as %s "
+                           "for %s: downgrade possible but refused "
+                           "for Proxy Adapter incompatibility.",
+                           proxy_version, self.name)
+            raise Exception("Incompatible Proxy Adapter for protocol "
+                            "version: {}".format(proxy_version))
+        else:
+            self._log.info("Received Proxy Adapter protocol version as %s "
+                           "for %s: requesting %s", proxy_version,
+                           self.name, max_version)
+            return max_version
 
     def _handle_request(self, request_id, data, method_name):
         init_request = method_name == str(data_protocol.Method.DPI)
         if init_request and not self.init_expected:
             raise RemotingException("Unexpected late {} request"
                                     .format(str(data_protocol.Method.DPI)))
         if not init_request and self.init_expected:
@@ -1260,49 +1313,52 @@
         """
         return self._params
 
     @adapter_params.setter
     def adapter_params(self, value):
         self._params = value
 
-    def _on_request_receiver_started(self):
-        """Invoked to notify this subclass that the Request Receiver has been
+    def _on_request_manager_started(self):
+        """Invoked to notify this subclass that the Request Manager has been
         started.
 
         This method takes care of enabling the communication
         from the Remote Data Adapter to the Proxy Adapter, in order to send
-        data over the "notifications" channel.
-        This requires creating an additional socket.
+        data over the "notifications" subchannel.
+        This may require creating an additional socket, if the backward
+        compatibility configuration has been leveraged.
         """
 
-        self._ntfy_sock = create_socket_and_connect(self._notify_address,
-                                                    self._ssl_context)
-        notify_sender_log = logging.getLogger("lightstreamer-adapter."
-                                              "requestreply.notifications."
-                                              "NotifySender")
-        self._notify_sender = _Sender(sock=self._ntfy_sock, server=self,
-                                      name=self.name + " (Notify)",
-                                      keepalive=self.keep_alive,
-                                      log=notify_sender_log)
-        self._notify_sender.start()
-        self._send_remote_credentials_on_notify()
+        notification_log = logging.getLogger("lightstreamer-adapter."
+                                             "requestreply.notifications")
+
+        # we can send notifications through the inherited reply sender;
+        # the only difference is that the notifications
+        # should be logged by a dedicated logger
+        self._request_manager._reply_sender._notification_log = notification_log
 
     def _on_dpi(self, data):
         return self._on_init(data_protocol, self._params, self._config_file,
                              data, self._adapter, True)
 
     def _on_sub(self, request_id, data):
         item_name = data_protocol.read_sub(data)
 
         def do_task():
             DATA_LOGGER.debug("Processing SUB request: %s", request_id)
             success = False
             try:
                 snpt_available = self._adapter.issnapshot_available(item_name)
                 if snpt_available is False:
+                    # we have to send an empty snapshot;
+                    # this should be done before letting the Data Adapter start the subscription,
+                    # to ensure that the snapshot precedes the real time updates;
+                    # note that it also precedes the reply to the subscribe request,
+                    # hence it may even precede an unsuccessful reply,
+                    # but this is not forbidden by the ARI protocol
                     self.end_of_snapshot(item_name)
                 self._adapter.subscribe(item_name)
                 success = True
             except Exception as err:
                 res = data_protocol.write_sub(err)
             else:
                 res = data_protocol.write_sub()
@@ -1340,15 +1396,15 @@
             self._send_reply(request_id, res)
 
         unsub_task = ItemTask(request_id, False, do_task, do_late_task)
         self._subscription_mgr.do_unsubscription(item_name, unsub_task)
 
     @notify
     def _send_notify(self, ntfy):
-        self._notify_sender.send(ntfy)
+        self._request_manager.send_notify(ntfy)
 
     def update(self, item_name, events_map, issnapshot):
         request_id = self._subscription_mgr.get_active_item(item_name)
         if request_id:
             try:
                 res = data_protocol.write_update_map(item_name, request_id,
                                                      issnapshot, events_map)
@@ -1403,20 +1459,14 @@
             res = data_protocol.write_failure(exception)
             self._send_notify(res)
         except RemotingException:
             DATA_LOGGER.exception("Caught second-level exception while trying"
                                   " to notify a first-level exception")
         return False
 
-    def _change_keep_alive(self, keep_alive_milliseconds):
-        super(DataProviderServer, self)._change_keep_alive(
-                                                    keep_alive_milliseconds)
-        self._notify_sender.change_keep_alive(
-                                        keep_alive_milliseconds / 1000, True)
-
     def start(self):
         """Starts the Remote Data Adapter. A connection to the Proxy Adapter is
         performed (as soon as one is available). Then, requests issued by the
         Proxy Adapter are received and forwarded to the Remote Adapter.
 
         The requests are handled through a ThreadPoolExecutor. Since Python
         3.9, this requires that the main thread is kept active until close
@@ -1430,24 +1480,14 @@
                          " %d", self.name, self.thread_pool_size)
         try:
             super(DataProviderServer, self).start()
         except (TypeError, OSError) as err:
             raise DataProviderError("Caught an error during the "
                                     "initialization phase") from err
 
-    def close(self):
-        """Stops the management of the Remote Data Adapter attached to this
-        Server object.
-        The method first invokes the inherited Server.close() and then closes
-        the Notify Sender object.
-        """
-        super(DataProviderServer, self).close()
-        self._ntfy_sock.close()
-        self._notify_sender.quit()
-
 
 class ExceptionHandler(metaclass=ABCMeta):
     """An abstract class meant to to be implemented in order to provide a
     Remote Server instance with a custom handler for error conditions occurring
     on the     Remote Server.
 
     Note that multiple redundant invocations on the same Remote Server instance
```

## Comparing `lightstreamer_adapter-1.2.3/lightstreamer_adapter/subscription.py` & `lightstreamer_adapter-1.3.0/lightstreamer_adapter/subscription.py`

 * *Files identical despite different names*

## Comparing `lightstreamer_adapter-1.2.3/lightstreamer_adapter/interfaces/data.py` & `lightstreamer_adapter-1.3.0/lightstreamer_adapter/interfaces/data.py`

 * *Files identical despite different names*

## Comparing `lightstreamer_adapter-1.2.3/lightstreamer_adapter/interfaces/metadata.py` & `lightstreamer_adapter-1.3.0/lightstreamer_adapter/interfaces/metadata.py`

 * *Files 0% similar despite different names*

```diff
@@ -1107,16 +1107,18 @@
         text can also be specified.
 
         :param int client_error_code: Error code that can be used to
          distinguish the kind of problem. It must be a negative integer, or
          zero to mean an unspecified problem.
         :param str msg: the detail message.
         :param str user_msg: A detail message to be forwarded to the Client.
-         The message should be in simple ASCII, otherwise it might be altered
-         in order to be sent to the client; multiline text is also not allowed.
+         If ``None`` or missing, an empty string message will be forwarded.
+         The message is free, but if it is not in simple ASCII or if it is
+         multiline, it might be altered in order to be sent to very old
+         non-TLCP clients.
         """
         super(CreditsError, self).__init__(msg)
         self._code = client_error_code
         self._user_msg = user_msg
 
     @property
     def client_error_code(self):
@@ -1154,16 +1156,18 @@
         :param int client_error_code:  Error code that can be used to
          distinguish the kind of problem. It must be a negative integer, or
          zero to mean an unspecified problem.
         :param str msg: The detail message.
         :param str conflicting_session_id: ID of a Session that can be closed
          in order to eliminate the reported problem. It must not be null.
         :param str user_msg: A detail message to be forwarded to the Client.
-         The message should be in simple ASCII, otherwise it might be altered
-         in order to be sent to the client; multiline text is also not allowed.
+         If ``None`` or missing, an empty string message will be forwarded.
+         The message is free, but if it is not in simple ASCII or if it is
+         multiline, it might be altered in order to be sent to very old
+         non-TLCP clients.
         """
         super(ConflictingSessionError, self).__init__(code, msg, user_msg)
         self._conflicting_session_id = conflicting_session_id
 
     @property
     def conflicting_session_id(self):
         """The ID of a Session that can be closed in order to eliminate the
```

## Comparing `lightstreamer_adapter-1.2.3/lightstreamer_adapter.egg-info/PKG-INFO` & `lightstreamer_adapter-1.3.0/lightstreamer_adapter.egg-info/PKG-INFO`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: lightstreamer-adapter
-Version: 1.2.3
+Version: 1.3.0
 Summary: Lightstreamer SDK for Python Adapters
 Home-page: https://github.com/Lightstreamer/Lightstreamer-lib-python-adapter
 Author: Lightstreamer Srl
 Author-email: support@lightstreamer.com
 License: Apache License 2.0
 Keywords: lightstreamer push realtime real-time
 Classifier: Development Status :: 5 - Production/Stable
@@ -55,19 +55,18 @@
             <param name="request_reply_port">8003</param>
             <param name="timeout">36000000</param>
          </metadata_provider>
          <data_provider>
             <adapter_class>ROBUST_PROXY_FOR_REMOTE_ADAPTER</adapter_class>
             <classloader>log-enabled</classloader>
             <param name="request_reply_port">8001</param>
-            <param name="notify_port">8002</param>
             <param name="timeout">36000000</param>
          </data_provider>
       </adapters_conf>
-    
+
 4) Take note of the ports configured in the adapters.xml file as those are needed to write the remote part of the adapters.
 
 Write the Adapters
 ------------------
 
 Create a new python module, let's call it ``adapters.py``, where we will put  the minimal logic required to write a basic Adapter Set.
 
@@ -144,15 +143,15 @@
           
           # Starts the server instance.
           metadata_provider_server.start()
           
           # Creates a new DataProviderServer instance, passing a new MyDataAdpater
           # object and the remote address
           data_provider_sever = DataProviderServer(MyDataAdapter(),
-                                                   (LS_SERVER_HOST, 8001, 8002))
+                                                   (LS_SERVER_HOST, 8001))
           # Starts the server instance.
           data_provider_sever.start()
 
 5) Ensure that the main thread stays alive. This is needed, since Python 3.9, to allow the SDK library to take advantage of the system's ThreadPoolExecutor class. Here we show a simple way to do so:
 
    .. code-block:: python
    
@@ -184,15 +183,15 @@
     // ...
     
 where ``LS_SERVER_HOST`` is the host of the Lightstreamer Server, and ``"PROXY_PYTHON"`` is the Adapter Set ID as specified in the ``adapters.xml`` file.
     
 API Reference
 -------------
 
-API Reference is available at `<http://lightstreamer-lib-python-adapter.readthedocs.io/en/version-1.2.3>`_.
+API Reference is available at `<http://lightstreamer-lib-python-adapter.readthedocs.io/en/version-1.3.0>`_.
 
 You can generate it by executing the following command from the ``doc`` folder:
 
 .. code-block:: bash
 
    $ make html
    
@@ -208,28 +207,71 @@
 .. _Adapter Remoting Infrastructure Network Protocol Specification: https://lightstreamer.com/api/ls-generic-adapter/latest/ARI%20Protocol.pdf
 .. _Lightstreamer Chat Demo adapter for Python: https://github.com/Lightstreamer/Lightstreamer-example-Chat-adapter-python
 
 
 Lightstreamer Compatibility Notes
 =================================
 
-Compatible with Adapter Remoting Infrastructure since Server version 7.0 (corresponding to Adapter Remoting Infrastructure 1.8).
+Compatible with Adapter Remoting Infrastructure since Server version 7.4.
+- For a version of this library compatible with Adapter Remoting Infrastructure for Server version 7,3, please refer to `this tag`_.
+- For a version of this library compatible with Adapter Remoting Infrastructure for Server version 6.0 (corresponding to Adapter Remoting Infrastructure 1.7), please refer to `this older tag`_.
 
-- For a version of this library compatible with Adapter Remoting Infrastructure for Server version 6.0 (corresponding to Adapter Remoting Infrastructure 1.7), please refer to `this tag`_.
-
-.. _this tag: https://github.com/Lightstreamer/Lightstreamer-lib-python-adapter/tree/version-1.0.0post1-27
+.. _this tag: https://github.com/Lightstreamer/Lightstreamer-lib-python-adapter/tree/version-1.2.2
+.. _this older tag: https://github.com/Lightstreamer/Lightstreamer-lib-python-adapter/tree/version-1.0.0post1-27
 
 
 .. :changelog:
 
 Release History
 ---------------
 
 
+1.3.0 (2023-07-17)
+++++++++++++++++++
+
+**New Features**
+
+- Introduced the support for a single connection instead of two for the
+  communication of the Remote Data Adapters.
+  In fact, since Server version 7.4, the Proxy Data Adapter can (and should)
+  be configured to use a single connection for the communication.
+  Hence, the "address" argument of __init__ for the DataProviderServer class,
+  which is a tuple, can now have only 2 values (including one port); a tuple
+  with 3-values will now be refused.
+  As a consequence, if an existing Remote Server based on the previous
+  version of this SDK launches a Remote Data Adapter, it cannot be upgraded
+  to this new SDK version seamlessly.
+  The upgrade will require a change in the code to supply a single
+  port for the connection to the Proxy Data Adapter. This, in turn, will
+  require the configuration of a single port on the Proxy Data Adapter,
+  which is only possible with Lightstreamer Server 7.4 or later.
+  However, if a Remote Server only launches Remote Metadata Adapters,
+  the compatibility with Server version 7.3 is kept.
+
+- Thoroughly modified the supplied unit tests to implement the single-connection
+  behavior and the new compatibility rules.
+
+**Improvements**
+
+- Revised the supplied unit tests to clarifiy dequeueing from the sockets
+  and expected messages.
+
+- Clarified the meaning of a None or missing value for a "userMsg" argument
+  supplied in a CreditsError: an empty string should be sent to the client.
+  Note that, previously, the Server used to send the "null" string as a
+  placeholder. Hence, Adapters relying on this behavior should now supply
+  "null" explicitly.*
+
+**Lightstreamer Compatibility Notes**
+
+- Compatible with Adapter Remoting Infrastructure since Server version 7.4.
+
+
 1.2.3 (2023-03-21)
+++++++++++++++++++
 
 **Improvements**
 
 - Added handling of runtime exceptions in the internal threads, by submitting
   them to the exception handlers and extended the default handling of runtime
   exceptions by always showing the stack trace.
```

## Comparing `lightstreamer_adapter-1.2.3/lightstreamer_adapter.egg-info/SOURCES.txt` & `lightstreamer_adapter-1.3.0/lightstreamer_adapter.egg-info/SOURCES.txt`

 * *Files identical despite different names*

## Comparing `lightstreamer_adapter-1.2.3/tests/common.py` & `lightstreamer_adapter-1.3.0/tests/common.py`

 * *Files 18% similar despite different names*

```diff
@@ -8,146 +8,139 @@
 
 logging.basicConfig(level=logging.DEBUG)
 LOG = logging.getLogger("lightstreamer-test_server")
 
 
 class LightstreamerServerSimulator():
 
-    def __init__(self, req_reply_adr, notify_adr, enable_notify=False):
+    def __init__(self, req_reply_adr):
         self.main_thread = None
         # Request-Reply Socket
         self._rr_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
         self._rr_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
         self._rr_sock.bind(req_reply_adr)
         self._rr_sock.listen(1)
         self._rr_client_socket = None
-        self._ntfy_sock, self._ntfy_client_sock = None, None
-        if enable_notify is True:
-            self._ntfy_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-            self._ntfy_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR,
-                                       1)
-            self._ntfy_sock.bind(notify_adr)
-            self._ntfy_sock.listen(1)
-
-        self._semaphore = threading.Semaphore(0)
+        self._rr_socket_queue = None
 
     def _accept_connections(self):
         LOG.info("Listening at %s", self._rr_sock.getsockname())
         self._rr_client_socket, rr_client_addr = self._rr_sock.accept()
         LOG.info("Accepted connection from %s on %s", rr_client_addr,
                  self._rr_sock.getsockname())
         LOG.info("Listener at %s closed", self._rr_sock.getsockname())
+        self._rr_socket_queue = queue.Queue()
         self._rr_sock.close()
 
-        if self._ntfy_sock is not None:
-            LOG.info("Listening at %s", self._ntfy_sock.getsockname())
-            self._ntfy_client_sock, ntfy_client_addr = self._ntfy_sock.accept()
-            LOG.info("Accepted a connection from %s on %s", ntfy_client_addr,
-                     self._ntfy_sock.getsockname())
-            LOG.info("Listener at %s closed", self._ntfy_sock.getsockname())
-            self._ntfy_sock.close()
-
-        self._semaphore.release()
-
     def set_rr_socket_timeout(self, timeout):
         self._rr_client_socket.settimeout(timeout)
 
-    def set_notify_socket_timeout(self, timeout):
-        self._ntfy_client_sock.settimeout(timeout)
-
     def start(self):
         self.main_thread = threading.Thread(target=self._accept_connections,
                                             name="Simple Server Thread")
         self.main_thread.start()
         LOG.info("Started accepting new connections")
 
     def send_request(self, request):
         protocol_request = request + '\r\n'
         self._rr_client_socket.sendall(bytes(protocol_request, "utf-8"))
         LOG.info("Sent request: %s", protocol_request)
 
-    def receive_replies(self, skip_keepalive):
-        reply = self._read_from_socket(self._rr_client_socket, skip_keepalive,
-                                       split=False)
+    def receive_reply(self, skip_keepalive):
+        reply = self._get_next_message(skip_keepalive)
         LOG.info("Received reply: %s", reply)
         return reply
 
-    def receive_notifications(self, skip_keepalive):
-        notify = self._read_from_socket(self._ntfy_client_sock,
-                                        skip_keepalive, split=True)
-        LOG.info("Received notify: %s", notify)
-        return notify
+    def receive_notification(self, skip_keepalive):
+        notification = self._get_next_message(skip_keepalive)
+        notification = '|'.join(notification.split("|")[1:])
+        LOG.info("Received notify: %s", notification)
+        return notification
+
+    def skip_messages(self):
+        messages = self._get_curr_messages()
+        LOG.info("Skipping received messages: %s", messages)
+
+    def _get_curr_messages(self):
+        messages = []
+        self._rr_client_socket.settimeout(0.2)
+        msg = self._get_next_message(skip_keepalive=True)
+        self._rr_client_socket.settimeout(5)
+        while True:
+            messages.append(msg)
+            msg = self._get_next_message(skip_keepalive=False)
+            if msg == "KEEPALIVE":
+                return messages
+
+    def _get_next_message(self, skip_keepalive):
+        while True:
+            if self._rr_socket_queue.empty():
+                self._read_from_socket()
+            else:
+                msg = self._rr_socket_queue.get_nowait()
+                if not skip_keepalive or msg != 'KEEPALIVE':
+                    return msg
 
-    def _read_from_socket(self, sock, skip_keepalive, split):
+    def _read_from_socket(self):
         buffer = ''
-        notifications = []
         while True:
             LOG.debug("Reading from socket...")
-            more = sock.recv(1024)
+            more = self._rr_client_socket.recv(1024)
             LOG.debug("Received %d bytes of data", len(more))
             if not more:
                 raise EOFError('Socket connection broken')
             buffer += more.decode()
             tokens = buffer.splitlines(keepends=True)
-            for notify in tokens:
-                if notify.endswith('\r\n') and (not skip_keepalive or
-                                                notify.strip() != 'KEEPALIVE'):
-                    if split is True and notify.strip() != 'KEEPALIVE':
-                        notify = '|'.join(notify.split("|")[1:])
-                    notifications.append(notify.rstrip())
+            for line in tokens:
+                if line.endswith('\r\n'):
+                    self._rr_socket_queue.put(line.strip())
                     buffer = ''
                 else:
-                    buffer = notify
+                    # it must be an incomplete line
+                    # and it must be the last in tokens
+                    buffer = line
             if not buffer:
                 break
-        return notifications
 
     def stop(self):
         self._rr_client_socket.shutdown(socket.SHUT_WR)
-        if self._ntfy_client_sock is not None:
-            self._ntfy_client_sock.shutdown(socket.SHUT_WR)
 
 
 class RemoteAdapterBase(unittest.TestCase):
 
-    _HOST, _REQ_REPLY_PORT, _NOTIFY_PORT = 'localhost', 6662, 6663
+    _HOST, _REQ_REPLY_PORT = 'localhost', 6662
     _REQUEST_REPLY_ADDRESS = (_HOST, _REQ_REPLY_PORT)
-    _NOTIFY_ADDRESS = (_HOST, _NOTIFY_PORT)
     PROXY_METADATA_ADAPTER_ADDRESS = (_HOST, _REQ_REPLY_PORT)
-    PROXY_DATA_ADAPTER_ADDRESS = (_HOST, _REQ_REPLY_PORT, _NOTIFY_PORT)
+    PROXY_DATA_ADAPTER_ADDRESS = (_HOST, _REQ_REPLY_PORT)
 
     def setUp(self):
         LOG.info("\n\n========> Starting new test...")
         LOG.info("setUp for test " + self._testMethodName)
         self._remote_server = None
         self._exception_handler = None
         # Configures and starts the Lightstreamer Server simulator
         self._ls_server = LightstreamerServerSimulator(
-            RemoteAdapterBase._REQUEST_REPLY_ADDRESS,
-            RemoteAdapterBase._NOTIFY_ADDRESS,
-            self.is_enable_notify())
+            RemoteAdapterBase._REQUEST_REPLY_ADDRESS)
         self._ls_server.start()
         self.on_setup()
         LOG.info("setUp completed\n\n")
 
-    def is_enable_notify(self):
-        return False
-
     def on_setup(self):
         pass
 
     def on_teardown(self):
         pass
 
     def launch_remote_server(self, remote_server, set_exception_handler=False):
         self._remote_server = remote_server
         if set_exception_handler is True:
             self._remote_server.set_exception_handler(MyExceptionHandler())
         self._remote_server.start()
-        self._ls_server._semaphore.acquire()
+        # this opens the sockets
+        self._ls_server.main_thread.join()
 
     @property
     def remote_server(self):
         return self._remote_server
 
     def tearDown(self):
         if self._remote_server is not None:
@@ -155,43 +148,37 @@
             if self._remote_server._exception_handler is not None:
                 self._remote_server._exception_handler.join()
 
         # Stops the Lightstreamer Server Simulator
         self._ls_server.stop()
         LOG.info("Test completed")
 
-    def send_request(self, request, skip_reply=False):
+    def send_request(self, request):
         self._ls_server.send_request(request)
-        if skip_reply:
-            self._ls_server.receive_replies(skip_keepalive=True)
 
-    def receive_replies(self):
-        return self._ls_server.receive_replies(skip_keepalive=True)
+    def receive_reply(self):
+        self._ls_server.set_rr_socket_timeout(0.2)
+        return self._ls_server.receive_reply(skip_keepalive=True)
+
+    def receive_notification(self):
+        self._ls_server.set_rr_socket_timeout(0.5)
+        return self._ls_server.receive_notification(skip_keepalive=True)
 
-    def receive_notifications(self, skip_keepalive=True):
-        return self._ls_server.receive_notifications(skip_keepalive)
+    def skip_messages(self):
+        return self._ls_server.skip_messages()
 
     def assert_reply(self, expected=None, timeout=0.2, skip_keepalive=True):
         self._ls_server.set_rr_socket_timeout(timeout)
-        reply = self._ls_server.receive_replies(skip_keepalive)
-        self.assertEqual(len(reply), 1)
-        self.assertEqual(expected, reply[0])
-
-    def assert_not_reply(self, not_expected=None, timeout=0.2,
-                         skip_keepalive=True):
-        self._ls_server.set_rr_socket_timeout(timeout)
-        reply = self._ls_server.receive_replies(skip_keepalive)
-        self.assertEqual(len(reply), 1)
-        self.assertNotEqual(not_expected, reply[0])
+        reply = self._ls_server.receive_reply(skip_keepalive)
+        self.assertEqual(expected, reply)
 
     def assert_notify(self, expected=None, timeout=0.5, skip_keepalive=True):
-        self._ls_server.set_notify_socket_timeout(timeout)
-        notifications = self._ls_server.receive_notifications(skip_keepalive)
-        self.assertEqual(len(notifications), 1)
-        self.assertEqual(expected, notifications[0])
+        self._ls_server.set_rr_socket_timeout(timeout)
+        notification = self._ls_server.receive_notification(skip_keepalive)
+        self.assertEqual(expected, notification)
 
     def assert_caught_exception(self, msg):
         self.assertEqual(msg, self._remote_server._exception_handler.get())
 
     def assert_no_caught_exception(self):
         self.assertTrue(self._remote_server._exception_handler.empty())
```

## Comparing `lightstreamer_adapter-1.2.3/tests/test_data.py` & `lightstreamer_adapter-1.3.0/tests/test_data.py`

 * *Files 7% similar despite different names*

```diff
@@ -14,17 +14,22 @@
 
 logging.basicConfig(level=logging.DEBUG)
 LOG = logging.getLogger(__name__)
 
 # Specify here the number of your CPU cores
 EXPECTED_CPU_CORES = cpu_count()
 
+# Keep aligned with the ARI version currently implemented
+basic_version = '1.8.3'
+# Temporarily used because it is the only version accepted
+accepted_version = '1.9.1'
+
 def assert_credentials_response(remote_adapter):
-    remote_adapter.assert_reply("1|RAC|S|enableClosePacket|S|true")
-    remote_adapter.assert_notify("RAC|S|enableClosePacket|S|true")
+    remote_adapter.assert_reply("1|RAC|S|enableClosePacket|S|true"
+                                "|S|SDK|S|Python+Adapter+SDK")
 
 class DataProviderTestClass(DataProvider):
 
     def __init__(self, collector):
         self.collector = collector
         self.config_file = None
         self.subscribed = queue.Queue()
@@ -39,36 +44,40 @@
 
         self.collector['params'] = parameters
 
     def set_listener(self, event_listener):
         self.listener = event_listener
 
     def issnapshot_available(self, item_name):
-        return False
+        if "nosnap" in item_name:
+            return False
+            # this will cause the SDK library to send an EOS upon subscribe
+
+        return True
 
     def subscribe(self, item_name):
-        if item_name == "aapl_1":
+        if item_name == "item-err-1":
             raise SubscribeError("Subscription Error")
 
-        if item_name == "aapl_2":
+        if item_name == "item-err-2":
             raise FailureError("Failure Error")
 
-        if item_name == "aapl_3":
+        if item_name == "item-err-3":
             raise RuntimeError("Error")
 
         self.subscribed.put(item_name)
 
     def unsubscribe(self, item_name):
-        if item_name == "aapl_4":
+        if item_name == "item-err-4":
             raise SubscribeError("Subscription Error")
 
-        if item_name == "aapl_5":
+        if item_name == "item-err-5":
             raise FailureError("Failure Error")
 
-        if item_name == "aapl_6":
+        if item_name == "item-err-6":
             raise RuntimeError("Error")
         self.collector.update({'itemName': item_name})
 
 
 class DataProviderServerConstructionTest(unittest.TestCase):
 
     def test_start_with_error(self):
@@ -194,321 +203,358 @@
             keep_alive=keep_alive, name="DataProviderTest")
         remote_server.adapter_config = config
         remote_server.adapter_params = params
         remote_server.remote_user = username
         remote_server.remote_password = password
         self.launch_remote_server(remote_server)
 
-    def is_enable_notify(self):
-        return True
-
     def test_no_kalive_hint_and_no_configured_kalive(self):
         self.setup_remote_adapter()
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|DPI|S|adapters_conf.id|S|DEMO"
-                          "|S|data_provider.name|S|STOCKLIST")
-        self.assert_reply('10000010c3e4d0462|DPI|V')
+                          "|S|data_provider.name|S|STOCKLIST"
+                          "|S|ARI.version|S|" + accepted_version)
+        self.assert_reply("10000010c3e4d0462|DPI"
+                          "|S|ARI.version|S|" + basic_version)
         self.assertEqual(KeepaliveConstants.STRICTER.value,
                          self.remote_server.keep_alive)
 
     def test_no_kalive_hint_and_configured_kalive(self):
         configured_keepalive = 5
         self.setup_remote_adapter(configured_keepalive)
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|DPI|S|adapters_conf.id|S|DEMO"
-                          "|S|data_provider.name|S|STOCKLIST")
-        self.assert_reply('10000010c3e4d0462|DPI|V')
+                          "|S|data_provider.name|S|STOCKLIST"
+                          "|S|ARI.version|S|" + accepted_version)
+        self.assert_reply("10000010c3e4d0462|DPI"
+                          "|S|ARI.version|S|" + basic_version)
         self.assertIsNone(self.adapter.config_file)
         self.assertEqual(configured_keepalive, self.remote_server.keep_alive)
 
     def test_negative_kalive_hint_and_no_configured_kalive(self):
         self.setup_remote_adapter()
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|DPI|S|adapters_conf.id|S|DEMO"
                           "|S|data_provider.name|S|STOCKLIST|"
-                          "|S|keepalive_hint.millis|S|-510")
-        self.assert_reply('10000010c3e4d0462|DPI|V')
+                          "|S|keepalive_hint.millis|S|-510"
+                          "|S|ARI.version|S|" + accepted_version)
+        self.assert_reply("10000010c3e4d0462|DPI"
+                          "|S|ARI.version|S|" + basic_version)
         self.assertIsNone(self.adapter.config_file)
         self.assertEqual(KeepaliveConstants.DEFAULT.value,
                          self.remote_server.keep_alive)
 
     def test_negative_kalive_hint_and_configured_kalive(self):
         configured_keepalive = 6
         self.setup_remote_adapter(configured_keepalive)
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|DPI|S|adapters_conf.id|S|DEMO"
                           "|S|data_provider.name|S|STOCKLIST|"
-                          "|S|keepalive_hint.millis|S|-500")
-        self.assert_reply('10000010c3e4d0462|DPI|V')
+                          "|S|keepalive_hint.millis|S|-500"
+                          "|S|ARI.version|S|" + accepted_version)
+        self.assert_reply("10000010c3e4d0462|DPI"
+                          "|S|ARI.version|S|" + basic_version)
         self.assertIsNone(self.adapter.config_file)
         self.assertEqual(configured_keepalive, self.remote_server.keep_alive)
 
     def test_kalive_hint_lt_default_and_no_configured_kalive(self):
         expected_keepalive = 9
         self.setup_remote_adapter()
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|DPI|S|adapters_conf.id|S|DEMO"
                           "|S|data_provider.name|S|STOCKLIST"
-                          "|S|keepalive_hint.millis|S|9000")
-        self.assert_reply('10000010c3e4d0462|DPI|V')
+                          "|S|keepalive_hint.millis|S|9000"
+                          "|S|ARI.version|S|" + accepted_version)
+        self.assert_reply("10000010c3e4d0462|DPI"
+                          "|S|ARI.version|S|" + basic_version)
         self.assertIsNone(self.adapter.config_file)
         self.assertEqual(expected_keepalive, self.remote_server.keep_alive)
 
     def test_kalive_hint_lt_default_and_min_and_no_configured_kalive(self):
         self.setup_remote_adapter()
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|DPI|S|adapters_conf.id|S|DEMO"
                           "|S|data_provider.name|S|STOCKLIST"
-                          "|S|keepalive_hint.millis|S|500")
-        self.assert_reply('10000010c3e4d0462|DPI|V')
+                          "|S|keepalive_hint.millis|S|500"
+                          "|S|ARI.version|S|" + accepted_version)
+        self.assert_reply("10000010c3e4d0462|DPI"
+                          "|S|ARI.version|S|" + basic_version)
         self.assertIsNone(self.adapter.config_file)
         self.assertEqual(KeepaliveConstants.MIN.value,
                          self.remote_server.keep_alive)
 
     def test_kalive_hint_gt_default_and_no_configured_klive(self):
         self.setup_remote_adapter()
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|DPI|S|adapters_conf.id|S|DEMO"
                           "|S|keepalive_hint.millis|S|11000"
-                          "|S|data_provider.name|S|STOCKLIST")
-        self.assert_reply('10000010c3e4d0462|DPI|V')
+                          "|S|data_provider.name|S|STOCKLIST"
+                          "|S|ARI.version|S|" + accepted_version)
+        self.assert_reply("10000010c3e4d0462|DPI"
+                          "|S|ARI.version|S|" + basic_version)
         self.assertIsNone(self.adapter.config_file)
         self.assertEqual(KeepaliveConstants.DEFAULT.value,
                          self.remote_server.keep_alive)
 
     def test_kalive_lt_configured_klive(self):
         expected_keepalive = 4
         configured_keepalive = 5
         self.setup_remote_adapter(configured_keepalive)
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|DPI|S|adapters_conf.id|S|DEMO"
                           "|S|keepalive_hint.millis|S|4000"
-                          "|S|data_provider.name|S|STOCKLIST")
-        self.assert_reply('10000010c3e4d0462|DPI|V')
+                          "|S|data_provider.name|S|STOCKLIST"
+                          "|S|ARI.version|S|" + accepted_version)
+        self.assert_reply("10000010c3e4d0462|DPI"
+                          "|S|ARI.version|S|" + basic_version)
         self.assertIsNone(self.adapter.config_file)
         self.assertEqual(expected_keepalive, self.remote_server.keep_alive)
 
     def test_kalive_lt_configured_kalive_and_min(self):
         configured_keepalive = 5
         self.setup_remote_adapter(configured_keepalive)
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|DPI|S|adapters_conf.id|S|DEMO"
                           "|S|keepalive_hint.millis|S|500"
-                          "|S|data_provider.name|S|STOCKLIST")
-        self.assert_reply('10000010c3e4d0462|DPI|V')
+                          "|S|data_provider.name|S|STOCKLIST"
+                          "|S|ARI.version|S|" + accepted_version)
+        self.assert_reply("10000010c3e4d0462|DPI"
+                          "|S|ARI.version|S|" + basic_version)
         self.assertIsNone(self.adapter.config_file)
         self.assertEqual(KeepaliveConstants.MIN.value,
                          self.remote_server.keep_alive)
 
     def test_remote_credentials_with_user_and_password(self):
         self.setup_remote_adapter(username="remote1", password="fdhjkslghak")
-        self.assert_reply("1|RAC|S|user|S|remote1|S|password|S|fdhjkslghak|S|"
-                          "enableClosePacket|S|true")
-        self.assert_notify("RAC|S|user|S|remote1|S|password|S|fdhjkslghak|S|"
-                           "enableClosePacket|S|true")
+        self.assert_reply("1|RAC|S|user|S|remote1|S|password|S|fdhjkslghak"
+                          "|S|enableClosePacket|S|true"
+                          "|S|SDK|S|Python+Adapter+SDK")
 
     def test_remote_credentials_with_user(self):
         self.setup_remote_adapter(username="remote1")
-        self.assert_reply("1|RAC|S|user|S|remote1|S|enableClosePacket|S|true")
-        self.assert_notify("RAC|S|user|S|remote1|S|enableClosePacket|S|true")
+        self.assert_reply("1|RAC|S|user|S|remote1"
+                          "|S|enableClosePacket|S|true"
+                          "|S|SDK|S|Python+Adapter+SDK")
 
     def test_remote_credentials_with_password(self):
         self.setup_remote_adapter(password="fdhjkslghak")
-        self.assert_reply("1|RAC|S|password|S|fdhjkslghak|S|enableClosePacket|S|true")
-        self.assert_notify("RAC|S|password|S|fdhjkslghak|S|enableClosePacket|S|true")
+        self.assert_reply("1|RAC|S|password|S|fdhjkslghak"
+                          "|S|enableClosePacket|S|true"
+                          "|S|SDK|S|Python+Adapter+SDK")
 
     def test_remote_credentials_with_no_credentials(self):
         self.setup_remote_adapter()
-        self.assert_reply("1|RAC|S|enableClosePacket|S|true")
-        self.assert_notify("RAC|S|enableClosePacket|S|true")
+        self.assert_reply("1|RAC|S|enableClosePacket|S|true"
+                          "|S|SDK|S|Python+Adapter+SDK")
 
 
 class DataProviderServerTest(RemoteAdapterBase):
 
     def on_setup(self):
         self.collector = {}
         # Configuring and starting MetadataProviderServer
         self.adapter = DataProviderTestClass(self.collector)
         remote_server = DataProviderServer(
             adapter=self.adapter,
             address=RemoteAdapterBase.PROXY_DATA_ADAPTER_ADDRESS,
             name="DataProviderTest")
         self.launch_remote_server(remote_server)
 
-    def is_enable_notify(self):
-        return True
-
     def on_teardown(self):
         LOG.info("DataProviderTest completed")
 
     def do_subscription(self, item_name):
         self.send_request("10000010c3e4d0462|SUB|S|" + item_name)
 
     def do_subscription_with_request_id(self, request_id, item_name):
         self.send_request(request_id + "|SUB|S|" + item_name)
 
     def do_subscription_and_skip(self, item_name):
-        self.send_request("10000010c3e4d0462|SUB|S|" + item_name, True)
+        self.send_request("10000010c3e4d0462|SUB|S|" + item_name)
+        self.skip_messages()
 
     def do_unsubscription(self, item_name):
         self.send_request("10000010c3e4d0463|USB|S|" + item_name)
 
     def do_init(self):
-        self.send_request("10000010c3e4d0462|DPI")
+        self.send_request("10000010c3e4d0462|DPI"
+                          "|S|ARI.version|S|" + accepted_version)
 
     def do_init_and_skip(self):
         assert_credentials_response(self)
-        self.send_request("10000010c3e4d0462|DPI", True)
+        self.send_request("10000010c3e4d0462|DPI"
+                          "|S|ARI.version|S|" + accepted_version)
+        self.skip_messages()
 
-    def test_default_keep_alive_on_reply(self):
+    def test_default_keep_alive(self):
         assert_credentials_response(self)
         # Receive a KEEPALIVE message because no requests have been issued
         for _ in range(0, 1):
             start = time.time()
             self.assert_reply(expected="KEEPALIVE", timeout=11.1,
                               skip_keepalive=False)
             end = time.time()
             self.assertGreaterEqual(end - start, 0.99)
 
-    def test_default_keep_alive_on_notify(self):
-        assert_credentials_response(self)
-        # Receive a KEEPALIVE message because no updates have been issued
-        for _ in range(0, 1):
-            start = time.time()
-            self.assert_notify(expected="KEEPALIVE", timeout=11.1,
-                               skip_keepalive=False)
-            end = time.time()
-            self.assertGreaterEqual(end - start, 0.99)
-
     def test_no_keep_alive(self):
         # Initialization with no further configurations leads to a keepalive
         # time of 1 second.
         self.do_init_and_skip()
         # Receive a KEEPALIVE message because no request has been issued
         items = ["item1", "item2", "item3"]
         for item_name in items:
             # Wait for half the KEEPALIVE time
             time.sleep(0.5)
             self.do_subscription(item_name)
-            self.assert_not_reply("KEEPALIVE", skip_keepalive=False)
+            self.assert_reply("10000010c3e4d0462|SUB|V", timeout=0.2, skip_keepalive=False)
 
         # As no more requests have been issued, a period longer than 1 second
         # must have been elapsed, therefore we expect a KEEPALIVE message
         self.assert_reply("KEEPALIVE", timeout=1.1, skip_keepalive=False)
 
     def test_init(self):
         assert_credentials_response(self)
         self.do_init()
-        self.assert_reply("10000010c3e4d0462|DPI|V")
+        self.assert_reply("10000010c3e4d0462|DPI"
+                          "|S|ARI.version|S|" + basic_version)
         self.assertDictEqual({}, self.collector['params'])
         self.assertIsNotNone(self.adapter.listener)
 
     def test_init_with_adapter_config(self):
         self.remote_server.adapter_config = "config.file"
         self.do_init_and_skip()
         self.assertEqual("config.file", self.adapter.config_file)
 
     def test_init_with_local_params(self):
         self.remote_server.adapter_params = {"par1": "val1", "par2": "val2"}
         assert_credentials_response(self)
-        self.send_request("10000010c3e4d0462|DPI|")
+        self.send_request("10000010c3e4d0462|DPI"
+                          "|S|ARI.version|S|" + accepted_version)
 
-        self.assert_reply("10000010c3e4d0462|DPI|V")
+        self.assert_reply("10000010c3e4d0462|DPI"
+                          "|S|ARI.version|S|" + basic_version)
         self.assertDictEqual({"par1": "val1",
                               "par2": "val2"},
                              self.collector['params'])
 
     def test_init_with_remote_params(self):
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|DPI|S|adapters_conf.id|S|DEMO|S|"
-                          "data_provider.name|S|STOCKLIST")
-        self.assert_reply("10000010c3e4d0462|DPI|V")
+                          "data_provider.name|S|STOCKLIST"
+                          "|S|ARI.version|S|" + accepted_version)
+        self.assert_reply("10000010c3e4d0462|DPI"
+                          "|S|ARI.version|S|" + basic_version)
         self.assertDictEqual({"adapters_conf.id": "DEMO",
                               "data_provider.name": "STOCKLIST"},
                              self.collector['params'])
 
     def test_init_with_local_and_remote_params(self):
         self.remote_server.adapter_params = {"my_param.name": "my_local_param"}
         request = ("10000010c3e4d0462|DPI|S|adapters_conf.id|S|DEMO|S|"
-                   "data_provider.name|S|STOCKLIST")
+                   "data_provider.name|S|STOCKLIST"
+                   "|S|ARI.version|S|" + accepted_version)
         assert_credentials_response(self)
         self.send_request(request)
 
-        self.assert_reply("10000010c3e4d0462|DPI|V")
+        self.assert_reply("10000010c3e4d0462|DPI"
+                          "|S|ARI.version|S|" + basic_version)
         self.assertDictEqual({"adapters_conf.id": "DEMO",
                               "data_provider.name": "STOCKLIST",
                               "my_param.name": "my_local_param"},
                              self.collector['params'])
 
     def test_init_with_protocol_1_8_0(self):
         self.remote_server.adapter_params = {"data_provider.name":
                                              "my_local_provider"}
         assert_credentials_response(self)
-        self.send_request("10000010c3e4d0462|DPI|S|ARI.version|S|1.8.0|S|"
+        self.send_request("10000010c3e4d0462|DPI|S|"
                           "adapters_conf.id|S|DEMO|S|data_provider.name|S|"
                           "STOCKLIST")
-        self.assert_reply("10000010c3e4d0462|DPI|E|Unsupported+protocol+"
-                          "version+number%3A+1.8.0")
+
+        self.assert_reply("10000010c3e4d0462|DPI|E|Incompatible+Proxy+Adapter+"
+                          "for+protocol+version%3A+1.8.0")
         self.assertFalse('params' in self.collector)
 
     def test_init_with_protocol_1_8_1(self):
         self.remote_server.adapter_params = {"data_provider.name":
                                              "my_local_provider"}
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|DPI|S|ARI.version|S|1.8.1|S|"
                           "adapters_conf.id|S|DEMO|S|data_provider.name|S|"
                           "STOCKLIST")
+
         self.assert_reply("10000010c3e4d0462|DPI|E|Unsupported+reserved+"
                           "protocol+version+number%3A+1.8.1")
         self.assertFalse('params' in self.collector)
 
     def test_init_with_protocol_1_8_2(self):
         self.remote_server.adapter_params = {"data_provider.name":
                                              "my_local_provider"}
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|DPI|S|ARI.version|S|1.8.2|S|"
                           "adapters_conf.id|S|DEMO|S|data_provider.name|S|"
                           "STOCKLIST")
 
-        self.assert_reply("10000010c3e4d0462|DPI|S|ARI.version|S|1.8.2")
-
-        self.assertDictEqual({"adapters_conf.id": "DEMO",
-                              "data_provider.name": "my_local_provider"},
-                             self.collector['params'])
+        self.assert_reply("10000010c3e4d0462|DPI|E|Incompatible+Proxy+Adapter+"
+                          "for+protocol+version%3A+1.8.2")
+        self.assertFalse('params' in self.collector)
 
     def test_init_with_protocol_1_8_3(self):
         self.remote_server.adapter_params = {"data_provider.name":
                                              "my_local_provider"}
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|DPI|S|ARI.version|S|1.8.3|S|"
                           "adapters_conf.id|S|DEMO|S|data_provider.name|S|"
                           "STOCKLIST")
 
-        self.assert_reply("10000010c3e4d0462|DPI|S|ARI.version|S|1.8.3")
-
-        self.assertDictEqual({"adapters_conf.id": "DEMO",
-                              "data_provider.name": "my_local_provider"},
-                             self.collector['params'])
+        self.assert_reply("10000010c3e4d0462|DPI|E|Incompatible+Proxy+Adapter+"
+                          "for+protocol+version%3A+1.8.3")
+        self.assertFalse('params' in self.collector)
 
     def test_init_with_protocol_1_8_4(self):
         self.remote_server.adapter_params = {"data_provider.name":
                                              "my_local_provider"}
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|DPI|S|ARI.version|S|1.8.4|S|"
                           "adapters_conf.id|S|DEMO|S|data_provider.name|S|"
                           "STOCKLIST")
 
-        self.assert_reply("10000010c3e4d0462|DPI|S|ARI.version|S|1.8.3")
+        self.assert_reply("10000010c3e4d0462|DPI|E|Incompatible+Proxy+Adapter+"
+                          "for+protocol+version%3A+1.8.4")
+        self.assertFalse('params' in self.collector)
 
+    def test_init_with_protocol_1_9_0(self):
+        self.remote_server.adapter_params = {"data_provider.name":
+                                             "my_local_provider"}
+        assert_credentials_response(self)
+        self.send_request("10000010c3e4d0462|DPI|S|ARI.version|S|1.9.0|S|"
+                          "adapters_conf.id|S|DEMO|S|data_provider.name|S|"
+                          "STOCKLIST")
+
+        self.assert_reply("10000010c3e4d0462|DPI|E|Incompatible+Proxy+Adapter+"
+                          "for+protocol+version%3A+1.9.0")
+        self.assertFalse('params' in self.collector)
+
+    def test_init_with_protocol_1_9_1(self):
+        self.remote_server.adapter_params = {"data_provider.name":
+                                             "my_local_provider"}
+        assert_credentials_response(self)
+        self.send_request("10000010c3e4d0462|DPI|S|ARI.version|S|1.9.1|S|"
+                          "adapters_conf.id|S|DEMO|S|data_provider.name|S|"
+                          "STOCKLIST")
+
+        self.assert_reply("10000010c3e4d0462|DPI|S|ARI.version|S|1.8.3")
         self.assertDictEqual({"adapters_conf.id": "DEMO",
                               "data_provider.name": "my_local_provider"},
                              self.collector['params'])
 
     def test_malformed_init_for_unkown_token_type(self):
-        request = ("10000010c3e4d0462|DPI|H|adapters_conf.id|S|DEMO|S|"
+        request = ("10000010c3e4d0462|DPI"
+                   "|S|ARI.version|S|" + accepted_version +
+                   "|H|adapters_conf.id|S|DEMO|S|"
                    "data_provider.name|S|STOCKLIST")
         assert_credentials_response(self)
         self.send_request(request)
         self.assert_notify("FAL|E|Unknown+type+%27H%27+found+while+parsing+"
                            "DPI+request")
 
     def test_malformed_init_for_invalid_number_of_tokens(self):
@@ -533,263 +579,243 @@
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|DPI|S|id|S")
         self.assert_notify("FAL|E|Invalid+number+of+tokens+while+parsing+"
                            "DPI+request")
 
     def test_init_with_data_provider_exception(self):
         assert_credentials_response(self)
-        request = "10000010c3e4d0462|DPI|S|data_provider.name|S|STOCKLIST"
+        request = ("10000010c3e4d0462|DPI|S|data_provider.name|S|STOCKLIST"
+                   "|S|ARI.version|S|" + accepted_version)
         self.send_request(request)
         self.assert_reply("10000010c3e4d0462|DPI|ED|The+ID+must+be+supplied")
 
     def test_init_with_generic_exception(self):
         assert_credentials_response(self)
-        self.send_request("10000010c3e4d0462|DPI|S|adapters_conf.id|S|DEMO")
+        self.send_request("10000010c3e4d0462|DPI|S|adapters_conf.id|S|DEMO"
+                          "|S|ARI.version|S|" + accepted_version)
         self.assert_reply("10000010c3e4d0462|DPI|E|RuntimeError")
 
     def test_init_init(self):
         self.do_init_and_skip()
         self.do_init()
         self.assert_notify("FAL|E|Unexpected+late+DPI+request")
 
     def test_init_miss(self):
         assert_credentials_response(self)
         # Test error when the very first request is not a DPI request
-        self.do_subscription('aapl%5F')
+        self.do_subscription('item')
         self.assert_notify("FAL|E|Unexpected+request+SUB+while+waiting+for+DPI"
                            "+request")
 
     def test_close(self):
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|DPI|S|adapters_conf.id|S|DEMO|S|"
-                          "data_provider.name|S|STOCKLIST|S|ARI.version|S|1.8.3")
-        self.assert_reply("10000010c3e4d0462|DPI|S|ARI.version|S|1.8.3")
+                          "data_provider.name|S|STOCKLIST"
+                          "|S|ARI.version|S|" + accepted_version)
+        self.assert_reply("10000010c3e4d0462|DPI"
+                          "|S|ARI.version|S|" + basic_version)
         self.assertDictEqual({"adapters_conf.id": "DEMO",
                               "data_provider.name": "STOCKLIST"},
                              self.collector['params'])
 
         self.send_request("0|CLOSE|S|reason|S|any-reason")
         with self.assertRaises(Exception):
             self.assert_reply()
 
-    def test_close_not_recognized_because_of_protocol_1_8_0(self):
-        assert_credentials_response(self)
-        self.send_request("10000010c3e4d0462|DPI|S|adapters_conf.id|S|DEMO|S|"
-                          "data_provider.name|S|STOCKLIST")
-        self.assert_reply("10000010c3e4d0462|DPI|V")
-        self.assertDictEqual({"adapters_conf.id": "DEMO",
-                              "data_provider.name": "STOCKLIST"},
-                             self.collector['params'])
-
-        self.send_request("0|CLOSE|S|reason|S|any-reason")
-        with self.assertRaises(Exception):
-            self.assert_notify("FAL|E|Close+requested+by+the+counterpart+with+reason%3A+any-reason")
-
-    def test_close_not_recognized_because_of_protocol_1_8_2(self):
-        assert_credentials_response(self)
-        self.send_request("10000010c3e4d0462|DPI|S|adapters_conf.id|S|DEMO|S|"
-                          "data_provider.name|S|STOCKLIST|S|ARI.version|S|1.8.2")
-        self.assert_reply("10000010c3e4d0462|DPI|S|ARI.version|S|1.8.2")
-        self.assertDictEqual({"adapters_conf.id": "DEMO",
-                              "data_provider.name": "STOCKLIST"},
-                             self.collector['params'])
-
-        self.send_request("0|CLOSE|S|reason|S|any-reason")
-        with self.assertRaises(Exception):
-            self.assert_notify("FAL|E|Close+requested+by+the+counterpart+with+reason%3A+any-reason")
-
     def test_subscribe(self):
         self.do_init_and_skip()
-        self.do_subscription('aapl%5F')
+        self.do_subscription('item-nosnap')
+        # As snapshot is not available for this item, an EOS notification
+        # is also expected; the SDK library will send it even before
+        # the SUB reply, which is allowed
+        self.assert_notify("EOS|S|item-nosnap|S|10000010c3e4d0462")
         self.assert_reply("10000010c3e4d0462|SUB|V")
-        self.assert_notify("EOS|S|aapl_|S|10000010c3e4d0462")
         item_name = self.adapter.subscribed.get()
         self.adapter.subscribed.task_done()
-        self.assertEqual(item_name, "aapl_")
+        self.assertEqual(item_name, "item-nosnap")
 
     def test_subscribe_to_more_items(self):
         self.do_init_and_skip()
-        self.do_subscription_with_request_id("10000010c3e4d0462", 'aapl%5F')
+        self.do_subscription_with_request_id("10000010c3e4d0462", 'item1-nosnap')
+        # As snapshot is not available for this item, an EOS notification
+        # is also expected; the SDK library will send it even before
+        # the SUB reply, which is allowed
+        self.assert_notify("EOS|S|item1-nosnap|S|10000010c3e4d0462")
         self.assert_reply("10000010c3e4d0462|SUB|V")
-        self.assert_notify("EOS|S|aapl_|S|10000010c3e4d0462")
 
-        self.do_subscription_with_request_id("20000010c3e4d0462", 'saals%5F')
+        self.do_subscription_with_request_id("20000010c3e4d0462", 'item2-nosnap')
+        # As snapshot is not available for this item, an EOS notification
+        # is also expected; the SDK library will send it even before
+        # the SUB reply, which is allowed
+        self.assert_notify("EOS|S|item2-nosnap|S|20000010c3e4d0462")
         self.assert_reply("20000010c3e4d0462|SUB|V")
-        self.assert_notify("EOS|S|saals_|S|20000010c3e4d0462")
 
-        self.do_subscription_with_request_id("30000010c3e4d0462", 'paals%5F')
+        self.do_subscription_with_request_id("30000010c3e4d0462", 'item3-nosnap')
+        # As snapshot is not available for this item, an EOS notification
+        # is also expected; the SDK library will send it even before
+        # the SUB reply, which is allowed
+        self.assert_notify("EOS|S|item3-nosnap|S|30000010c3e4d0462")
         self.assert_reply("30000010c3e4d0462|SUB|V")
-        self.assert_notify("EOS|S|paals_|S|30000010c3e4d0462")
 
     def test_subscribe_with_subscribe_exception(self):
         self.do_init_and_skip()
-        self.do_subscription('aapl%5F1')
+        self.do_subscription('item-err-1')
         self.assert_reply("10000010c3e4d0462|SUB|EU|Subscription+Error")
 
     def test_subscribe_with_failure_exception(self):
         self.do_init_and_skip()
-        self.do_subscription('aapl%5F2')
+        self.do_subscription('item-err-2')
         self.assert_reply("10000010c3e4d0462|SUB|EF|Failure+Error")
 
     def test_subscribe_with_genieric_exception(self):
         self.do_init_and_skip()
-        self.do_subscription('aapl%5F3')
+        self.do_subscription('item-err-3')
         self.assert_reply("10000010c3e4d0462|SUB|E|Error")
 
     def test_malformed_subscribe(self):
         self.do_init_and_skip()
-        self.send_request("10000010c3e4d0462|SUB|S1|item_name")
+        self.send_request("10000010c3e4d0462|SUB|S1|item")
         self.assert_notify("FAL|E|Unknown+type+%27S1%27+found+while+parsing+"
                            "SUB+request")
         self.send_request("10000010c3e4d0462|SUB|S||")
         self.assert_notify("FAL|E|Token+not+found+while+parsing+SUB+request")
 
     def test_unsubscribe(self):
         self.do_init_and_skip()
-        self.do_subscription_and_skip('aapl%5F')
+        self.do_subscription_and_skip('item')
         item_name = self.adapter.subscribed.get()
         self.adapter.subscribed.task_done()
-        self.assertEqual(item_name, "aapl_")
-        self.do_unsubscription('aapl%5F')
+        self.assertEqual(item_name, "item")
+        self.do_unsubscription('item')
         self.assert_reply("10000010c3e4d0463|USB|V")
 
     def test_unsubscribe_with_unsubscribe_exception(self):
         self.do_init_and_skip()
-        self.do_subscription_and_skip('aapl%5F4')
-        self.do_unsubscription('aapl%5F4')
+        self.do_subscription_and_skip('item-err-4')
+        self.do_unsubscription('item-err-4')
         self.assert_reply("10000010c3e4d0463|USB|EU|Subscription+Error")
 
     def test_unsubscribe_with_failure_exception(self):
         self.do_init_and_skip()
-        self.do_subscription_and_skip('aapl%5F5')
-        self.do_unsubscription('aapl%5F5')
+        self.do_subscription_and_skip('item-err-5')
+        self.do_unsubscription('item-err-5')
         self.assert_reply("10000010c3e4d0463|USB|EF|Failure+Error")
 
     def test_unsubscribe_with_genieric_exception(self):
         self.do_init_and_skip()
-        self.do_subscription_and_skip('aapl%5F6')
-        self.do_unsubscription('aapl%5F6')
+        self.do_subscription_and_skip('item-err-6')
+        self.do_unsubscription('item-err-6')
         self.assert_reply("10000010c3e4d0463|USB|E|Error")
 
     def test_unsubscribe_without_subscription(self):
         self.do_init_and_skip()
-        self.do_unsubscription('aapl%5F')
+        self.do_unsubscription('item')
         with self.assertRaises(Exception):
             self.assert_reply(timeout=0.5)
         LOG.exception("Timeout expired")
 
     def test_malformed_unsubscribe(self):
         self.do_init_and_skip()
-        self.send_request("10000010c3e4d0462|USB|S1|item_name")
+        self.send_request("10000010c3e4d0462|USB|S1|item")
         self.assert_notify("FAL|E|Unknown+type+%27S1%27+found+while+parsing+"
                            "USB+request")
         self.send_request("10000010c3e4d0462|USB|S||")
         self.assert_notify("FAL|E|Token+not+found+while+parsing+USB+request")
 
     def test_eos(self):
         self.do_init_and_skip()
-        self.do_subscription_and_skip('aapl%5F')
-        # As snapshot is not available, an EOS is expected on the notify
-        # channel
-        self.assert_notify("EOS|S|aapl_|S|10000010c3e4d0462")
-        self.adapter.listener.end_of_snapshot("aapl_")
-        self.assert_notify("EOS|S|aapl_|S|10000010c3e4d0462")
+        self.do_subscription_and_skip('item')
+        self.adapter.listener.end_of_snapshot("item")
+        self.assert_notify("EOS|S|item|S|10000010c3e4d0462")
 
     def test_cls(self):
         self.do_init_and_skip()
-        self.do_subscription_and_skip('aapl%5F')
-        # As snapshot is not available, an EOS is expected on the notify
-        # channel
-        self.assert_notify("EOS|S|aapl_|S|10000010c3e4d0462")
+        self.do_subscription_and_skip('item-nosnap')
+        # As snapshot is not available for this item, an EOS notification
+        # is also expected, but it is skipped as well
 
-        self.adapter.listener.clear_snapshot("aapl_")
-        self.assert_notify("CLS|S|aapl_|S|10000010c3e4d0462")
+        self.adapter.listener.clear_snapshot("item-nosnap")
+        self.assert_notify("CLS|S|item-nosnap|S|10000010c3e4d0462")
 
     def test_update_with_str_value(self):
         self.do_init_and_skip()
-        self.do_subscription_and_skip("item1")
-        # As snapshot is not available, an EOS is expected on the notify
-        # channel
-        self.assert_notify("EOS|S|item1|S|10000010c3e4d0462")
+        self.do_subscription_and_skip("item-nosnap")
+        # As snapshot is not available for this item, an EOS notification
+        # is also expected, but it is skipped as well
 
         # Usage of OrderdDict with the only purpose of respecting the order
         # expressed in the assert statement.
         events_map = OrderedDict([("field1", "value1"),
                                   ("field2", "value2")])
-        self.adapter.listener.update("item1", events_map, False)
+        self.adapter.listener.update("item-nosnap", events_map, False)
 
-        self.assert_notify("UD3|S|item1|S|10000010c3e4d0462|B|0|S|field1|S"
+        self.assert_notify("UD3|S|item-nosnap|S|10000010c3e4d0462|B|0|S|field1|S"
                            "|value1|S|field2|S|value2")
 
     def test_massive_update(self):
         self.do_init_and_skip()
-        self.do_subscription_and_skip("item1")
-
-        # Skip first data received on the notification channel because of
-        # unavailability of snapshot
-        self.receive_notifications()
+        self.do_subscription_and_skip("item-nosnap")
+        # As snapshot is not available for this item, an EOS notification
+        # is also expected, but it is skipped as well
 
         # Usage of OrderdDict with the only purpose of respecting the order
         # expressed in the assert statement.
         for i in range(0, 1000):
             events_map = OrderedDict([("field1", "value1"),
                                       ("field2", str(i))])
 
-            self.adapter.listener.update("item1", events_map, False)
-            self.assert_notify("UD3|S|item1|S|10000010c3e4d0462|B|0|S|field1|S"
+            self.adapter.listener.update("item-nosnap", events_map, False)
+            self.assert_notify("UD3|S|item-nosnap|S|10000010c3e4d0462|B|0|S|field1|S"
                                "|value1|S|field2|S|{}".format(i))
 
     def test_update_with_byte_value(self):
         self.do_init_and_skip()
-        self.do_subscription_and_skip("aapl")
-        # As snapshot is not available, an EOS is expected on the notify
-        # channel
-        self.assert_notify("EOS|S|aapl|S|10000010c3e4d0462")
+        self.do_subscription_and_skip("item-nosnap")
+        # As snapshot is not available for this item, an EOS notification
+        # is also expected, but it is skipped as well
 
         # Usage of OrderdDict with the only purpose of respecting the order
         # expressed in the assert statement.
         events_map = OrderedDict([("pct_change", b'0.44'),
                                   ("last_price", b'6.82'),
                                   ("time", b'12:48:24')])
-        self.adapter.listener.update('aapl', events_map, True)
+        self.adapter.listener.update('item-nosnap', events_map, True)
 
-        self.assert_notify("UD3|S|aapl|S|10000010c3e4d0462|B|1|S|pct_change|"
+        self.assert_notify("UD3|S|item-nosnap|S|10000010c3e4d0462|B|1|S|pct_change|"
                            "Y|MC40NA==|S|last_price|Y|Ni44Mg==|S|time|Y|"
                            "MTI6NDg6MjQ=")
 
     def test_update_with_none_value(self):
         self.do_init_and_skip()
-        self.do_subscription_and_skip("aapl")
-        # As snapshot is not available, an EOS is expected on the notify
-        # channel
-        self.assert_notify("EOS|S|aapl|S|10000010c3e4d0462")
+        self.do_subscription_and_skip("item-nosnap")
+        # As snapshot is not available for this item, an EOS notification
+        # is also expected, but it is skipped as well
 
         # Usage of OrderdDict with the only purpose of respecting the order
         # expressed in the assert statement.
         events_map = OrderedDict([("pct_change", b'0.44'),
                                   ("last_price", b'6.82'),
                                   ("time", None)])
-        self.adapter.listener.update('aapl', events_map, True)
-        self.assert_notify("UD3|S|aapl|S|10000010c3e4d0462|B|1|S|pct_change|"
+        self.adapter.listener.update('item-nosnap', events_map, True)
+        self.assert_notify("UD3|S|item-nosnap|S|10000010c3e4d0462|B|1|S|pct_change|"
                            "Y|MC40NA==|S|last_price|Y|Ni44Mg==|S|time|S|#")
 
     def test_update_with_empty_value(self):
         self.do_init_and_skip()
-        self.do_subscription_and_skip("aapl")
-        # As snapshot is not available, an EOS is expected on the notify
-        # channel
-        self.assert_notify("EOS|S|aapl|S|10000010c3e4d0462")
+        self.do_subscription_and_skip("item-nosnap")
+        # As snapshot is not available for this item, an EOS notification
+        # is also expected, but it is skipped as well
 
         # Usage of OrderdDict with the only purpose of respecting the order
         # expressed in the assert statement.
         events_map = OrderedDict([("pct_change", b'0.44'),
                                   ("last_price", b'6.82'),
                                   ("time", "")])
-        self.adapter.listener.update('aapl', events_map, True)
-        self.assert_notify("UD3|S|aapl|S|10000010c3e4d0462|B|1|S|pct_change|"
+        self.adapter.listener.update('item-nosnap', events_map, True)
+        self.assert_notify("UD3|S|item-nosnap|S|10000010c3e4d0462|B|1|S|pct_change|"
                            "Y|MC40NA==|S|last_price|Y|Ni44Mg==|S|time|S|$")
 
     def test_failure(self):
         self.do_init_and_skip()
         self.adapter.listener.failure(Exception("Generic exception"))
         self.assert_notify("FAL|E|Generic+exception")
```

## Comparing `lightstreamer_adapter-1.2.3/tests/test_data_protocol.py` & `lightstreamer_adapter-1.3.0/tests/test_data_protocol.py`

 * *Files 2% similar despite different names*

```diff
@@ -168,18 +168,24 @@
             data_protocol.write_update_map("item1", "10000010c3e4d0462", None,
                                            {})
 
         self.assertEqual("Not a bool value: 'None'", str(err.exception))
 
     def test_credentials(self):
         res = protocol.write_credentials("remote1", "fdhjkslghak")
-        self.assertEqual("RAC|S|user|S|remote1|S|password|S|fdhjkslghak|S|"
-                         "enableClosePacket|S|true", res)
+        self.assertEqual("RAC|S|user|S|remote1|S|password|S|fdhjkslghak"
+                         "|S|enableClosePacket|S|true"
+                         "|S|SDK|S|Python+Adapter+SDK", res)
 
         res = protocol.write_credentials("remote1")
-        self.assertEqual("RAC|S|user|S|remote1|S|enableClosePacket|S|true", res)
+        self.assertEqual("RAC|S|user|S|remote1"
+                         "|S|enableClosePacket|S|true"
+                         "|S|SDK|S|Python+Adapter+SDK", res)
 
         res = protocol.write_credentials(password="fdhjkslghak")
-        self.assertEqual("RAC|S|password|S|fdhjkslghak|S|enableClosePacket|S|true", res)
+        self.assertEqual("RAC|S|password|S|fdhjkslghak"
+                         "|S|enableClosePacket|S|true"
+                         "|S|SDK|S|Python+Adapter+SDK", res)
 
         res = protocol.write_credentials()
-        self.assertEqual("RAC|S|enableClosePacket|S|true", res)
+        self.assertEqual("RAC|S|enableClosePacket|S|true"
+                         "|S|SDK|S|Python+Adapter+SDK", res)
```

## Comparing `lightstreamer_adapter-1.2.3/tests/test_metadata.py` & `lightstreamer_adapter-1.3.0/tests/test_metadata.py`

 * *Files 2% similar despite different names*

```diff
@@ -16,18 +16,21 @@
                                                        TableInfo,
                                                        MpnSubscriptionInfo)
 from .common import (RemoteAdapterBase, KeepaliveConstants)
 
 # Specify here the number of your CPU cores
 EXPECTED_CPU_CORES = cpu_count()
 
+# Keep aligned with the ARI version currently implemented
+basic_version = '1.8.3'
 
 
 def assert_credentials_response(remote_adapter):
-    remote_adapter.assert_reply("1|RAC|S|enableClosePacket|S|true")
+    remote_adapter.assert_reply("1|RAC|S|enableClosePacket|S|true"
+                                "|S|SDK|S|Python+Adapter+SDK")
 
 class MetadataProviderTestClass(MetadataProvider):
 
     def __init__(self, collector):
         self.collector = collector
         self.config_file = None
 
@@ -608,128 +611,148 @@
         remote_server.remote_user = username
         remote_server.remote_password = password
         self.launch_remote_server(remote_server, set_exception_handler=True)
 
     def do_init_and_skip(self):
         # RAC reply always received.
         assert_credentials_response(self)
-        self.send_request("10000010c3e4d0462|MPI", True)
+        self.send_request("10000010c3e4d0462|MPI"
+                          "|S|ARI.version|S|" + basic_version)
+        self.skip_messages()
 
     def test_no_kalive_hint_and_no_configured_kalive(self):
         self.setup_remote_adapter()
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|MPI|S|adapters_conf.id|S|DEMO"
-                          "|S|proxy.instance_id|S|hewbc3ikbbctyui")
-        self.assert_reply('10000010c3e4d0462|MPI|V')
+                          "|S|proxy.instance_id|S|hewbc3ikbbctyui"
+                          "|S|ARI.version|S|" + basic_version)
+        self.assert_reply("10000010c3e4d0462|MPI"
+                          "|S|ARI.version|S|" + basic_version)
         self.assertEqual({"adapters_conf.id": "DEMO", "proxy.instance_id":
                           "hewbc3ikbbctyui"}, self.collector['params'])
         self.assertIsNone(self.adapter.config_file)
 
         self.assertEqual(KeepaliveConstants.STRICTER.value,
                          self.remote_server.keep_alive)
 
     def test_no_kalive_hint_and_configured_kalive(self):
         configured_keepalive = 5
         self.setup_remote_adapter(configured_keepalive)
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|MPI|S|adapters_conf.id|S|DEMO"
-                          "|S|proxy.instance_id|S|hewbc3ikbbctyui")
-        self.assert_reply('10000010c3e4d0462|MPI|V')
+                          "|S|proxy.instance_id|S|hewbc3ikbbctyui"
+                          "|S|ARI.version|S|" + basic_version)
+        self.assert_reply("10000010c3e4d0462|MPI"
+                          "|S|ARI.version|S|" + basic_version)
         self.assertEqual({"adapters_conf.id": "DEMO", "proxy.instance_id":
                           "hewbc3ikbbctyui"}, self.collector['params'])
         self.assertIsNone(self.adapter.config_file)
         self.assertEqual(configured_keepalive, self.remote_server.keep_alive)
 
     def test_negative_kalive_hint_and_no_configured_kalive(self):
         self.setup_remote_adapter()
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|MPI|S|adapters_conf.id|S|DEMO"
                           "|S|keepalive_hint.millis|S|-510"
-                          "|S|proxy.instance_id|S|hewbc3ikbbctyui")
-        self.assert_reply('10000010c3e4d0462|MPI|V')
+                          "|S|proxy.instance_id|S|hewbc3ikbbctyui"
+                          "|S|ARI.version|S|" + basic_version)
+        self.assert_reply("10000010c3e4d0462|MPI"
+                          "|S|ARI.version|S|" + basic_version)
         self.assertEqual({"adapters_conf.id": "DEMO", "proxy.instance_id":
                           "hewbc3ikbbctyui"}, self.collector['params'])
         self.assertIsNone(self.adapter.config_file)
         self.assertEqual(KeepaliveConstants.DEFAULT.value,
                          self.remote_server.keep_alive)
 
     def test_negative_kalive_hint_and_configured_kalive(self):
         configured_keepalive = 6
         self.setup_remote_adapter(configured_keepalive)
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|MPI|S|adapters_conf.id|S|DEMO"
                           "|S|keepalive_hint.millis|S|-500"
-                          "|S|proxy.instance_id|S|hewbc3ikbbctyui")
-        self.assert_reply('10000010c3e4d0462|MPI|V')
+                          "|S|proxy.instance_id|S|hewbc3ikbbctyui"
+                          "|S|ARI.version|S|" + basic_version)
+        self.assert_reply("10000010c3e4d0462|MPI"
+                          "|S|ARI.version|S|" + basic_version)
         self.assertEqual({"adapters_conf.id": "DEMO", "proxy.instance_id":
                           "hewbc3ikbbctyui"}, self.collector['params'])
         self.assertIsNone(self.adapter.config_file)
         self.assertEqual(configured_keepalive, self.remote_server.keep_alive)
 
     def test_kalive_hint_lt_default_and_no_configured_kalive(self):
         expected_keepalive = 9
         self.setup_remote_adapter()
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|MPI|S|adapters_conf.id|S|DEMO|S|"
                           "keepalive_hint.millis|S|9000"
-                          "|S|proxy.instance_id|S|hewbc3ikbbctyui")
-        self.assert_reply('10000010c3e4d0462|MPI|V')
+                          "|S|proxy.instance_id|S|hewbc3ikbbctyui"
+                          "|S|ARI.version|S|" + basic_version)
+        self.assert_reply("10000010c3e4d0462|MPI"
+                          "|S|ARI.version|S|" + basic_version)
         self.assertEqual({"adapters_conf.id": "DEMO", "proxy.instance_id":
                           "hewbc3ikbbctyui"}, self.collector['params'])
         self.assertIsNone(self.adapter.config_file)
         self.assertEqual(expected_keepalive, self.remote_server.keep_alive)
 
     def test_kalive_hint_lt_default_and_min_and_no_configured_kalive(self):
         self.setup_remote_adapter()
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|MPI|S|adapters_conf.id|S|DEMO|S|"
                           "keepalive_hint.millis|S|500"
-                          "|S|proxy.instance_id|S|hewbc3ikbbctyui")
-        self.assert_reply('10000010c3e4d0462|MPI|V')
+                          "|S|proxy.instance_id|S|hewbc3ikbbctyui"
+                          "|S|ARI.version|S|" + basic_version)
+        self.assert_reply("10000010c3e4d0462|MPI"
+                          "|S|ARI.version|S|" + basic_version)
         self.assertEqual({"adapters_conf.id": "DEMO", "proxy.instance_id":
                           "hewbc3ikbbctyui"}, self.collector['params'])
         self.assertIsNone(self.adapter.config_file)
         self.assertEqual(KeepaliveConstants.MIN.value,
                          self.remote_server.keep_alive)
 
     def test_kalive_hint_gt_default_and_no_configured_kalive(self):
         self.setup_remote_adapter()
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|MPI|S|adapters_conf.id|S|DEMO"
                           "|S|keepalive_hint.millis|S|11000"
-                          "|S|proxy.instance_id|S|hewbc3ikbbctyui")
-        self.assert_reply('10000010c3e4d0462|MPI|V')
+                          "|S|proxy.instance_id|S|hewbc3ikbbctyui"
+                          "|S|ARI.version|S|" + basic_version)
+        self.assert_reply("10000010c3e4d0462|MPI"
+                          "|S|ARI.version|S|" + basic_version)
         self.assertEqual({"adapters_conf.id": "DEMO", "proxy.instance_id":
                           "hewbc3ikbbctyui"}, self.collector['params'])
         self.assertIsNone(self.adapter.config_file)
         self.assertEqual(KeepaliveConstants.DEFAULT.value,
                          self.remote_server.keep_alive)
 
     def test_kalive_lt_configured_kalive(self):
         expected_keepalive = 4
         configured_keepalive = 5
         self.setup_remote_adapter(configured_keepalive)
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|MPI|S|adapters_conf.id|S|DEMO|S|"
                           "keepalive_hint.millis|S|4000"
-                          "|S|proxy.instance_id|S|hewbc3ikbbctyui")
-        self.assert_reply('10000010c3e4d0462|MPI|V')
+                          "|S|proxy.instance_id|S|hewbc3ikbbctyui"
+                          "|S|ARI.version|S|" + basic_version)
+        self.assert_reply("10000010c3e4d0462|MPI"
+                          "|S|ARI.version|S|" + basic_version)
         self.assertEqual({"adapters_conf.id": "DEMO", "proxy.instance_id":
                           "hewbc3ikbbctyui"}, self.collector['params'])
         self.assertIsNone(self.adapter.config_file)
         self.assertEqual(expected_keepalive, self.remote_server.keep_alive)
 
     def test_kalive_less_then_configured_kalive_and_min(self):
         configured_keepalive = 5
         self.setup_remote_adapter(configured_keepalive)
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|MPI|S|adapters_conf.id|S|DEMO"
                           "|S|keepalive_hint.millis|S|500"
-                          "|S|proxy.instance_id|S|hewbc3ikbbctyui")
-        self.assert_reply('10000010c3e4d0462|MPI|V')
+                          "|S|proxy.instance_id|S|hewbc3ikbbctyui"
+                          "|S|ARI.version|S|" + basic_version)
+        self.assert_reply("10000010c3e4d0462|MPI"
+                          "|S|ARI.version|S|" + basic_version)
         self.assertEqual({"adapters_conf.id": "DEMO", "proxy.instance_id":
                           "hewbc3ikbbctyui"}, self.collector['params'])
         self.assertIsNone(self.adapter.config_file)
         self.assertEqual(KeepaliveConstants.MIN.value,
                          self.remote_server.keep_alive)
 
     def test_default_keep_alive(self):
@@ -742,103 +765,164 @@
             end = time.time()
             self.assertGreaterEqual(end - start, 1.99)
 
     def test_init(self):
         self.setup_remote_adapter()
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|MPI|S|adapters_conf.id|S|DEMO|S|"
-                          "proxy.instance_id|S|hewbc3ikbbctyui")
+                          "proxy.instance_id|S|hewbc3ikbbctyui"
+                          "|S|ARI.version|S|" + basic_version)
 
-        self.assert_reply('10000010c3e4d0462|MPI|V')
+        self.assert_reply("10000010c3e4d0462|MPI"
+                          "|S|ARI.version|S|" + basic_version)
         self.assertEqual({"adapters_conf.id": "DEMO", "proxy.instance_id":
                           "hewbc3ikbbctyui"}, self.collector['params'])
         self.assertIsNone(self.adapter.config_file)
 
     def test_init_with_adapter_config(self):
         self.setup_remote_adapter(config="config.file")
         self.do_init_and_skip()
         self.assertEqual("config.file", self.adapter.config_file)
 
     def test_init_with_local_params(self):
         self.setup_remote_adapter()
         assert_credentials_response(self)
         self.remote_server.adapter_params = {"par1": "val1", "par2": "val2"}
-        self.send_request("10000010c3e4d0462|MPI")
+        self.send_request("10000010c3e4d0462|MPI"
+                          "|S|ARI.version|S|" + basic_version)
 
-        self.assert_reply("10000010c3e4d0462|MPI|V")
+        self.assert_reply("10000010c3e4d0462|MPI"
+                          "|S|ARI.version|S|" + basic_version)
         self.assertDictEqual({"par1": "val1",
                               "par2": "val2"},
                              self.collector['params'])
 
     def test_init_with_remote_params(self):
         self.setup_remote_adapter()
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|MPI|S|adapters_conf.id|S|DEMO|S|"
-                          "proxy.instance_id|S|hewbc3ikbbctyui")
+                          "proxy.instance_id|S|hewbc3ikbbctyui"
+                          "|S|ARI.version|S|" + basic_version)
 
-        self.assert_reply("10000010c3e4d0462|MPI|V")
+        self.assert_reply("10000010c3e4d0462|MPI"
+                          "|S|ARI.version|S|" + basic_version)
         self.assertDictEqual({"adapters_conf.id": "DEMO",
                               "proxy.instance_id": "hewbc3ikbbctyui"},
                              self.collector['params'])
 
     def test_init_with_local_and_remote_params(self):
         self.setup_remote_adapter()
         assert_credentials_response(self)
         self.remote_server.adapter_params = {"proxy.instance_id":
                                              "my_local_meta_provider"}
         self.send_request("10000010c3e4d0462|MPI|S|adapters_conf.id|S|DEMO|S|"
-                          "proxy.instance_id|S|hewbc3ikbbctyui")
+                          "proxy.instance_id|S|hewbc3ikbbctyui"
+                          "|S|ARI.version|S|" + basic_version)
+        self.assert_reply("10000010c3e4d0462|MPI"
+                          "|S|ARI.version|S|" + basic_version)
+        self.assertDictEqual({"adapters_conf.id": "DEMO",
+                              "proxy.instance_id":
+                              "my_local_meta_provider"},
+                             self.collector['params'])
+
+    def test_init_with_protocol_1_8_0(self):
+        self.setup_remote_adapter(params={"proxy.instance_id":
+                                          "my_local_meta_provider"})
+        assert_credentials_response(self)
+        self.send_request("10000010c3e4d0462|MPI|S|"
+                          "adapters_conf.id|S|DEMO|S|proxy.instance_id|S|"
+                          "hewbc3ikbbctyui")
         self.assert_reply("10000010c3e4d0462|MPI|V")
         self.assertDictEqual({"adapters_conf.id": "DEMO",
                               "proxy.instance_id":
                               "my_local_meta_provider"},
                              self.collector['params'])
 
-    def test_init_with_protocol_version(self):
+    def test_init_with_protocol_1_8_1(self):
+        self.setup_remote_adapter(params={"proxy.instance_id":
+                                          "my_local_meta_provider"})
+        assert_credentials_response(self)
+        self.send_request("10000010c3e4d0462|MPI|S|ARI.version|S|1.8.1|S|"
+                          "adapters_conf.id|S|DEMO|S|proxy.instance_id|S|"
+                          "hewbc3ikbbctyui")
+        self.assert_reply("10000010c3e4d0462|MPI|E|Unsupported+reserved+"
+                          "protocol+version+number%3A+1.8.1")
+        self.assertFalse('params' in self.collector)
+
+    def test_init_with_protocol_1_8_2(self):
         self.setup_remote_adapter(params={"proxy.instance_id":
                                           "my_local_meta_provider"})
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|MPI|S|ARI.version|S|1.8.2|S|"
                           "adapters_conf.id|S|DEMO|S|proxy.instance_id|S|"
                           "hewbc3ikbbctyui")
         self.assert_reply("10000010c3e4d0462|MPI|S|ARI.version|S|1.8.2")
         self.assertDictEqual({"adapters_conf.id": "DEMO",
                               "proxy.instance_id":
                               "my_local_meta_provider"},
                              self.collector['params'])
 
-    def test_init_with_protocol_version_above_1_8_2(self):
+    def test_init_with_protocol_1_8_3(self):
+        self.setup_remote_adapter(params={"proxy.instance_id":
+                                          "my_local_meta_provider"})
+        assert_credentials_response(self)
+        self.send_request("10000010c3e4d0462|MPI|S|ARI.version|S|1.8.3|S|"
+                          "adapters_conf.id|S|DEMO|S|proxy.instance_id|S|"
+                          "hewbc3ikbbctyui")
+        self.assert_reply("10000010c3e4d0462|MPI|S|ARI.version|S|1.8.3")
+        self.assertDictEqual({"adapters_conf.id": "DEMO",
+                              "proxy.instance_id":
+                              "my_local_meta_provider"},
+                             self.collector['params'])
+
+    def test_init_with_protocol_1_8_4(self):
         self.setup_remote_adapter(params={"proxy.instance_id":
                                           "my_local_meta_provider"})
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|MPI|S|ARI.version|S|1.8.4|S|"
                           "adapters_conf.id|S|DEMO|S|proxy.instance_id|S|"
                           "hewbc3ikbbctyui")
         self.assert_reply("10000010c3e4d0462|MPI|S|ARI.version|S|1.8.3")
         self.assertDictEqual({"adapters_conf.id": "DEMO",
                               "proxy.instance_id":
                               "my_local_meta_provider"},
                              self.collector['params'])
 
-    def test_init_with_unsupported_protocol_version(self):
+    def test_init_with_protocol_1_9_0(self):
         self.setup_remote_adapter(params={"proxy.instance_id":
                                           "my_local_meta_provider"})
         assert_credentials_response(self)
-        self.send_request("10000010c3e4d0462|MPI|S|ARI.version|S|1.8.1|S|"
+        self.send_request("10000010c3e4d0462|MPI|S|ARI.version|S|1.9.0|S|"
                           "adapters_conf.id|S|DEMO|S|proxy.instance_id|S|"
                           "hewbc3ikbbctyui")
-        self.assert_reply("10000010c3e4d0462|MPI|E|Unsupported+reserved+"
-                          "protocol+version+number%3A+1.8.1")
-        self.assertFalse('params' in self.collector)
+        self.assert_reply("10000010c3e4d0462|MPI|S|ARI.version|S|1.8.3")
+        self.assertDictEqual({"adapters_conf.id": "DEMO",
+                              "proxy.instance_id":
+                              "my_local_meta_provider"},
+                             self.collector['params'])
+
+    def test_init_with_protocol_1_9_1(self):
+        self.setup_remote_adapter(params={"proxy.instance_id":
+                                          "my_local_meta_provider"})
+        assert_credentials_response(self)
+        self.send_request("10000010c3e4d0462|MPI|S|ARI.version|S|1.9.1|S|"
+                          "adapters_conf.id|S|DEMO|S|proxy.instance_id|S|"
+                          "hewbc3ikbbctyui")
+        self.assert_reply("10000010c3e4d0462|MPI|S|ARI.version|S|1.8.3")
+        self.assertDictEqual({"adapters_conf.id": "DEMO",
+                              "proxy.instance_id":
+                              "my_local_meta_provider"},
+                             self.collector['params'])
 
     def test_init_with_metadata_provider_exception(self):
         self.setup_remote_adapter()
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|MPI|S|proxy.instance_id|S|"
-                          "hewbc3ikbbctyui")
+                          "hewbc3ikbbctyui"
+                          "|S|ARI.version|S|" + basic_version)
         self.assert_reply("10000010c3e4d0462|MPI|EM|The+ID+must+be+supplied")
 
     def test_init_with_generic_exception(self):
         self.setup_remote_adapter()
         assert_credentials_response(self)
         self.send_request("10000010c3e4d0462|MPI|S|adapters_conf.id|S|DEMO")
         self.assert_reply("10000010c3e4d0462|MPI|E|Exception")
@@ -894,16 +978,18 @@
 
         self.assert_caught_exception("Unexpected request NUS while waiting for"
                                      " MPI request")
 
     def test_close(self):
         self.setup_remote_adapter()
         assert_credentials_response(self)
-        self.send_request("10000010c3e4d0462|MPI|S|ARI.version|S|1.8.3")
-        self.assert_reply('10000010c3e4d0462|MPI|S|ARI.version|S|1.8.3')
+        self.send_request("10000010c3e4d0462|MPI"
+                          "|S|ARI.version|S|" + basic_version)
+        self.assert_reply("10000010c3e4d0462|MPI"
+                          "|S|ARI.version|S|" + basic_version)
 
         self.send_request("0|CLOSE|S|reason|S|any-reason")
         self.assert_no_caught_exception()
         with self.assertRaises(Exception):
             self.assert_reply()
 
     def test_close_not_recognized_because_of_protocol_1_8_0(self):
@@ -926,24 +1012,29 @@
         self.send_request("0|CLOSE|S|reason|S|any-reason")
         self.assert_no_caught_exception()
         with self.assertRaises(Exception):
             self.assert_reply()
 
     def test_remote_credentials_with_user_and_password(self):
         self.setup_remote_adapter(username="remote1", password="fdhjkslghak")
-        self.assert_reply("1|RAC|S|user|S|remote1|S|password|S|fdhjkslghak|S|"
-                          "enableClosePacket|S|true")
+        self.assert_reply("1|RAC|S|user|S|remote1|S|password|S|fdhjkslghak"
+                          "|S|enableClosePacket|S|true"
+                          "|S|SDK|S|Python+Adapter+SDK")
 
     def test_remote_credentials_with_user(self):
         self.setup_remote_adapter(username="remote1")
-        self.assert_reply("1|RAC|S|user|S|remote1|S|enableClosePacket|S|true")
+        self.assert_reply("1|RAC|S|user|S|remote1"
+                          "|S|enableClosePacket|S|true"
+                          "|S|SDK|S|Python+Adapter+SDK")
 
     def test_remote_credentials_with_password(self):
         self.setup_remote_adapter(password="fdhjkslghak")
-        self.assert_reply("1|RAC|S|password|S|fdhjkslghak|S|enableClosePacket|S|true")
+        self.assert_reply("1|RAC|S|password|S|fdhjkslghak"
+                          "|S|enableClosePacket|S|true"
+                          "|S|SDK|S|Python+Adapter+SDK")
 
     def test_remote_credentials_with_no_credentials(self):
         self.setup_remote_adapter()
         assert_credentials_response(self)
 
 
 class MetadataProviderServerTest(RemoteAdapterBase):
@@ -956,15 +1047,17 @@
             adapter,
             RemoteAdapterBase.PROXY_METADATA_ADAPTER_ADDRESS)
         self.launch_remote_server(remote_server, set_exception_handler=True)
 
     def do_init_and_skip(self):
         # RAC reply always received.
         assert_credentials_response(self)
-        self.send_request("10000010c3e4d0462|MPI", True)
+        self.send_request("10000010c3e4d0462|MPI"
+                          "|S|ARI.version|S|" + basic_version)
+        self.skip_messages()
 
     def test_notify_user(self):
         self.do_init_and_skip()
         self.send_request("10000010c3e4d0462|NUS|S|userX|S|remote_password|S|"
                           "host|S|www.mycompany.com")
 
         self.assert_reply("10000010c3e4d0462|NUS|D|12.3|B|1")
```

## Comparing `lightstreamer_adapter-1.2.3/tests/test_metadata_protocol.py` & `lightstreamer_adapter-1.3.0/tests/test_metadata_protocol.py`

 * *Files identical despite different names*

